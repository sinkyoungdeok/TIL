# 클라우드 네이티브를 위한 쿠버네티스 실전 프로젝트 

## 1. 컨테이너 기술 보급과 쿠버네티스

<details><summary> 1. 컨테이너란 </summary>

### 1. 컨테이너란 

#### 컨테이너 vs 가상머신


![image](https://user-images.githubusercontent.com/28394879/152093444-1ec4e0ef-8628-44b1-ba01-5d5413810eec.png)
자료: Google Cloud 홈페이지

**가상머신**  
- 호스트OS에 하이퍼바이저를 설치하고 그 위에 게스트 OS를 동작 

**컨테이너**
- 호스트OS에 컨테이너 런타임을 올리고 그 위에 프로세서로서 컨테이너를 동작
- 호스트OS의 커널을 공유하면서 분리된 프로세스로서 실행해 마치 가상 머신이 움직이는 것처럼 보이는 기술
- 컨테이너 실체는 단순한 프로세스이므로 가상 머신에 비해 매우 가볍고 빠르게 동작 가능

</details>

<details><summary> 2. 도커란 </summary>

### 2. 도커란

#### 2.1 도커의 특징과 장점
- 도커는 컨테이너를 동작시키기 위한 엔진 중 하나이다.
- 단기간에 인기를 얻은 두가지의 특징을 가짐
  - 컨테이너 관리 방식 (Dockerfile로 동일한 컨테이너 이미지를 간단히 만들 수 있음)
  - 컨테이너 이미지를 저장, 공유하기 위한 에코시스템이 초기부터 준비되었다 (도커 허브)
- 도커 허브에 이미지를 전송하거나 다운로드 함으로써, 개발 환경, 스테이징 환경과 서비스 환경으로 동일한 컨테이너 이미지를 배포할 수 있으므로 테스트를 거친 컨테이너 이미지를 서비스 환경에 안정적으로 배포할 수 있다. 

#### 2.2 도커를 통한 조직의 문제 해결 

**도커 이전의 관리 방법**  
인프라팀: OS(커널), OS(커널 이외), 실행 런타임(자바 등), 미들웨어(톰캣 등) 등을 준비하고 관리 한다.  
애플리케이션팀: 애플리케이션을 준비하고 관리한다.

- 위처럼 두개의 팀으로 분업하더라도, 미들웨어 설정 변경 등이 필요하면 애플리케이션팀은 항상 인프라팀에 작업을 의뢰해야한다는 문제가 생긴다.
- 인프라팀은 많은 서버를 관리하고 있어 애플리케이션팀이 요구하는 환경을 제공할 떄 까지의 시간이 길어진다.
- 이 경우 애플리케이션팀이 Dockerfile로 미들웨어를 포함한 설정을 관리하면 빠르게 설정을 변경할 수 있다. 


**도커 이후의 관리 방법**  
인프라팀: OS(커널), 컨테이너 런타임 등을 준비하고 관리
애플리케이션팀: OS(커널 이외), 실행 런타임(자바 등), 미들웨어(톰캣 등) 애플리케이션 등을 준비하고 관리  

- 실행 런타임보다 상위 설정 등은 애플리케이션팀에서 준비하는 것이 효율적
- 보안 설정이 완료되고 안전한 도커 기본이미지를 인프라팀이 준비하고 개발자에게 제공하는 경우는 괜찮다. 
- 작은 변경 요청사항을 인프라팀이 일일히 받지 않아도 되기 떄문에 각 팀은 서로 장점만 취할 수 있다 

#### 2.3 도커의 과제와 오케스트레이션 도구의 필요성 
- 도커는 컨테이너 여러 개를 실행할 떄 문제가 있다.
- 보통 시스템 구성이 커지면 컨테이너 여러 개를 연결해 서비스 하나를 만들게 된다.
- 이런 구성일 때 문제 되는 것 중 하나로 컨테이너 사이의 통신과 가용성 확보가 있다.
- 서비스 환경에서 시스템을 동작시키기 위해 컴포넌트 각각을 다중화 하는 것은 기본이다.
  - 예) 컨테이너가 스케일 아웃 등을 하는 경우 로드밸런서에 어떻게 연결하는 것이 좋을까?
  - 예) 가상 머신 1대 안에서 컨테이너 여러 개를 동작시키는 경우 리소스 제어는 어떻게 하면 좋을까?
  - 위의 예시들은 한쪽 컨테이너에 부하가 높아져도 다른 한쪽 컨테이너의 성능이 떨어지지 않게 하는 다중화 관련 고민이다
- 이러한 과제를 해결하기 위해 등장한 것이 바로 쿠버네티스와 같은 컨테이너 오케스트레이션 도구들이다.

</details>

<details><summary> 3. 쿠버네티스란 </summary>

### 3. 쿠버네티스란

#### 3.1 쿠버네티스의 개념
- 쿠버네티스는 데이터 플레인이라는 서버를 여러 대 실행시켜 그 위에 가상 오케스트레이션 계층을 구축하고 거기에서 컨테이너가 동작한다.
  - 컨테이너 이용자는 컨테이너 그룹을 하나의 큰 머신 리소스로 볼 수 있어 인프라를 추상화할 수 있다. 
  - 여러 대의 서버로 구성이 가능하므로 단일 장애점을 배제할 수 있는 장점이 있다.
- 쿠버네티스는 어떤 가상 머신에서 어느 정도의 컨테이너를 동작시킬지를 관리하거나, 새로운 컨테이너를 배포할 때 어떤 가상 머신에 배포하면 좋을지 등을 자동으로 판단한다.
  - 장애가 발생한 컨테이너를 정지시키고 재시작하는 구조도 갖고 있다.
  - 이러한 기능은 컨트롤 플레인이라는 마스터 노드 그룹에서 구현된다 

![image](https://user-images.githubusercontent.com/28394879/152100663-4307f79a-333c-4c70-83a3-90f412ea45fd.png)


#### 3.2 쿠버네티스의 기본 오브젝트

**파드**  
- 쿠버네티스의 최소 단위
- 파드 하나 안에서는 하나 이상의 컨테이너를 동작시킬 수 있다.
- 파드에서는 어떤 컨테이너 이미지를 사용할지 등을 설정한다.

**레플리카셋**  
- 파드를 얼마나 동작시킬지 관리하는 오브젝트
- 레플리카셋에서 파드의 수를 설정하면 그만큼의 파드가 동작하는 것을 보장한다.

**디플로이먼트**  
- 배포 이력을 관리한다.
- 애플리케이션의 새로운 버전을 릴리즈하거나, 부하 증가에 따라 레플리카셋 수를 변경하는 등을 관리할 수 있다.
- 새로운 버전의 애플리케이션 릴리즈 이후 문제가 발생하면 바로 이전 버전으로 쉽게 롤백할 수 있다.
- 서비스를 운영하는 상황 대부분에서 파드를 동작시킬 떄는 디플로이먼트 단위로 관리한다.

**서비스**
- 배포한 파드를 쿠버네티스 클러스터 외부에 공개하기 위한 구조를 제공한다.
- 공개하는 방법은 여러가지이고, 대표적인 방법이 로드밸런서를 사용하는 것이다.
- 클러스터 내에 파드 여러 개를 동작시킨 경우 그 앞단에 로드밸런서를 배치하여 특정 파드를 클러스터 외부로 공개할수 있다.

![image](https://user-images.githubusercontent.com/28394879/152099980-fc9ad096-83ed-4f31-bf31-34a3beb269c1.png)
- 출처: 클라우드 네이티브를 위한 쿠버네티스 실적 프로젝트 책

</details>

<details><summary> 4. Amazon EKS란 </summary>

</details>