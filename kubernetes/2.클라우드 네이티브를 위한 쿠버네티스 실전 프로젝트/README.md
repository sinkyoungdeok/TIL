# 클라우드 네이티브를 위한 쿠버네티스 실전 프로젝트 

## 1. 컨테이너 기술 보급과 쿠버네티스

<details><summary> 1. 컨테이너란 </summary>

### 1. 컨테이너란 

#### 컨테이너 vs 가상머신


![image](https://user-images.githubusercontent.com/28394879/152093444-1ec4e0ef-8628-44b1-ba01-5d5413810eec.png)
자료: Google Cloud 홈페이지

**가상머신**  
- 호스트OS에 하이퍼바이저를 설치하고 그 위에 게스트 OS를 동작 

**컨테이너**
- 호스트OS에 컨테이너 런타임을 올리고 그 위에 프로세서로서 컨테이너를 동작
- 호스트OS의 커널을 공유하면서 분리된 프로세스로서 실행해 마치 가상 머신이 움직이는 것처럼 보이는 기술
- 컨테이너 실체는 단순한 프로세스이므로 가상 머신에 비해 매우 가볍고 빠르게 동작 가능

</details>

<details><summary> 2. 도커란 </summary>

### 2. 도커란

#### 2.1 도커의 특징과 장점
- 도커는 컨테이너를 동작시키기 위한 엔진 중 하나이다.
- 단기간에 인기를 얻은 두가지의 특징을 가짐
  - 컨테이너 관리 방식 (Dockerfile로 동일한 컨테이너 이미지를 간단히 만들 수 있음)
  - 컨테이너 이미지를 저장, 공유하기 위한 에코시스템이 초기부터 준비되었다 (도커 허브)
- 도커 허브에 이미지를 전송하거나 다운로드 함으로써, 개발 환경, 스테이징 환경과 서비스 환경으로 동일한 컨테이너 이미지를 배포할 수 있으므로 테스트를 거친 컨테이너 이미지를 서비스 환경에 안정적으로 배포할 수 있다. 

#### 2.2 도커를 통한 조직의 문제 해결 

**도커 이전의 관리 방법**  
인프라팀: OS(커널), OS(커널 이외), 실행 런타임(자바 등), 미들웨어(톰캣 등) 등을 준비하고 관리 한다.  
애플리케이션팀: 애플리케이션을 준비하고 관리한다.

- 위처럼 두개의 팀으로 분업하더라도, 미들웨어 설정 변경 등이 필요하면 애플리케이션팀은 항상 인프라팀에 작업을 의뢰해야한다는 문제가 생긴다.
- 인프라팀은 많은 서버를 관리하고 있어 애플리케이션팀이 요구하는 환경을 제공할 떄 까지의 시간이 길어진다.
- 이 경우 애플리케이션팀이 Dockerfile로 미들웨어를 포함한 설정을 관리하면 빠르게 설정을 변경할 수 있다. 


**도커 이후의 관리 방법**  
인프라팀: OS(커널), 컨테이너 런타임 등을 준비하고 관리
애플리케이션팀: OS(커널 이외), 실행 런타임(자바 등), 미들웨어(톰캣 등) 애플리케이션 등을 준비하고 관리  

- 실행 런타임보다 상위 설정 등은 애플리케이션팀에서 준비하는 것이 효율적
- 보안 설정이 완료되고 안전한 도커 기본이미지를 인프라팀이 준비하고 개발자에게 제공하는 경우는 괜찮다. 
- 작은 변경 요청사항을 인프라팀이 일일히 받지 않아도 되기 떄문에 각 팀은 서로 장점만 취할 수 있다 

#### 2.3 도커의 과제와 오케스트레이션 도구의 필요성 
- 도커는 컨테이너 여러 개를 실행할 떄 문제가 있다.
- 보통 시스템 구성이 커지면 컨테이너 여러 개를 연결해 서비스 하나를 만들게 된다.
- 이런 구성일 때 문제 되는 것 중 하나로 컨테이너 사이의 통신과 가용성 확보가 있다.
- 서비스 환경에서 시스템을 동작시키기 위해 컴포넌트 각각을 다중화 하는 것은 기본이다.
  - 예) 컨테이너가 스케일 아웃 등을 하는 경우 로드밸런서에 어떻게 연결하는 것이 좋을까?
  - 예) 가상 머신 1대 안에서 컨테이너 여러 개를 동작시키는 경우 리소스 제어는 어떻게 하면 좋을까?
  - 위의 예시들은 한쪽 컨테이너에 부하가 높아져도 다른 한쪽 컨테이너의 성능이 떨어지지 않게 하는 다중화 관련 고민이다
- 이러한 과제를 해결하기 위해 등장한 것이 바로 쿠버네티스와 같은 컨테이너 오케스트레이션 도구들이다.

</details>

<details><summary> 3. 쿠버네티스란 </summary>

### 3. 쿠버네티스란

#### 3.1 쿠버네티스의 개념
- 쿠버네티스는 데이터 플레인이라는 서버를 여러 대 실행시켜 그 위에 가상 오케스트레이션 계층을 구축하고 거기에서 컨테이너가 동작한다.
  - 컨테이너 이용자는 컨테이너 그룹을 하나의 큰 머신 리소스로 볼 수 있어 인프라를 추상화할 수 있다. 
  - 여러 대의 서버로 구성이 가능하므로 단일 장애점을 배제할 수 있는 장점이 있다.
- 쿠버네티스는 어떤 가상 머신에서 어느 정도의 컨테이너를 동작시킬지를 관리하거나, 새로운 컨테이너를 배포할 때 어떤 가상 머신에 배포하면 좋을지 등을 자동으로 판단한다.
  - 장애가 발생한 컨테이너를 정지시키고 재시작하는 구조도 갖고 있다.
  - 이러한 기능은 컨트롤 플레인이라는 마스터 노드 그룹에서 구현된다 

![image](https://user-images.githubusercontent.com/28394879/152100663-4307f79a-333c-4c70-83a3-90f412ea45fd.png)


#### 3.2 쿠버네티스의 기본 오브젝트

**파드**  
- 쿠버네티스의 최소 단위
- 파드 하나 안에서는 하나 이상의 컨테이너를 동작시킬 수 있다.
- 파드에서는 어떤 컨테이너 이미지를 사용할지 등을 설정한다.

**레플리카셋**  
- 파드를 얼마나 동작시킬지 관리하는 오브젝트
- 레플리카셋에서 파드의 수를 설정하면 그만큼의 파드가 동작하는 것을 보장한다.

**디플로이먼트**  
- 배포 이력을 관리한다.
- 애플리케이션의 새로운 버전을 릴리즈하거나, 부하 증가에 따라 레플리카셋 수를 변경하는 등을 관리할 수 있다.
- 새로운 버전의 애플리케이션 릴리즈 이후 문제가 발생하면 바로 이전 버전으로 쉽게 롤백할 수 있다.
- 서비스를 운영하는 상황 대부분에서 파드를 동작시킬 떄는 디플로이먼트 단위로 관리한다.

**서비스**
- 배포한 파드를 쿠버네티스 클러스터 외부에 공개하기 위한 구조를 제공한다.
- 공개하는 방법은 여러가지이고, 대표적인 방법이 로드밸런서를 사용하는 것이다.
- 클러스터 내에 파드 여러 개를 동작시킨 경우 그 앞단에 로드밸런서를 배치하여 특정 파드를 클러스터 외부로 공개할수 있다.

![image](https://user-images.githubusercontent.com/28394879/152099980-fc9ad096-83ed-4f31-bf31-34a3beb269c1.png)
- 출처: 클라우드 네이티브를 위한 쿠버네티스 실적 프로젝트 책

</details>

<details><summary> 4. Amazon EKS란 </summary>

### 4. Amazon EKS란

#### 4.1 EKS는 무엇을 해결하는가 
- 쿠버네티스 도입을 검토할 때 가장 큰 장벽은 '컨트롤 플레인의 유지 및 운영'이다
  - 쿠버네티스에서는 여러 컴포넌트들이 서로 독립적이고 비동기로 동작하며 전체를 구성한다
  - 각각의 구성 요소를 정상적으로 동작시키기 위한 설정이나 유지, 운영 장애가 발생했을 때의 복구 방법 등이 간단하지 않는다.
- EKS의 경우 이런 유지, 운영을 AWS에서 대신해준다.

![image](https://user-images.githubusercontent.com/28394879/152101164-15fa2f33-d04e-42fe-9ee9-33b1010d643d.png)


#### 4.2 EKS의 특징
- 쿠버네티스와 완전한 호환성을 갖는다.
- AWS의 다른 서비스들과 연결하거나 기존 구조와 같은 환경으로 이용할 수 있다 

**VPC의 통합**
- 일반적으로 쿠버네티스 클러스터에서는 파드 네트워크로 데이터 플레인의 네트워크와는 다른 자체 네트워크 체계를 배치한다.
- 클러스터 외부에서 파드에 명시적으로 엔드포인터를 생성하지 않으면 통신이 불가능하다
- EKS에서는 VPC통합 네트워킹을 지원하고 있어, 파드에서 VPC 내부 주소 대역을 사용할 수 있고 클러스터 외부와의 통신을 SeamLess하게 구현할 수 있다
  
![image](https://user-images.githubusercontent.com/28394879/152101592-d93750eb-d7a1-4287-8b25-213c7bc3a3bb.png)


**IAM을 통한 인증과 인가**
- 쿠버네티스 클러스터는 kubectl이라는 명령줄 도구를 사용하여 조작한다.
- 해당 조작이 허가된 사용자에 의한 것임을 올바르게 인증 해야한다.
- 인증된 사용자에게 어떤 조작을 허가할지에 대한 인가 구조도 필요하다.

![image](https://user-images.githubusercontent.com/28394879/152101838-cfe1c407-5815-4593-8e37-a33bc086131e.png)


**ELB와의 연계**  
- 쿠버네티스 클러스터 외부에서 접속할 때 사용하는 서비스 중 가장 전형적인 엔드포인트
- EKS에서 LoadBalancer를 설정하면 자동으로 ELB가 생성됨
![image](https://user-images.githubusercontent.com/28394879/152111523-d99f2c2b-a199-4bbd-b81b-af434de2bbde.png)

**데이터 플레인 선택**  
![image](https://user-images.githubusercontent.com/28394879/152112307-5d5cd368-2b14-411d-b441-6b2b5aa0652f.png)


</details>

<details><summary> 요약 </summary>

### 요약

- 컨테이너와 가상 머신의 차이
- 도커의 특징과 도커가 조직에 미치는 영향
- 많은 컨테이너를 운영할 때의 과제와 컨테이너 오케스트레이션의 필요성
- 쿠버네티스의 역사와 개념, 사용해야 하는 이유
- 쿠버네티스 기본 오브젝트
- EKS는 컨트롤 플레인의 관리형 서비스
- EKS의 특징(VPC, IAM, ELB 연계 등)
- 사용자가 EC2에 직접 구축하여 관리하는 방법 외에 관리형 노드 그룹과 파게이트 등의 운영 효율화 가능을 제공하는 EKS의 데이터 플레인들과 선택 기준

</details>

## 2. 쿠버네티스 환경 구축과 예제 애플리케이션 배포

<details><summary> 1. 예제 애플리케이션의 개요와 AWS의 기본 </summary>

### 1. 예제 애플리케이션의 개요와 AWS의 기본

#### 1.2 예제 애플리케이션의 개요
- 예제 애플리케이션은 마음에 드는 장소를 등록하는 서비스이다.
- 장소를 표시, 등록하는 웹 애플리케이션과 장소 정보를 일괄 등록하는 배치 애플리케이션을 구성한다.

![image](https://user-images.githubusercontent.com/28394879/152114066-c1e4e189-e680-4a59-8f9c-9f5a66c36175.png)

![image](https://user-images.githubusercontent.com/28394879/152114231-2e6c24b3-02f1-4117-894f-2b18b83e3905.png)

**구성**
- 싱글 페이지 애플리케이션(SPA)의 프런드 엔드
- REST API를 제공하는 백엔드
- 스케줄되는 배치 애플리케이션

**설명**
- 프론트엔드
  - 파일을 S3에 저장, CloudFront를 통해 정적 웹 콘텐츠로 배포
- 백엔드
  - EKS 클러스터 워커 노드에 컨테이너로 배포하고 RDS 데이터베이스와 접속한다.
  - 접속은 가용성을 고려해 ELB로 부하를 분산한다.
  - 컨테이너 이미지는 ECR(Elastic Container Registry) 에 저장된다.
- 배치 애플리케이션
  - 백엔드와 마찬가지로 EKS에 배포되며, S3에 저장된 파일을 읽어와서 처리하고 RDS에 접속하여 쓰기를 실행한다.
  - 컨테이너 이미지는 ECR에 저장된다.
  - RDS의 데이터베이스 조작을 위해 EC2 인스턴스로 배스천 호스트를 구성한다. 

#### 1.3 AWS 관련 서비스 및 용어

**S3**
- 클라우드 스토리지 서비스 
- 높은 내구성을 가짐
- 미리 스토리지 용량 등을 정의하지 않고 사용가능
- 데이터 공개 정책, 데이터 암호화, 비용 효율적으로 데이터를 장기 보관하기 위한 라이프사이클 정책 등의 많은 기능을 제공  

**CloudFront**  
- 콘텐츠 전송 네트워크 서비스 (CDN)
- CDN은 인터넷에서 웹 콘텐츠, 이미지, 동영상, 애플리케이션 등을 빠르게 전송하기 위한 구조로 되어 있다.
- CloudFront는 전 세계에 많은 에지 로케이션(데이터를 전송하기 위한 지점)을 갖고 있다.
- 그러므로 사용자가 접속한 가장 가까운 장소에서 콘텐츠를 제공할 수 있다. 

**RDS**
- 관계형 데이터베이스 서비스이다.
- OS나 미들웨어 관리, 운영에 필요한 많은 작업을 담당하므로 개발, 운영에 필요한 인적 자원을 애플리케이션에 집중가능
- 멀티 AZ구성을 지원하고 서비스 환경 운영에서 요구되는 가용성을 실현할 수 있다 

**ECR**
- 컨테이너 레지스트리 관리형 서비스 
- 컨테이너를 이용하여 애플리케이션을 작동시키는 경우 컨테이너 이미지를 저장하고 다운로드할 수 있는 구조로 컨테이너 레지스트리를 사용한다.
  - 컨테이너 레지스트리는 컨테이너 이미지를 보관하는 리포지터리이며 도커 명령어를 사용하여 컨테이너 이미지를 등록 및 다운로드 한다.
- 쿠버네티스 클러스터에도 컨테이너 이미지는 컨테이너 레지스트리를 통해 다운로드하는 구조로 되어 있다.

**EC2**
- 가상 머신을 사용할 수 있는 서비스
- 다양한 형태의 가상머신을 쉽게 구축하고 운영 가능

**ELB**
- 로드밸런서 서비스다
- Applicaiton Load Balancer는 HTTP/HTTPS에 특화된 L7 로드밸런서이다.
  - 경로 기반 라우팅, 호스트 기반 라우팅 등 HTTP 고유의 처리가 가능
- Network Laod Balancer는 L4 로드밸런서이다.
  - HTTP/HTTPS 외의 프로토콜에서도 사용 가능
- GateWay Load BAlancer는 다른 회사의 가상 네트워킹 어플라이언스의 배포, 확장, 실행을 돕는다.
  - 여러 회사의 어플라이언스에 대한 로드 밸런싱 및 자동 조정 기능을 제공 
- Classic Load Balancer는 HTTP/HTTPS와 TCP로 분산 설정이 가능하고 기본적인 로드밸런서 기능을 제공한다.
  - 제약사항이 많다 

**IAM**
- AWS 리소스에 접속하는 사용자나 권한을 관리하는 서비스
- IAM 역할을 생성하여 리소스에 설정함으로써 해당 리소스에 다른 리소스에 대한 접근 권한을 부여할 수 있다.

#### 1.4 EKS 구축에 사용하는 도구 

**EKS 클러스터를 구축하는 방법**
- EKS 클러스터 구축 도구 eksctl을 이용하는 방법
- AWS 관리 콘솔(또는 AWS CLI)을 이용하는 방법
- 여기에서는 eksctl을 설명한다.

**eksctl란**
- EKS 클러스터 구축 및 관리를 하기 위한 오픈소스 명령줄 도구
- `eksctl create cluster` 명령만으로 EKS 클러스터를 기본 구성으로 구축할 수 있다.
- eksctl을 사용하면 VPC, 서브넷, 보안 그룹 등 EKS 클러스터를 구축하는데 필요한 리소스를 한번에 구성이 가능하다.
- 이미 만들어둔 VPC등의 기본 리소스랑도 연결할 수 있다. 

**VPC 관련 용어**
- 1개의 AWS 계정에 VPC 여러 개를 생성할 수 있지만, 기본적으로 VPC끼리는 독립적인 환경이고 명시적으로 VPC를 연결하지 않는 한 VPC간 통신은 할 수 없다.
- VPC는 서브넷을 사용해 네트워크를 분할하여 관리한다.
  - 서브넷은 가용 영역 여러개를 동시에 사용할 수 없으며 가용 영역 여러개를 사용할 경우 서브넷도 그만큼 나눠야 한다

**CloudFormation을 이용한 환경 구축**
- AWS 리소스는 AWS 관리 콘솔이나 AWS CLI등 여러 방법으로 구축 가능하지만, 관련 리소스를 한번에 구축하고 필요에 따라 변경 및 삭제할 때는 CloudFormation이 적합하다.
- JSON 또는 YAML 형식으로 리소스 구성을 정의한다.

**AWS 관리 콘솔**
- AWS 서비스를 관리하기 위한 웹 사용자 인터페이스다. 
- AWS의 가장 일반적인 조작 방법이며 GUI 기반이므로 AWS에 익숙하지 않은 사람도 쉽게 사용 가능하다.

**AWS CLI**
- AWS가 제공하는 명령줄 도구로 AWS 리소스 관리에 많이 사용된다.
- AWS CLI는 파이썬으로 만들어진 도구로 인스톨러가 제공되며 pip를 이용해 설치할 수도 있다

</details>

