- [출처](#출처)
- [1. 엔지니어링](#1-엔지니어링)
    - [어제까지 알고 있던 모든것들이 언제까지 사실이고 진실이지 않다.](#어제까지-알고-있던-모든것들이-언제까지-사실이고-진실이지-않다)
    - [과학과 엔지니어링](#과학과-엔지니어링)
    - [엔지니어는 이론을 이용하되, 매몰되지는 말아야 한다.](#엔지니어는-이론을-이용하되-매몰되지는-말아야-한다)
    - [좋은 엔지니어는](#좋은-엔지니어는)
    - [패턴이란](#패턴이란)
    - [패턴은 해독제와 비슷하다.](#패턴은-해독제와-비슷하다)
    - [은탄환은 없다](#은탄환은-없다)
    - [TDD도 모든 문제를 해결해주지 않는다.](#tdd도-모든-문제를-해결해주지-않는다)
    - [근육 기억](#근육-기억)
    - [이규원님의 경험) 반복이 완벽함을 만든다.](#이규원님의-경험-반복이-완벽함을-만든다)
- [2. 테스트 주도 개발 기초](#2-테스트-주도-개발-기초)
  - [1. 코드 기능 명세](#1-코드-기능-명세)
    - [도메인](#도메인)
    - [비즈니스 시스템의 도메인 지식 흐름](#비즈니스-시스템의-도메인-지식-흐름)
    - [비즈니스 전문가란](#비즈니스-전문가란)
    - [분석가란](#분석가란)
    - [프로그래머란](#프로그래머란)
    - [컴퓨터](#컴퓨터)
    - [프로그래머와 기능 명세](#프로그래머와-기능-명세)
    - [무책임하고 위험한 도박의 예시](#무책임하고-위험한-도박의-예시)
  - [2. 테스트 기법](#2-테스트-기법)
    - [수등 테스트](#수등-테스트)
    - [소프트 웨어 회귀](#소프트-웨어-회귀)
    - [회귀테스트 대상](#회귀테스트-대상)
    - [테스트 자동화](#테스트-자동화)
    - [인수 테스트](#인수-테스트)
    - [단위 테스트](#단위-테스트)


# 출처 

- 강의: https://fastcampus.co.kr/dev_red_ygw
- 강사: 이규원님


# 1. 엔지니어링 

### 어제까지 알고 있던 모든것들이 언제까지 사실이고 진실이지 않다.
- 어떤 것들은 오래된 것들이 지금까지 계속 도움이 되는 것들이 있는 반면
- 어떤 것들은 옳다고 믿었던 것들인데, 지금와서는 잘못된 것으로 판명되어서 좋은 영향보다는 나쁜 영향을 줄 수도 있다. 
- 원랜 좋았던 도구들도 시대가 흐르면서 안좋은 도구로 변하기도 한다 
- 믿고 있던것들을 계속 믿기 보다는 더 좋은 방법이 없을까를 고민해야 된다.
  
### 과학과 엔지니어링
- 과학은 밝혀내고 
- 엔지니어링은 해결한다 -> 문제를 해결한다 
  - 대부분의 개발은 거의 엔지니어링에 가깝다
  - 엔지니어링은 과학을 이용하되, 주어진 자원을 고려해서 수행해야 한다.

### 엔지니어는 이론을 이용하되, 매몰되지는 말아야 한다.
- 클린코드라는 용어가 되게 핫한데, 
- 지나치게 클린코드에 빠져들고 있는 프로그래머들의 언행들은 좋게 보이지 않는다.
- 종종 클린코드에 빠져 드는 사람의 말을 들어보면, 마치 어디에나 통용될 수 있는 보편적인 코드 기준을 이야기하는 것 같은 느낌이 든다.
  - 그럼, 코드를 평가하는 보편적인 기준을 얻음으로써 얻는게 무엇이 있을까?
  - 왜 클린 코드를 추구해야 하는 것일까?
  - 이런 질문에 명확하게 답변하는 사람들은 많지 않다.
- 클린 코드가 제시하고 있는 조건들이 나쁘진 않지만, 엔지니어링을 하는 엔지니어로써 보편적인 높은 기준을 가지고 일을 하는 사람인가를 되돌아 봐야한다.
- 주어진 임무가 제시하는 코드의 기준은 매번 달랐다.
  - 어떤 때에는 클린코드가 제시하는 기준과 일치하기도 하고,
  - 어떤 때에는 굉장히 많은 차이가 있기도 한다.

### 좋은 엔지니어는
- 보편적인 기준을 다루기 보다는, 그때 그때 적절한 코드를 다루는 것이 중요하다.


### 패턴이란
- 알려진 문제의 일반적이고 재사용할 수 있는 해결법
- 프로그래머는 고유한 문제를 풀어야 한다
- 고유한 문제는 좀 더 작은 하위 기술 문제를 가진다
- 이 작은 기술 문제들 중 많은 일부는 과거 어디에 선가 여러 번 반복되고 해결된 적이 있다.


### 패턴은 해독제와 비슷하다.
- 적절한 병에 맞는 해독제를 먹어야 병이 낫는 것 처럼
- 패턴도 적절한 곳에 쓰여야 문제를 적절하게 해결할 수 있다.
- 패턴을 어떻게 쓰는 것 인지 보다는 언제 이 패턴을 써야하는지를 익혀야 한다. 
- 어디에나 통하는 만병통치약과 같은 패턴은 없다.

### 은탄환은 없다 
- 프로그래밍은 협업이다.
  - 내가 상대방 코드를 봤을 때 쓰레기라고 느낄 수 있지만, 상대방도 그럴 수 있다.
  - 하지만, 중요한 것은 서로의 기준에서 좋은 코드를 작성하는 것 보다는 우리가 어떤 목표를 공유하고 있느냐가 중요하다. 
- 시스템은 연결된다
  - 다른회사 혹은 옆팀의 코드는 왜 저따구일까 라는 생각을 할 수도 있다.
  - 하지만, 그따위의 시스템도 내막을 알게 되면 다 사정이 있어서 아픈 역사를 가져서 그렇게 설계되었을 수도 있고,
  - 우리가 모르는 어떤 문제를 해결하기 위해 생각하고 있는 거랑 다른 방식으로 해결 되었을 수 있다. 
- 도구 상자에 다양한 도구를 채우자
  - 한가지, 어디에나 들어맞는 도구를 준비 하기 보다는 
  - 다양한 도구를 준비해서 우리에게 주어진 상황에 가장 적합한 도구를 꺼내서 쓸 수 있어야 한다. 
- 엔지니어링은 거래(trade-off)이다.
  - 우리가 가지고 있는 도구가 완벽하게 동작하는 환경만 마주한다면 거래할 필요가 없겠지만, 그런일은 거의 발생하지 않는다. 
  - 우리는 일반적으로 엔지니어링을 통해서 우리 입장의 아주 심각한 문제를 덜 심각한 문제랑 맞 바꾸는 일을 자주 한다

### TDD도 모든 문제를 해결해주지 않는다.
- TDD도 어떤 환경에서는 적합해서 잘 동작하고 여러가지 도움을 주지만,
- 어떤 환경에서는 무리하게 도입하면 해가되는 경우도 있다.

### 근육 기억 
- 반복되는 문제 해결에 비용이 많이 쓰인다면 
- 연습하고, 연습하고, 연습해서 생각의 비용을 줄더들도록 뇌에 새겨라 
- 그러면, 새로운 문제에 더 많은 시간을 쓸 수 있다. 

### 이규원님의 경험) 반복이 완벽함을 만든다.
- 테스트 관련해서 나쁜 습관이 있다는 것을 깨닫고
- 2주 정도 동안 나쁜 버릇을 사용해서 작성한 테스트케이스 1000개를 더 좋은 방식으로 개선했던 경험이 있다.
- 그 결과 테스트 코드와 운영 코드의 결합을 맞춰서 유연한 설계를 얻을 수 있게 되었고 
- 이 경험은 지금까지 근육 기억으로 남아 있다.


# 2. 테스트 주도 개발 기초 

## 1. 코드 기능 명세 

### 도메인 
- 소프트웨어는 문제를 푸는 도구 
- 도메인은 소프트웨어가 풀어야 할 문제가 정의되는 공간
  - 비즈니스 시스템의 도메인은 비즈니스
- 문제를 충분히 이해하지 못하면 문제를 푸는 도구를 잘 만들 수 없다
  - 틱택토 게임을 이해하지 못하면 틱택토 컴퓨터 게임을 만들 수 없다 


### 비즈니스 시스템의 도메인 지식 흐름
```mermaid
graph LR;

비즈니스전문가 --> 분석가 --> 프로그래머 --> 컴퓨터
```
- <-- : 목적/추상적 
- --> : 수단/구체적 
- 분석가: 제품 관리자 / 서비스 기획자 / 프로그래머


### 비즈니스 전문가란 
- 문제를 가장 잘 이해한다.
  - 시스템이 투영해야 할 핵심 지식의 원천 
- 문제 설명력 부족 (프로그래머 입장에서 봤을 때)
  - 지식의 저주 
- 풀이도 가장 잘 이해한다고 착각
  - 문제를 말해야 할 때 풀이를 말하려는 경향을 가짐 
  - 의사한태 가서 비염때문에 왔어요 라고 하면 의사는 증상을 말하라고 한다. (의사: 프로그래머, 비염환자: 비즈니스 전문가)

### 분석가란 
- 비즈니스 전문가로부터 시스템 요구사항을 발굴한다
- 발굴된 요구사항의 오류 탐색 
- 발견된 문제점을 구현 작업 전에 협업을 통해 해결
- 요구사항이 기존의 시스템에 충돌되는 것은 없는지 검증을 찾아내야 하므로 시스템의 이해도도 필요하다.

### 프로그래머란 
- 정제된 기능 명세를 아키텍처와 코드로 번역 
  - 제품 제작 과정 중 비용이 가장 큰 직업
- 끊임없는 설계 결정
- 지식 흐름 과정의 마지막 인간

### 컴퓨터
- 코드를 통해 프로그래머로부터 지식을 전달받음
- 철저히 수동적
- 융통성 없음

### 프로그래머와 기능 명세
- 컴퓨터는 스스로 설계를 결정하지 않기 떄문에 
  - 프로그래머가 도메인 지식을 컴퓨터에 전달 할 때에는 
  - 모든 요소들이 명확히 결정될 수 밖에 없다 
- 충분히 명확한 도메인 지식을 확보하지 못한 프로그래머는 
  - 지식 흐름 상류에 지식 보강을 요청해야함 (분석가 혹은 비즈니스 전문가)
- 하지만 어떤 프로그래머는 스스로 결정을 내림 
  - 도메인 지식 투영에 오차 발생
  - 무책임하고 위험한 도박 

### 무책임하고 위험한 도박의 예시
- 배경
  - 어떤 회사가 분산 값을 통계값을 계산하는 제품을 만들려고 한다.
  - 프로그래머는 분산을 계산하는 공식을 전달 받았고,
  - 샘플 예제를 하나 받았다. `1+2+3+4+5+6 = 3.5`

```python
S = list(map(float, input().split()))

sum = sum(S)
mean = sum / len(S)

sumOfSquares = 0.0
for s in S:
    sumOfSquares += (s - mean) ** 2

variance = sumOfSquares / (len(S) - 1)

print("분산", variance)

"""
INPUT1
1.0 2.0 3.0 4.0 5.0 6.0 

RESULT
분산 3.5
"""

"""
INPUT2 - BUG REPORT

RESULT
분산 -0.0 혹은 ERROR
"""
```

- INPUT1만 테스트해보고 서비스 오픈을 했는데
- INPUT2 케이스 에 대한 유저 컴플레인이 들어 왔다.
- 프로그래머는 그냥 이렇게 되는거 아니야? 라고 생각했지만, 통계전문가는 당연히 데이터가 없으면 분산은 계산할 수 없고 오류 메시지가 출력 되야지 라고 답을 한다.
- 프로그래머는 도메인지식을 프로그램에 투영 시켰지만, 저번에 전달 받았던 지식에서 누락된 지식을 깨달은 것이다.

```python
S = list(map(float, input().split()))

if len(S) == 0: # 추가
    print("데이터가 입력되지 않았습니다") 
    quit() 

sum = sum(S)
mean = sum / len(S)

sumOfSquares = 0.0
for s in S:
    sumOfSquares += (s - mean) ** 2

variance = sumOfSquares / (len(S) - 1)

print("분산", variance)

"""
INPUT1
1.0 2.0 3.0 4.0 5.0 6.0 

RESULT
분산 3.5
"""

"""
INPUT2 

RESULT
데이터가 입력되지 않았습니다. 
"""

"""
INPUT3 - BUG REPORT
1 

RESULT
분산 NaN 또는 ERROR
"""
```

- 통계 전문가: 분산을 계산하려면 적어도 2개이상은 입력해줘야 해

```python
S = list(map(float, input().split()))

if len(S) == 0: 
    print("데이터가 입력되지 않았습니다") 
    quit() 
if len(S) == 1:
    print("2개 이상의 데이터를 입력하세요.")
    quit()

sum = sum(S)
mean = sum / len(S)

sumOfSquares = 0.0
for s in S:
    sumOfSquares += (s - mean) ** 2

variance = sumOfSquares / (len(S) - 1)

print("분산", variance)

"""
INPUT1
1.0 2.0 3.0 4.0 5.0 6.0 

RESULT
분산 3.5
"""

"""
INPUT2 

RESULT
데이터가 입력되지 않았습니다. 
"""

"""
INPUT3 
1 

RESULT
2개 이상의 데이터를 입력하세요. 
"""
```

- 이제서야 오류 없는 프로그램이 완성되었지만,
- 프로그램을 이전 버전에서 사용한 사용자들은 이미 이탈을 했을 것이다.

## 2. 테스트 기법

### 수등 테스트 
- 품질 담당자(QA)가 UI를 사용해 기능을 검증
- 최종 사용자의 사용 경험과 가장 비슷하게 검증
- 실행 비용이 높고 결과의 변동이 큼
  - 어떤 테스트 대상 기능이 동작 하는데 필요한 모든 코드가 동작한다.
  - 일부 코드가 빠지면 동작하지 않는다. 
- 가장 온전한 코드 실행
- 인수 테스트 
  - 소프트웨어를 요청한 클라이언트가 제작된 소프트웨어를 인수 받아도 되는지 하는 테스트

### 소프트 웨어 회귀 
- 소프트웨어의 기능이 원래 동작했는데, 어떤 시점 이후 로는 동작하지 않는것
- 새로운 기능이 추가되고나서, 기존 기능이 오작동 하는 케이스


### 회귀테스트 대상
- 시간이 지날수록 회귀테스트의 대상은 늘어난다
- 새로운 기능을 추가한다고 해서 새로운 기능에 대해서만 테스트를 해서는 안된다.
  - 시스템이 정상적으로 동작한다는 것을 보장 하지 못하고,
  - 기존의 기능들까지 테스트해야 된다.
- 수동 테스트만으로는 이 늘어나는 비용을 감당하기가 힘들다.
  - 수동 테스트만 운영하는 팀에서는 많은 경우 
  - 새로운 영역에 대해서만 테스트하고
  - 기존의 영역에 대해서는 테스트하지 않는 경우도 있다. 


### 테스트 자동화 
1. 기능을 검증하는 코드를 작성
2. 테스트 코드 작성 비용이 소비되지만, 실행 비용이 낮고 결과의 신뢰도가 높음
   - 수동테스트는 사람이 직접 테스트해야 되기 때문에 비용이 높지만
   - 테스트 코드는 한번 만들어두면 실행 할 자동으로 처리할 수 있다.
3. 테스트코드 작성과 관리가 프로그래머 역량에 크게 영향 받음


### 인수 테스트
1. 배치된 시스템을 대상으로 검증
2. 전체 시스템 이상 여부 신뢰도가 높음
3. 높은 비용 
   - 작성 비용
   - 관리 비용
   - 실행 비용 
4. 피드백 품질이 낮음
   - 현상은 드러나지만 원인은 숨겨짐  

### 단위 테스트
1. 시스템의 일부(하위시스템)을 대상으로 검증
2. 낮은 비용 
   - 작성 비용
   - 관리 비용
   - 실행 비용 
3. 높은 피드백 품질
4. 전체 시스템 이상 여부 신뢰도가 낮음
   - 단위 시스템에 성공한 여러 하위 시스템들이 협력하는 과정에서 실패하는 케이스도 있다.

