
## 1장 사용자 수에 따른 규모 확장성 
한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로는 몇백만 사용자를 지원하는 시스템을 설계해 볼 것이다.


### 단일 서버

<img width="768" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/9b648507-0bfa-4a01-9e48-14fd42e7fcc1">

웹, 앱, 데이터베이스, 캐시 등이 전부 서버 한대에서 실행된다.

사용자 요청 처리 흐름은 다음과 같다. 

1. 도메인이름을 이용하여 웹사이트에 접속. 
2. 도메인 이름을 DNS(Domain Name Service)에 질의하여 IP 주소로 변환 
3. 해당 IP주소로 HTTP 요청이 전달
4. 웹서버에서 HTML or JSON 응답 반환 



### 데이터베이스

<img width="768" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/262181b3-a2e9-4c0e-8529-a68fce7bdd9a">

- 사용자가 늘면서 하나는 웹/모바일 트래픽 처리 용도의 서버, 다른 하나는 데이터베이스용 서버로 분리했다.
- 분리함으로써 각각을 독립적으로 확장해 나갈 수 있게 됐다.

**어떤 데이터베이스를 사용할 것인가?** 
- RDB vs NoSql 에서 고른다.
- RDB: Mysql, Oracle, PostgreSQL 등 
- NoSQL: CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등
- NoSQL은 네 부류로 나눌 수 있다.
  - key-value store
  - graph store
  - column store
  - document store
- RDB는 조인 연산을 지원하는 반면, NoSQL은 조인 연산을 지원하지 않는다. 
- 아래 케이스에선 NoSQL를 고려해보자.
  - 아주 낮은 응답 지연시간 필요
  - 데이터가 비정형임
  - 데이터를 serialize, deserialize 할 수 있기만 하면 됨
  - 

### 수직적 규모 확장 vs 수평적 규모 확장
- 스케일업(수직 = vertical scaling): 서버에 고사양 자원을 추가하는 행위
- 스케일 아웃(수평 = scale out): 더 많은 서버를 추가
- 트래픽 양이 적을 때는 스케일업이 좋은 선택이고 단순함이 큰 장점인 반면에 심각한 단점이 있다.
  - 한 대의 서버에 CPU나 메모리를 무한대로 증설 할 수 없으므로 한계가 있다.
  - 장애에 대한 자동복구 방안이나 다중화 방안을 제시할 수 없다.
- 대규모 애플리케이션에서는 scale out이 더 적절하다.

트래픽이 몰릴 때에는 load balancer를 도입해보자.

**로드밸런서**  

<img width="728" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/08338d86-af45-481b-8319-a1e5da13dd38">

- 사용자는 로드밸런서의 공개 IP 주소로 접속한다. 
- 부하 분산 집합에 웹 서버를 하나 더 추가하고 나면 장애를 자동복구하지 못하는 문제(no failover)는 해소되며, 웹 계층의 가용성(availability)은 향상된다.
  - 서버한대가 다운되면(offline) 다른 서버로 트래픽이 전송된다.
  - 트래픽이 급증하면 서버 1대이상을 추가하기만 하면 된다. 

웹 계층은 이제 괜찮은데, DB는 하나 뿐이고 장애의 자동복구나 다중화를 지원하지 않는다.  
DB 다중화는 이런 문제를 해결하는 보편화된 기술이다.


**데이터베이스 다중화**  

- 보통 DB는 서버 사이에 master-slave 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장한다.
- 쓰기 연산은 마스터에서만 지원한다.
- slave DB는 master DB 로부터 사본을 전달 받으며, 읽기 연산만을 지원한다. 
- 대부분의 애플리케이션은 읽기 연산 비중이 쓰기 연산보다 훨씬 높기 때문에, slave DB 수를 더 많이 구성한다.


<img width="816" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/6c43457a-2c25-4da9-960a-5939cd149818">

- 데이터베이스를 다중화하면 다음과 같은 이득이 있다. 
  - 더 나은 성능: 병렬로 처리될 수 있는 query 수가 늘어나서 성능이 올라간다. 
  - 안정성: DB 일부가 죽더라도 데이터는 보존된다. 데이터를 지역적으로 떨어진 여러 장소에 다중화 시킬수도 있다.
  - 가용성: 데이터를 여러 지역에 복제해 둠으로써, 하나의 DB에 장애가 발생해도 다른 서버에 있는 데이터를 가져와서 서비스할 수 있다. 
- 데이터베이스 한대가 다운되면 어떤일이 벌어질까?
  - slave DB가 한대인데 다운된경우
    - 읽기 연산이 일시적으로 master DB로 감.
    - 새로운 slave DB가 장애서버를 대체 
  - slave DB가 여러대인데 다운된경우
    - 읽기 연산이 나머지 slave DB로 간다.
    - 새로운 slave DB가 장애서버를 대체 
  - master DB가 한대인데 다운된경우
    - slave DB가 master DB로 승격된다.
    - 모든 연산은 새로운 master DB로 수행된다.
    - 그리고 새로운 slave DB가 추가된다. 
    - 부 서버에 보관된 데이터가 최신 상태가 아닐 수 있는데, 이 때에는 없는 데이터에 대해서 복구 스크립트를 돌려서 추가해야 한다. 
    - 다중 마스터(multi-masters)나 원형 다중화(circular replication) 방식을 도입하면 이런 상황을 대처하는데 도움이 되지만 구성이 훨씬 복잡해진다. 

<img width="868" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/652e7778-0ae2-490f-84d8-94224e4cb10d">
- 로드밸런서 + DB 다중화를 고려한 설계 


다음은 응답시간을 개선해보자.  
응답시간은 캐시를 붙이고 정적 컨텐츠를 CDN으로 옮기면 개선할 수 있다.


### 캐시
- 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 빨리 처리될 수 있도록 하는 저장소다.

**캐시 계층**  
- 캐시 계층은 데이터가 잠시 보관되는 곳으로 DB보다 훨씬 빠르다.
- 성능 개선 뿐 아니라 DB 부하를 줄일 수 있고, 캐시 계층을 독립적으로 확장시키는 것도 가능하다. 

<img width="802" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/cc0b0344-f7fb-44ac-83a2-fd3573a03173">

- 이러한 캐시 전략을 읽기 주도형 캐시 전략이라고 부른다.
- 이것 이외에도 다양한 캐시 전략이 있는데, 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택하면 된다.

**캐시 사용 시 유의할 점**  
- 캐시는 어떤 상황에 바람직한가? 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려해보자.
- 어떤 데이터를 캐시에 두어야 하는가? 캐시 데이터는 휘발성 메모리에 두므로, 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다. 
- 캐시에 보관된 데이터는 어떻게 만료 되는가? 이에 대한 정책을 마련해 두는 것이 좋다. 만료 기한은 너무 짧거나 길면 곤란하다. DB를 너무 자주 읽거나, 원본과 차이날 수 있기 때문이다.
- 일관성은 어떻게 유지되는가? 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 일관성은 깨질 수 있다. 
- 장애에는 어떻게 대처할 것인가? 캐시 서버를 한 대만 두는 경우 SPOF가 될 수 있다. 특정 지점의 장애가 전체시스템의 동작을 중단시킬 수 있는 경우가 SPOF인데, SPOF를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.

<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/5044d3ad-e628-4ac6-9072-5cef4f2de623">
- 캐시 메모리는 얼마나 크게 잡을 것인가? 캐시 메모리가 너무 작으면 데이터가 너무 자주 캐시에서 밀려나버려 캐시 성능이 저하될 수 있다.
- 데이터 방출(eviction) 정책은 무엇인가? 가장 널리 쓰이는 것은 LRU(마지막으로 사용된 데이터를 내보냄) 이다. LFU(사용 빈도가 가장 낮은 데이터를 내보내는 정책)이나 FIFO같은 것도 있는데 경우에 맞게 적용하자.


### CDN

- 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. 
- 이미지, 비디오, CSS, js 파일 등을 캐시할 수 있다. 
- request path, query string, cookie, request header 등의 정보에 기반하여 HTML 페이지를 캐시하는 것이다.

<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/62d15673-538f-4f8c-8b6b-7a9ee6fb3589">

- 어떤 사용자가 웹사이트를 방문하면, 그 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달한다.


<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/d81941b6-ee99-4060-a3c4-adab36acc354">


**CDN 사용 시 고려해야 할 사항**  
- 비용: CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금을 내게 된다. 자주 사용하지 않은 컨텐츠를 캐싱하는 것은 이득이 크지 않으므로 CDN에서 빼는 것을 고려하자.
- 적절한 만료 시한 설정: 시의성이 중요한(time-sensitive) 컨텐츠의 경우 만료 시점을 잘 정해야 한다.
- CDN 장애에 대한 대처 방안: CDN이 응답 하지 않을 경우, 문제를 감지하여 원본 서버로부터 직접 컨텐츠를 가져오도록 클라이언트를 구성하는것이 필요할 수 있다.
- 컨텐츠 무효화 방법: 아직 만료되지 않은 컨텐츠라 하더라도 아래 방법들 중 하나를 쓰면 CDN에서 제거할 수 있다.
  - CDN 서비스 사업자가 제공하는 API 사용 
  - 컨텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝이용. 컨텐츠의 새로운 버전을 지정하기 위해서 URL 마지막에 버전 번호를 인자로 주면 된다. ex) image.png?v=2 

<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/5d1f04cf-70b2-46f2-873e-2aac12bb7ceb">

- CDN과 캐시가 추가된 설계
- 변화된 부분
  - 정적컨텐츠는 CDN을 통해 제공하여 더 나은 성능을 보장한다.
  - 캐시가 데이터베이스 부하를 줄여준다.

### 무상태(stateless) 웹 계층 