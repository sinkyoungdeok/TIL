- [1장 사용자 수에 따른 규모 확장성](#1장-사용자-수에-따른-규모-확장성)
  - [단일 서버](#단일-서버)
  - [데이터베이스](#데이터베이스)
  - [수직적 규모 확장 vs 수평적 규모 확장](#수직적-규모-확장-vs-수평적-규모-확장)
  - [캐시](#캐시)
  - [CDN](#cdn)
  - [무상태(stateless) 웹 계층](#무상태stateless-웹-계층)
  - [데이터 센터](#데이터-센터)
  - [메시지 큐](#메시지-큐)
  - [로그, 메트릭, 그리고 자동화](#로그-메트릭-그리고-자동화)
  - [데이터베이스의 규모 확장](#데이터베이스의-규모-확장)
  - [백만 사용자, 그리고 그 이상](#백만-사용자-그리고-그-이상)
- [2장 개략적인 규모 추정](#2장-개략적인-규모-추정)
  - [2의 제곱수](#2의-제곱수)
  - [모든 프로그래머가 알아야 하는 응답지연 값](#모든-프로그래머가-알아야-하는-응답지연-값)
  - [가용성에 관계된 수치들](#가용성에-관계된-수치들)
  - [예제: 트위터 QPS와 저장소 요구량 측정](#예제-트위터-qps와-저장소-요구량-측정)
  - [팁](#팁)
- [3. 시스템 설계 면접 공략법](#3-시스템-설계-면접-공략법)
  - [효과적 면접을 위한 4단계 접근법](#효과적-면접을-위한-4단계-접근법)

## 1장 사용자 수에 따른 규모 확장성 
한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로는 몇백만 사용자를 지원하는 시스템을 설계해 볼 것이다.


### 단일 서버

<img width="768" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/9b648507-0bfa-4a01-9e48-14fd42e7fcc1">

웹, 앱, 데이터베이스, 캐시 등이 전부 서버 한대에서 실행된다.

사용자 요청 처리 흐름은 다음과 같다. 

1. 도메인이름을 이용하여 웹사이트에 접속. 
2. 도메인 이름을 DNS(Domain Name Service)에 질의하여 IP 주소로 변환 
3. 해당 IP주소로 HTTP 요청이 전달
4. 웹서버에서 HTML or JSON 응답 반환 



### 데이터베이스

<img width="768" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/262181b3-a2e9-4c0e-8529-a68fce7bdd9a">

- 사용자가 늘면서 하나는 웹/모바일 트래픽 처리 용도의 서버, 다른 하나는 데이터베이스용 서버로 분리했다.
- 분리함으로써 각각을 독립적으로 확장해 나갈 수 있게 됐다.

**어떤 데이터베이스를 사용할 것인가?** 
- RDB vs NoSql 에서 고른다.
- RDB: Mysql, Oracle, PostgreSQL 등 
- NoSQL: CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등
- NoSQL은 네 부류로 나눌 수 있다.
  - key-value store
  - graph store
  - column store
  - document store
- RDB는 조인 연산을 지원하는 반면, NoSQL은 조인 연산을 지원하지 않는다. 
- 아래 케이스에선 NoSQL를 고려해보자.
  - 아주 낮은 응답 지연시간 필요
  - 데이터가 비정형임
  - 데이터를 serialize, deserialize 할 수 있기만 하면 됨
  - 

### 수직적 규모 확장 vs 수평적 규모 확장
- 스케일업(수직 = vertical scaling): 서버에 고사양 자원을 추가하는 행위
- 스케일 아웃(수평 = scale out): 더 많은 서버를 추가
- 트래픽 양이 적을 때는 스케일업이 좋은 선택이고 단순함이 큰 장점인 반면에 심각한 단점이 있다.
  - 한 대의 서버에 CPU나 메모리를 무한대로 증설 할 수 없으므로 한계가 있다.
  - 장애에 대한 자동복구 방안이나 다중화 방안을 제시할 수 없다.
- 대규모 애플리케이션에서는 scale out이 더 적절하다.

트래픽이 몰릴 때에는 load balancer를 도입해보자.

**로드밸런서**  

<img width="728" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/08338d86-af45-481b-8319-a1e5da13dd38">

- 사용자는 로드밸런서의 공개 IP 주소로 접속한다. 
- 부하 분산 집합에 웹 서버를 하나 더 추가하고 나면 장애를 자동복구하지 못하는 문제(no failover)는 해소되며, 웹 계층의 가용성(availability)은 향상된다.
  - 서버한대가 다운되면(offline) 다른 서버로 트래픽이 전송된다.
  - 트래픽이 급증하면 서버 1대이상을 추가하기만 하면 된다. 

웹 계층은 이제 괜찮은데, DB는 하나 뿐이고 장애의 자동복구나 다중화를 지원하지 않는다.  
DB 다중화는 이런 문제를 해결하는 보편화된 기술이다.


**데이터베이스 다중화**  

- 보통 DB는 서버 사이에 master-slave 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장한다.
- 쓰기 연산은 마스터에서만 지원한다.
- slave DB는 master DB 로부터 사본을 전달 받으며, 읽기 연산만을 지원한다. 
- 대부분의 애플리케이션은 읽기 연산 비중이 쓰기 연산보다 훨씬 높기 때문에, slave DB 수를 더 많이 구성한다.


<img width="816" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/6c43457a-2c25-4da9-960a-5939cd149818">

- 데이터베이스를 다중화하면 다음과 같은 이득이 있다. 
  - 더 나은 성능: 병렬로 처리될 수 있는 query 수가 늘어나서 성능이 올라간다. 
  - 안정성: DB 일부가 죽더라도 데이터는 보존된다. 데이터를 지역적으로 떨어진 여러 장소에 다중화 시킬수도 있다.
  - 가용성: 데이터를 여러 지역에 복제해 둠으로써, 하나의 DB에 장애가 발생해도 다른 서버에 있는 데이터를 가져와서 서비스할 수 있다. 
- 데이터베이스 한대가 다운되면 어떤일이 벌어질까?
  - slave DB가 한대인데 다운된경우
    - 읽기 연산이 일시적으로 master DB로 감.
    - 새로운 slave DB가 장애서버를 대체 
  - slave DB가 여러대인데 다운된경우
    - 읽기 연산이 나머지 slave DB로 간다.
    - 새로운 slave DB가 장애서버를 대체 
  - master DB가 한대인데 다운된경우
    - slave DB가 master DB로 승격된다.
    - 모든 연산은 새로운 master DB로 수행된다.
    - 그리고 새로운 slave DB가 추가된다. 
    - 부 서버에 보관된 데이터가 최신 상태가 아닐 수 있는데, 이 때에는 없는 데이터에 대해서 복구 스크립트를 돌려서 추가해야 한다. 
    - 다중 마스터(multi-masters)나 원형 다중화(circular replication) 방식을 도입하면 이런 상황을 대처하는데 도움이 되지만 구성이 훨씬 복잡해진다. 

<img width="868" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/652e7778-0ae2-490f-84d8-94224e4cb10d">
- 로드밸런서 + DB 다중화를 고려한 설계 


다음은 응답시간을 개선해보자.  
응답시간은 캐시를 붙이고 정적 컨텐츠를 CDN으로 옮기면 개선할 수 있다.


### 캐시
- 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 빨리 처리될 수 있도록 하는 저장소다.

**캐시 계층**  
- 캐시 계층은 데이터가 잠시 보관되는 곳으로 DB보다 훨씬 빠르다.
- 성능 개선 뿐 아니라 DB 부하를 줄일 수 있고, 캐시 계층을 독립적으로 확장시키는 것도 가능하다. 

<img width="802" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/cc0b0344-f7fb-44ac-83a2-fd3573a03173">

- 이러한 캐시 전략을 읽기 주도형 캐시 전략이라고 부른다.
- 이것 이외에도 다양한 캐시 전략이 있는데, 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택하면 된다.

**캐시 사용 시 유의할 점**  
- 캐시는 어떤 상황에 바람직한가? 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려해보자.
- 어떤 데이터를 캐시에 두어야 하는가? 캐시 데이터는 휘발성 메모리에 두므로, 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다. 
- 캐시에 보관된 데이터는 어떻게 만료 되는가? 이에 대한 정책을 마련해 두는 것이 좋다. 만료 기한은 너무 짧거나 길면 곤란하다. DB를 너무 자주 읽거나, 원본과 차이날 수 있기 때문이다.
- 일관성은 어떻게 유지되는가? 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 일관성은 깨질 수 있다. 
- 장애에는 어떻게 대처할 것인가? 캐시 서버를 한 대만 두는 경우 SPOF가 될 수 있다. 특정 지점의 장애가 전체시스템의 동작을 중단시킬 수 있는 경우가 SPOF인데, SPOF를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.

<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/5044d3ad-e628-4ac6-9072-5cef4f2de623">
- 캐시 메모리는 얼마나 크게 잡을 것인가? 캐시 메모리가 너무 작으면 데이터가 너무 자주 캐시에서 밀려나버려 캐시 성능이 저하될 수 있다.
- 데이터 방출(eviction) 정책은 무엇인가? 가장 널리 쓰이는 것은 LRU(마지막으로 사용된 데이터를 내보냄) 이다. LFU(사용 빈도가 가장 낮은 데이터를 내보내는 정책)이나 FIFO같은 것도 있는데 경우에 맞게 적용하자.


### CDN

- 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. 
- 이미지, 비디오, CSS, js 파일 등을 캐시할 수 있다. 
- request path, query string, cookie, request header 등의 정보에 기반하여 HTML 페이지를 캐시하는 것이다.

<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/62d15673-538f-4f8c-8b6b-7a9ee6fb3589">

- 어떤 사용자가 웹사이트를 방문하면, 그 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달한다.


<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/d81941b6-ee99-4060-a3c4-adab36acc354">


**CDN 사용 시 고려해야 할 사항**  
- 비용: CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금을 내게 된다. 자주 사용하지 않은 컨텐츠를 캐싱하는 것은 이득이 크지 않으므로 CDN에서 빼는 것을 고려하자.
- 적절한 만료 시한 설정: 시의성이 중요한(time-sensitive) 컨텐츠의 경우 만료 시점을 잘 정해야 한다.
- CDN 장애에 대한 대처 방안: CDN이 응답 하지 않을 경우, 문제를 감지하여 원본 서버로부터 직접 컨텐츠를 가져오도록 클라이언트를 구성하는것이 필요할 수 있다.
- 컨텐츠 무효화 방법: 아직 만료되지 않은 컨텐츠라 하더라도 아래 방법들 중 하나를 쓰면 CDN에서 제거할 수 있다.
  - CDN 서비스 사업자가 제공하는 API 사용 
  - 컨텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝이용. 컨텐츠의 새로운 버전을 지정하기 위해서 URL 마지막에 버전 번호를 인자로 주면 된다. ex) image.png?v=2 

<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/5d1f04cf-70b2-46f2-873e-2aac12bb7ceb">

- CDN과 캐시가 추가된 설계
- 변화된 부분
  - 정적컨텐츠는 CDN을 통해 제공하여 더 나은 성능을 보장한다.
  - 캐시가 데이터베이스 부하를 줄여준다.

### 무상태(stateless) 웹 계층 
- 웹 계층을 수평적으로 확장하는 방법을 고민해보자. 
- 이를 위해서는 상태 정보(사용자 세션 데이터와 같은)를 웹 계층에서 제거해야 한다.
- 상태 정보는 RDB, NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하자.
- 이렇게 구성된 웹 계층을 무상태 웹 계층이라 부른다.

**상태 정보 의존적인 아키텍처**  
- 상태 정보를 보관하는 서버와 그렇지 않은 서버 사이에는 몇가지 중요한 차이가 있다.
- 상태 정보를 보관하는 서버는 상태 정보를 요청들 사이에 공유되도록 한다. (무상태 서버에는 이런 장치가 없다)

<img width="792" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/833392fb-a63b-44fb-aa75-39b4b2b76660">

- 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다.
- 대부분의 로드밸런서가 이를 지원하기 위해 고정 세션이라는 기능을 제공하는데, 이는 로드밸런서에 부담을 준다.
- 게다가 로드밸런서 뒷단에 서버를 추가하거나 제거하기도 까다로워지고, 서버의 장애를 처리하기도 복잡해진다.

**무상태 아키텍처**  

<img width="624" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/fbd1e93a-3dc9-44bf-8f4e-1b1304645a5a">

- 이 구조에서는 HTTP 요청이 어떤 웹 서버로도 전달될 수 있다. 
- 웹 서버는 상태 정보가 필요할 경우 공유 저장소로부터 데이터를 가져온다. 
- 따라서 상태 정보는 웹 서버로부터 물리적으로 분리되어 있고, 구조가 단순하고 안정적이며 규모 확장이 쉬워진다.

<img width="854" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/28e3d617-a065-4051-8dc0-5d260f515a23">

- 세션 데이터를 웹 계층에서 분리하고 지속성 데이터 보관소에 저장하도록 만들었다.
- 이 공유 저장소는 RDB가 될수도 있고, Memcached/Redis 같은 캐시 시스템일 수도 있고 NoSQL일 수도 있다.
- 여기서는 NoSQL을 사용하였으며, 규모 확장이 간편해서다.


가용성을 높이고 전 세계 어디서도 쾌적하게 사용할 수 있도록 하려면  
여러 데이터 센터를 지원하는 것이 필수다.

### 데이터 센터

<img width="854" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/d87c323d-99d8-48be-862e-314b314af0cf">

- 두 개의 데이터 센터를 이용하는 사례다.
- 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데, 이것을 지리적 라우팅이라고(geoDNS-routing or geo-routing) 부른다.
- 지리적 라우팅에서의 geoDNS는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해주는 DNS 서비스다.

<img width="854" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/0345acc1-a6c7-444b-8f52-a3f313d2265a">

- 데이터 센터 중 하나에 심각한 장애가 발생하면 모든 트래픽이 장애가 없는 데이터 센터로 전송된다.
- 위 그림은 US-West에 장애가 발생하여, US-East로 전송되는 상황이다.

이 사례와 같은 다중 데이터센터 아키텍처를 만들려면 몇가지 기술적 난제를 해결해야 한다.
- 트래픽 우회: 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야한다. ex) GeoDNS
- 데이터 동기화: 데이터 센터마다 별도의 DB를 사용하면, 장애가 자동으로 복구되어 트래픽이 다른 DB로 우회되도, 해당 데이터센터에는 찾는 데이터가 없을 수 있다. 이런 상황을 막는 보편적 전략은 데이터를 여러 데이터센터에 걸쳐 다중화하는 것이다.
- 테스트와 배포: 웹 사이트 또는 애플리케이션을 여러 위치에서 테스트해보는 것이 중요하다. 또, 자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 하는 데 중요한 역할을 한다.

시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여, 각기 독립적으로 확장될 수 있도록 하여야 한다.  
메시지 큐는 많은 실제 분산 시스템이 이 문제를 풀기 위해 채용하고 있는 핵심적 전략 가운데 하나다. 

### 메시지 큐 
- 메시지의 무손실을 보장하는, 비동기 통신을 지원하는 컴포넌트다. 
- 메시지의 버퍼 역할을 하며, 비동기적으로 전송한다. 
- 메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다. 


<img width="759" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/737f8c57-6d92-4747-92f6-b7f087553fbb">

- 이미지의 크로핑, 샤프닝, 블러핑 등을 지원하는 사진 보정 애플리케이션을 만든다고 해 보자.
- 보정은 시간이 오래 걸릴 수 있는 프로세스이므로 비동기적으로 처리하면 편하다.
- 웹 서버는 사진 보정 작업을 메시지 큐에 넣는다. 
- 사진 보정 작업(worker) 프로세스들은 이 작업을 메시지 큐에서 꺼내어 비동기적으로 완료한다.
- 생산자와 소비자 서비스의 규모는 각기 독립적으로 확장될 수 있다. 
- 큐의 크기가  커지면 작업 프로세스를 늘리고, 큐가 항상 비어 있는 상태라면 작업 프로세스의 수를 줄일 수 있다. 

### 로그, 메트릭, 그리고 자동화 
- 소규모 웹 사이트에선 필요 없지만, 웹사이트와 함께 사업 규모가 커지고나면 로그나 메트릭, 자동화 같은 도구에 필수적으로 투자해야 한다.
- 로그: 에러 로그를 서버 단위로 모니터링 할 수도 있지만, 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 검색하고 조회할 수 있다. 
- 메트릭
  - 호스트 단위 메트릭: CPU, 메모리, 디스크 I/O에 관한 메트릭
  - 종합 메트릭: DB 계층의 성능, 캐시 계층의 성능 
  - 핵심 비즈니스 메트릭: 일별 능동 사용자, 수익, 재방문 등
- 자동화: 시스템이 크고 복잡해지면 생산성을 높이기 위해 자동화 도구를 활용해야 한다. 
  - 지속적 통합을 도와주는 도구를 활용하면 개발자가 만드는 코드가 어떤 검증 절차를 자동으로 거치도록 할 수 있어서 문제를 쉽게 감지할 수 있다.


**메시지 큐, 로그, 메트릭, 자동화 등을 반영하여 수정한 설계안**  

<img width="831" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/0ebc156a-6ab2-4ccb-a255-52b55b38f090">

1. 메시지큐는 각 컴포넌트가 느슨히 결합될 수 있도록 하고, 결함에 대한 내성을 높인다.
2. 로그, 모니터링 메트릭, 자동화 등을 지원하기 위한 장치를 추가했다.


### 데이터베이스의 규모 확장  
- 저장할 데이터가 많아지면 DB에 대한 부하가 증가하고, 그때엔 DB를 증설할 방법을 찾아야 한다.
- DB 규모를 확장하는데는 수직적 규모 확장법, 수평적 규모 확장법이 있다.

**수직적 확장**  
- 고성능의 자원(CPu, RAM, 디스크 등)을 증설하는 방법
- 수직적 접근법에는 단점이 있다.
  - 무한 증설이 불가능 하다.
  - SPOF 위험성
  - 고성능 서버로 갈수록 가격이 올라가서, 비용이 많이 든다.

**수평적 확장**  
- 샤딩이라고도 부름, 더 많은 서버를 추가해서 성능 향상 
- 대규모 DB를 샤드라고 부르는 작은 단위로 분할하는 기술을 일컫는다. 
- 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.

<img width="834" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/71ac5974-e3c0-4203-8d4c-5f3cc64a27ed">

- 샤드로 분할된 데이터베이스의 예다.
- 이 케이스에서는 사용자 데이터를 어느 샤드에 넣을지는 사용자 ID에 따라 정한다.
- 샤딩 전략을 구현할 때 고려해야 할 가장 중요한 것은 샤딩 키를 어떻게 정하느냐다.
- 샤딩 키는 파티션 키라고도 부르는데, 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성된다. 
- 위 케이스에서는 샤딩키가 user_id 이다. 
- 샤딩 키를 정할 때는 데이터를 고르게 분할 할 수 있도록 하는게 가장 중요하다. 


샤딩은 DB 규모 확장을 실현하는 훌륭한 기술이지만 완벽하진 않고, 도입하면 시스템이 복잡해지고 풀어야할 새로운 문제도 생긴다. 
- 데이터의 재 샤딩(resharding)
  - 1) 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때
  - 2) 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때 
  - 샤드소진 이라고도 부르는 이런 현상이 발생하면 샤드 키를 계싼하는 함수를 변경하고 데이터를 재배치해야 한다. 안정해시 기법을 활용하면 이 문제를 해결할 수 있다.
- 유명인사(celebrity) 문제
   - 핫스팟 키 문제라고도 부르는데, 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제다.
   - 이 문제를 풀려면 샤드를 잘 쪼개는게 중요하다.
- 조인과 비정규화
  - 하나의 DB를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다. 
  - 이를 해결하는 한 가지 방법은 DB를 비정규화하여 하나의 테이블에서 질의가 수행할 수 있도록 하는 것이다. 

<img width="834" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/d259088b-afa8-4afc-9849-cfb544856613">

- 샤딩을 적용 하고 DB에 대한 부하를 줄이기 위해 굳이 RDB가 요구되지 않는 기능들은 NoSQL로 이전했다.


### 백만 사용자, 그리고 그 이상
- 시스템의 규모를 확장하는 것은 지속적이고 반복적인 과정이다. 
- 수백만 사용자 이상을 지원하려면 새로운 전략을 도입해야 하고 지속적으로 시스템을 가다듬어야 할 것이다. ex) 시스템을 최적화하고 더 작은 단위의 서비스로 분할해야 할 수도 있다. 
- 이번 장에서 시스템 규모 확장을 위해 살펴본 기법들을 정리해보면
  - 웹 계층은 무상태 계층으로
  - 모든 계층에 다중화 도입
  - 가능한 한 많은 데이터를 캐시
  - 여러 데이터 센터를 지원
  - 정적 콘텐츠는 CDN 사용 
  - 데이터 계층은 샤딩을 통해 확장
  - 각 계층은 독립적 서비스로 분할
  - 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것

## 2장 개략적인 규모 추정

### 2의 제곱수

- 분산 시스템에서 다루는 데이터 양은 엄청 커질 수 있으나 계산법은 기본을 크게 벗어나지 않는다.
- 제대로 된 계산 결과를 얻으려면 데이터 볼륨의 단위를 2의 제곱수로 표현하면 어떻게 되는지 알아야 한다.

| 2의 x 제곱 | 근사치 | 이름 | 축약형 |
| --- | --- | --- | --- |
| 10 | 1천 | 1킬로바이트 | 1KB |
| 20 | 1백만 | 1메가바이트 | 1MB |
| 30 | 10억 | 1기가바이트 | 1GB |
| 40 | 1조 | 1테라바이트 | 1TB |
| 50 | 1000조 | 1페타바이트 | 1PB |

### 모든 프로그래머가 알아야 하는 응답지연 값 

- 구글의 제프 딘에서 2010년에 통상적인 컴퓨터에서 구현된 연산들의 응답지연 값을 공개했었다.
- 이들 중 몇몇은 컴퓨터가 더 빨라지면서 유효하지 않지만, 아직 어느정도 짐작할 수 있도록 해준다. 

| 연산명 | 시간 |
| --- | --- |
| L1 캐시 참조 | 0.5ns |
| 분기 예측 오류 | 5ns |
| L2 캐시 참조 | 7ns |
| 뮤텍스 락/언락 | 100ns |
| 주 메모리 참조 | 100ns |
| Zippy로 1KB 압축 | 10,000ns = 10us |
| 1 Gbps 네트워크로 2KB 전송 | 20,000ns = 20us |
| 메모리에서 1MB 순차적으로 read | 250,000ns = 250us |
| 같은 데이터 내에서의 메시지 오아복 지연시간 | 500,000ns = 500us |
| 디스크 검색 | 10,000,000ns = 10ms |
| 네트워크에서 1MB 순차적으로 read | 10,000,000ns = 10ms |
| 디스크에서 1MB 순차적으로 read | 30,000,000ns = 30ms |
| 한 패킷의 CA로부터 네덜란드까지의 왕복 지연시간 | 150,000,000ns = 150ms |

정리하자면
- 메모리는 빠르지만 디스크는 아직도 느리다
- 디스크 검색은 가능한 피하라
- 단순한 압축 알고리즘은 빠르다
- 데이터를 인터넷으로 전송하기 전에 가능하면 압축하자.
- 데이터 센터는 보통 여러 지역에 분산되어 있고, 센터들 간에 데이터를 주고받는 데는 시간이 걸린다.

### 가용성에 관계된 수치들 
- 고가용성(HA = high availability)은 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력의 용어다. 
- 100%는 시스템이 중단 없다는 의미 이고, 대부분의 서비스는 99%  ~ 100% 사이의 값을 찾는다.
- SLA(Service Level Agreement)는 서비스 사업가(service provider)가 보션적으로 사용하는 용어로, 서비스 사업자와 고객 사이에 맺어진 합의이다.
- 이 합의에는 서비스 사업자가 제공하는 서비스의 가용시간(uptime)이 공식적으로 기술되어 있다. 

| 가용률 | 하루당 장애시간 | 주당 장애시간 | 개월당 장애시간 | 연간 장애시간 |
| 99% | 14.40분 | 1.68시간 | 7.31시간 | 3.65일 |
| 99.9% | 1.44분 | 10.08분 | 43.83분 | 8.77시간 |
| 99.99% | 8.64초 | 1.01분 | 4.38분 | 52.60분 |
| 99.999% | 864.00밀리초 | 6.05초 | 26.30초 | 5.26분 |
| 99.9999% | 86.40밀리초 | 604.80밀리초 | 2.63초 | 31.56초 |

### 예제: 트위터 QPS와 저장소 요구량 측정 

제시된 수치들은 예시일뿐, 실제 성능이나 요구사항과는 관계 없다.

가정
- 월간 능동 사용자(MAU = montly active user)는 3억명이다.
- 50%의 사용자가 트위터를 매일 사용
- 평균적으로 각 사용자는 매일 2건의 트윗을 올린다
- 미디어를 포함하는 트윗은 10% 정도다
- 데이터는 5년간 보관된다

추정
- QPS 추정치 
- 일간 능동 사용자(DAU = daily active user) = 3억 % 50% = 1.5억
- QPS = 1.5 억 X 2 트윗 / 24시간 / 3600초 = 약 3500
- 최대 QPS = 2 X QPS = 약 7000

미디어 저장을 위한 저장소 요구량 
- 평균 트윗 크기 
  - tweet_id에 64바이트
  - 텍스트에 140바이트 
  - 미디어에 1MB
- 미디어 저장소 요구량: 1.5억 X 2 X 10% X 1MB = 30TB/일
- 5년간 미디어를 보관하기 위한 저장소 요구량: 30TB X 365 X 5 = 약 55PB

### 팁

개략적 규모 추정 면접에서 가장 중요한 것은 문제를 풀어 나가는 절차고, 문제 해결 능력이다.  
- 근사치를 활용한 계산: 99987/9.1 대신 100,000 / 10으로 간소화하자.
- 가정들은 적어두자 
- 단위를 붙이자. 스스로 헷갈리지 않기 이ㅜ해
- 많이 출제되는 개략적 규모 추정 문제는 QPS, 최대 QPS, 저장소 요구량, 캐시 요구량, 서버 수 등을 추정하는 것이다. 


## 3. 시스템 설계 면접 공략법 

- 시스템 설계 면접은 두 명의 동료가 모호한 문제를 풀기 위해 협력하여 그 해결책을 찾아내는 과정에 대한 시뮬레이션이다. 
- 최종적으로 도출될 설계안은 노력에 비하면 그다지 중요하지 않다. 
- 해당 면접은 설계 기술을 시연하는 자리이고, 설계 과정에서 내린 결정들에 대한 방어 능력을 보이는 자리이며, 면접관의 피드백을 건설적인 방식으로 처리할 자질이 있음을 보이는 자리이다. 
- 많은 사람이 시스템 설계 면접은 지원자의 설계 능력의 기술적 측면을 평가하는 자리라고 생각하지만, 지원자가 협력에 적합한 사람인지, 압박이 심한 상황도 잘 헤쳐 나갈 자질이 있는지, 모호한 문제를 건설적으로 해결할 능력이 있는지, 좋은 질문을 던질 능력이 있는지 등도 평가한다. 
- 훌륭한 면접관은 부정적 신호도 놓치지 않는다.
  - 설계의 순수성에 집착한 나머지 타협적 결정(tradeoff)을 도외시하고 over-engineering을 하고 마는 엔지니어들이 현업에도 많다.
  - 그런 엔지니어들은 과도한 엔지니어링의 결과로 시스템 전반의 비용이 올라간다는 사실을 알아채지 못하는 일이 많은데, 그 결과로 상당후 회사들은 값비싼 대가를 치르고 있다. 
- 이번 장에서는 시스템 설계 면접에 관한 유용한 팁들을 살펴보고, 시스템 설계 문제를 공략하는 효과적 접근법을 소개한다.

### 효과적 면접을 위한 4단계 접근법

**1단계: 문제 이해 및 설계 범위 확정**  

- 시스템 설계 면접에서는 생각 없이 바로 답을 내서는 안된다.
- 요구사항을 완전히 이해하지 않고 답을 내놓는 행위는 엄청난 부정적 신호다.
- 속도를 늦추고, 깊이 생각하고 질문하여 요구사항과 가정들을 분명히 하자.
- 엔지니어가 가져야할 가장 중요한 기술 중 하나는 올바른 질문, 적절한 가정, 그리고 시스템 구축에 필요한 정보를 모으는 것이다.
- 요구사항을 정확히 이해하는데 필요한 질문의 예시는 
  - 구체적으로 어떤 기능들을 만들어야 하나?
  - 제품 사용자 수는 얼마나 되나?
  - 회사의 규모는 얼마나 빨리 커지리라 예상하나? 석 달, 여섯 달, 일년 뒤의 규모는 얼마가 되리라 예상하는가?
  - 회사가 주로 사용하는 기술스택은 무엇인가? 설계를 단순화하기 위해 활용할 수 있는 기존 서비스로는 어떤 것들이 있는가?


예시: 뉴스피드 시스템 설계에서 요구사항을 분명히 하기 위한 질문을 던져야 한다.

지원자: 모바일 앱과 웹 앱 가운데 어느 쪽을 지원해야 하나요? 아니면 둘 다일까요?  
면접관: 둘다 지원해야 합니다.  
지원자: 가장 중요한 기능은 무엇 인가요?  
면접관: 새로운 포스트(post)를 올리고, 다른 친구의 뉴스피드를 볼 수 있도록 하는 기능 입니다.  
지원자: 이 뉴스피드는 시간 역순으로 정렬되어야 하나요? 아니면 다른 특별한 정렬 기준이 있습니까?    
제가 특별한 정렬 기준이 있느냐고 묻는이유는, 피드에 올라갈 포스트마다 다른 가중치가 부여되어야 하는지 알고 싶어서 인데요.   
가령 가까운 친구의 포스트가 사용자그룹(user group) 에 올라가는 포스트 보다 더 중요하다거나.  
면접관: 문제를 단순하게 만들기 위해, 일단 시간 역순으로 정렬된다고 가정합시다.  
지원자: 한 사용자는 최대 몇명의 사용자와 친구를 맺을수있나요?  
면접관: 500명입니다.  
지원자: 사이트로 오는 트래픽규모는 어느정도입니까?  
면접관: 일간능동사용자(dailyactive user,DAU)는 천만명입니다.  
지원자: 피드에 이미지나 비디오도 올라올수있나요? 아니면 포스트는 그저 텍스트입니까?  
면접관: 이미지나 비디오 같은 미디어 파일도 포스트 할 수 있어야 합니다. 


**2단계: 개략적인 설계안 제시 및 동의 구하기**   
- 설계안에 대한 최초 청사진을 제시하고 의견을 구하라. 면접관을 마치 팀원인 것처럼 대하자.
- 화이트보드나 종이에 핵심 컴포넌트를 포함하는 다이어그램을 그려라. 클라이언트, API, 웹 서버, 데이터 저장소, 캐시, CDN, 메시지 큐 같은 것들이 포함될 수 있다.
- 최초 설계안이 시스템 규모에 관계된 제약사항들을 만족하는지를 개략적으로 계산해보자. 이런 개략적 추정이 필요한지는 면접관한태 미리 물어보자.

예시: 뉴스 피드 시스템을 설계에서 개략적 설계를 살펴보자   

개략적으로 보면 이 설계는 두가지 flow로 나눠 생각 할 수 있는데, 피드 발생과 피드 생성이다.
- 피드 발행: 사용자가 포스트를 올리면 관련된 데이터가 캐시/데이터베이스에 기록되고, 해당 사용자의 친구 뉴스 피드에 뜬다.
- 피드 생성: 어떤 사용자의 뉴스 피드는 해당 사용자 친구들의 포스트를 시간 역순으로 정렬하여 만든다.

![image](https://github.com/sinkyoungdeok/TIL/assets/28394879/07c15030-6ae3-4c32-ab69-46f207b40d52)  
- 3-1: 피드 발생
- 3-2: 피드 생성


**3단계: 상세 설계**     
- 이 단계로 왔다면 면접관과 다음 목표는 달성한 상태이다.  
  - 시스템에서 전반적으로 달성해야 할 목표와 기능 범위 확인
  - 전체 설계의 개략적 청사진 마련
  - 해당 청사진에 대한 면접관의 의견 청취
  - 상세 설계에서 집중해야 할 영역들 확인 
- 이제 면접관과 설계 대상 컴포넌트 사이의 우선순위를 정하는 것이다.   
- 대부분의 경우 면접관은 특정 시스템 컴포넌트들의 시부사항을 깊이 있게 설명하는 것을 보길 원한다.
- 단축 URL 생성기라면, 해시 함수의 설계를 / 채팅 시스템에 관한 문제라면, 지연시간을 줄이고 사용자의 온/오프라인 상태를 표시할 것인지를 듣고자 할 것이다.
- 반대로 불필요한 세부사항에 시간을 쓰지말자. 뉴스 피드의 순위를 매기는데 사용되는 EdgeRank 알고리즘에 대해 이야기하는 것은 바람직 하지 않다. 시간을 너무 많이 쓰고, 규묘확장 가능한 시스템 설계 능력을 보여주기에는 도움되지 않는다.


예시: 뉴스 피드 시스템의 개략적 설계를 마친 상황 (면접관도 그 설계에 만족)  

두가지 중요한 용례를 깊이 탐구하자 
1. 피드 발행 (3-3)
2. 뉴스 피드 가져오기 (3-4)

![image](https://github.com/sinkyoungdeok/TIL/assets/28394879/8313f2c3-771d-4c85-95af-8fdb153618f2)  
![image](https://github.com/sinkyoungdeok/TIL/assets/28394879/d3f41763-487e-4956-9034-1e379e1edb27)  


**4단계: 마무리**   
- 면접관이 시스템 병목구간, 혹은 좀 더 개선 가능한 지점을 찾아내라 주문할 수 있다. 
  - 설계가 완벽하다거나 개선할 부분이 없다고 답하지 말자, 개선할 점은 언제든 있다.
- 설계를 한번 다시 요약해주는 것도 좋다.
- 오류가 발생하면 무슨일이 생기는지 따져보는것도 좋다.
- 운영 이슈도 논의할 가치가 충분하다. 
  - 메트릭은 어떻게 수집하고 모니터링?
  - 로그는?
  - 시스템은 어떻게 배포(roll-out)해나 갈 것인가?
- 미래에 닥칠 규모 확장 요구에 어떻게 대처할 것인지도 좋다.
- 시간이 좀 남으면, 필요하지만 다루지 못했던 세부적 개선사항들을 제안해보자.



면접 세션에서 해야 할 것  
- 질문을 통해 확인하자. 스스로 내린 가정이 옳다 믿고 진행하지 말자
- 문제의 요구사항을 이해해라
- 정답이나 최선의 답안 같은 것은 없다는 것을 명심하자
- 사고 흐름을 이해할 수 있도록 소통 하자
- 가능하다면 여러 해법을 함께 제시하자
- 개략적 설계에 면접관이 동의하면, 각 컴포넌트의 세부사항을 설명하기 시작하고 가장 중요한 컴포넌트부터 진행해라.
- 면접관의 아이디어를 이끌어 내자. 좋은 면접관은 팀원처럼 협력한다
- 포기하지 말자

면접 세션에서 하면 안되는 것  
- 전형적인 면접 문제들에도 대비하지 않은 상태에서 면접장에 가지 말자
- 요구사항이나 가정들을 분명히 하지 않은 상태에서 설계를 제시하지 말자
- 처음부터 특정 컴포넌트의 세부사항을 깊이 설명하지 말자. 개략적 부터 세부사항으로 가자.
- 진행 중에 막혔다면, 힌트를 청하자
- 침묵 속의 설계를 진행하지 말자.
- 설계안을 내놓는 순간 면접이 끝났다고 생각하지 말자. 의견을 일찍, 자주 구하자

시간 배분 - 예시 45분 
1. 문제 이해 및 설계 범위 확정: 3분 ~ 10분
2. 개략적 설계안 제시 및 동의 구하기: 10분 ~ 15분
3. 상세 설계: 10분 ~ 25분
4. 마무리: 3분 ~ 5분 