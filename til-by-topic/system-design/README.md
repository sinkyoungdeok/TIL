
## 1장 사용자 수에 따른 규모 확장성 
한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로는 몇백만 사용자를 지원하는 시스템을 설계해 볼 것이다.


### 단일 서버

<img width="768" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/9b648507-0bfa-4a01-9e48-14fd42e7fcc1">

웹, 앱, 데이터베이스, 캐시 등이 전부 서버 한대에서 실행된다.

사용자 요청 처리 흐름은 다음과 같다. 

1. 도메인이름을 이용하여 웹사이트에 접속. 
2. 도메인 이름을 DNS(Domain Name Service)에 질의하여 IP 주소로 변환 
3. 해당 IP주소로 HTTP 요청이 전달
4. 웹서버에서 HTML or JSON 응답 반환 



### 데이터베이스

<img width="768" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/262181b3-a2e9-4c0e-8529-a68fce7bdd9a">

- 사용자가 늘면서 하나는 웹/모바일 트래픽 처리 용도의 서버, 다른 하나는 데이터베이스용 서버로 분리했다.
- 분리함으로써 각각을 독립적으로 확장해 나갈 수 있게 됐다.

**어떤 데이터베이스를 사용할 것인가?** 
- RDB vs NoSql 에서 고른다.
- RDB: Mysql, Oracle, PostgreSQL 등 
- NoSQL: CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등
- NoSQL은 네 부류로 나눌 수 있다.
  - key-value store
  - graph store
  - column store
  - document store
- RDB는 조인 연산을 지원하는 반면, NoSQL은 조인 연산을 지원하지 않는다. 
- 아래 케이스에선 NoSQL를 고려해보자.
  - 아주 낮은 응답 지연시간 필요
  - 데이터가 비정형임
  - 데이터를 serialize, deserialize 할 수 있기만 하면 됨
  - 

### 수직적 규모 확장 vs 수평적 규모 확장
- 스케일업(수직 = vertical scaling): 서버에 고사양 자원을 추가하는 행위
- 스케일 아웃(수평 = scale out): 더 많은 서버를 추가
- 트래픽 양이 적을 때는 스케일업이 좋은 선택이고 단순함이 큰 장점인 반면에 심각한 단점이 있다.
  - 한 대의 서버에 CPU나 메모리를 무한대로 증설 할 수 없으므로 한계가 있다.
  - 장애에 대한 자동복구 방안이나 다중화 방안을 제시할 수 없다.
- 대규모 애플리케이션에서는 scale out이 더 적절하다.

트래픽이 몰릴 때에는 load balancer를 도입해보자.

**로드밸런서**  

<img width="728" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/08338d86-af45-481b-8319-a1e5da13dd38">

- 사용자는 로드밸런서의 공개 IP 주소로 접속한다. 
- 부하 분산 집합에 웹 서버를 하나 더 추가하고 나면 장애를 자동복구하지 못하는 문제(no failover)는 해소되며, 웹 계층의 가용성(availability)은 향상된다.
  - 서버한대가 다운되면(offline) 다른 서버로 트래픽이 전송된다.
  - 트래픽이 급증하면 서버 1대이상을 추가하기만 하면 된다. 

웹 계층은 이제 괜찮은데, DB는 하나 뿐이고 장애의 자동복구나 다중화를 지원하지 않는다.  
DB 다중화는 이런 문제를 해결하는 보편화된 기술이다.


**데이터베이스 다중화**  

- 보통 DB는 서버 사이에 master-slave 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장한다.
- 쓰기 연산은 마스터에서만 지원한다.
- slave DB는 master DB 로부터 사본을 전달 받으며, 읽기 연산만을 지원한다. 
- 대부분의 애플리케이션은 읽기 연산 비중이 쓰기 연산보다 훨씬 높기 때문에, slave DB 수를 더 많이 구성한다.


<img width="816" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/6c43457a-2c25-4da9-960a-5939cd149818">

- 데이터베이스를 다중화하면 다음과 같은 이득이 있다. 
  - 더 나은 성능: 병렬로 처리될 수 있는 query 수가 늘어나서 성능이 올라간다. 
  - 안정성: DB 일부가 죽더라도 데이터는 보존된다. 데이터를 지역적으로 떨어진 여러 장소에 다중화 시킬수도 있다.
  - 가용성: 데이터를 여러 지역에 복제해 둠으로써, 하나의 DB에 장애가 발생해도 다른 서버에 있는 데이터를 가져와서 서비스할 수 있다. 
- 데이터베이스 한대가 다운되면 어떤일이 벌어질까?
  - slave DB가 한대인데 다운된경우
    - 읽기 연산이 일시적으로 master DB로 감.
    - 새로운 slave DB가 장애서버를 대체 
  - slave DB가 여러대인데 다운된경우
    - 읽기 연산이 나머지 slave DB로 간다.
    - 새로운 slave DB가 장애서버를 대체 
  - master DB가 한대인데 다운된경우
    - slave DB가 master DB로 승격된다.
    - 모든 연산은 새로운 master DB로 수행된다.
    - 그리고 새로운 slave DB가 추가된다. 
    - 부 서버에 보관된 데이터가 최신 상태가 아닐 수 있는데, 이 때에는 없는 데이터에 대해서 복구 스크립트를 돌려서 추가해야 한다. 
    - 다중 마스터(multi-masters)나 원형 다중화(circular replication) 방식을 도입하면 이런 상황을 대처하는데 도움이 되지만 구성이 훨씬 복잡해진다. 

<img width="868" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/652e7778-0ae2-490f-84d8-94224e4cb10d">
- 로드밸런서 + DB 다중화를 고려한 설계 


다음은 응답시간을 개선해보자.  
응답시간은 캐시를 붙이고 정적 컨텐츠를 CDN으로 옮기면 개선할 수 있다.


### 캐시
- 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 빨리 처리될 수 있도록 하는 저장소다.

**캐시 계층**  
- 캐시 계층은 데이터가 잠시 보관되는 곳으로 DB보다 훨씬 빠르다.
- 성능 개선 뿐 아니라 DB 부하를 줄일 수 있고, 캐시 계층을 독립적으로 확장시키는 것도 가능하다. 

<img width="802" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/cc0b0344-f7fb-44ac-83a2-fd3573a03173">

- 이러한 캐시 전략을 읽기 주도형 캐시 전략이라고 부른다.
- 이것 이외에도 다양한 캐시 전략이 있는데, 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택하면 된다.

**캐시 사용 시 유의할 점**  
- 캐시는 어떤 상황에 바람직한가? 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려해보자.
- 어떤 데이터를 캐시에 두어야 하는가? 캐시 데이터는 휘발성 메모리에 두므로, 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다. 
- 캐시에 보관된 데이터는 어떻게 만료 되는가? 이에 대한 정책을 마련해 두는 것이 좋다. 만료 기한은 너무 짧거나 길면 곤란하다. DB를 너무 자주 읽거나, 원본과 차이날 수 있기 때문이다.
- 일관성은 어떻게 유지되는가? 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 일관성은 깨질 수 있다. 
- 장애에는 어떻게 대처할 것인가? 캐시 서버를 한 대만 두는 경우 SPOF가 될 수 있다. 특정 지점의 장애가 전체시스템의 동작을 중단시킬 수 있는 경우가 SPOF인데, SPOF를 피하려면 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.

<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/5044d3ad-e628-4ac6-9072-5cef4f2de623">
- 캐시 메모리는 얼마나 크게 잡을 것인가? 캐시 메모리가 너무 작으면 데이터가 너무 자주 캐시에서 밀려나버려 캐시 성능이 저하될 수 있다.
- 데이터 방출(eviction) 정책은 무엇인가? 가장 널리 쓰이는 것은 LRU(마지막으로 사용된 데이터를 내보냄) 이다. LFU(사용 빈도가 가장 낮은 데이터를 내보내는 정책)이나 FIFO같은 것도 있는데 경우에 맞게 적용하자.


### CDN

- 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. 
- 이미지, 비디오, CSS, js 파일 등을 캐시할 수 있다. 
- request path, query string, cookie, request header 등의 정보에 기반하여 HTML 페이지를 캐시하는 것이다.

<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/62d15673-538f-4f8c-8b6b-7a9ee6fb3589">

- 어떤 사용자가 웹사이트를 방문하면, 그 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달한다.


<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/d81941b6-ee99-4060-a3c4-adab36acc354">


**CDN 사용 시 고려해야 할 사항**  
- 비용: CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금을 내게 된다. 자주 사용하지 않은 컨텐츠를 캐싱하는 것은 이득이 크지 않으므로 CDN에서 빼는 것을 고려하자.
- 적절한 만료 시한 설정: 시의성이 중요한(time-sensitive) 컨텐츠의 경우 만료 시점을 잘 정해야 한다.
- CDN 장애에 대한 대처 방안: CDN이 응답 하지 않을 경우, 문제를 감지하여 원본 서버로부터 직접 컨텐츠를 가져오도록 클라이언트를 구성하는것이 필요할 수 있다.
- 컨텐츠 무효화 방법: 아직 만료되지 않은 컨텐츠라 하더라도 아래 방법들 중 하나를 쓰면 CDN에서 제거할 수 있다.
  - CDN 서비스 사업자가 제공하는 API 사용 
  - 컨텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝이용. 컨텐츠의 새로운 버전을 지정하기 위해서 URL 마지막에 버전 번호를 인자로 주면 된다. ex) image.png?v=2 

<img width="781" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/5d1f04cf-70b2-46f2-873e-2aac12bb7ceb">

- CDN과 캐시가 추가된 설계
- 변화된 부분
  - 정적컨텐츠는 CDN을 통해 제공하여 더 나은 성능을 보장한다.
  - 캐시가 데이터베이스 부하를 줄여준다.

### 무상태(stateless) 웹 계층 
- 웹 계층을 수평적으로 확장하는 방법을 고민해보자. 
- 이를 위해서는 상태 정보(사용자 세션 데이터와 같은)를 웹 계층에서 제거해야 한다.
- 상태 정보는 RDB, NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하자.
- 이렇게 구성된 웹 계층을 무상태 웹 계층이라 부른다.

**상태 정보 의존적인 아키텍처**  
- 상태 정보를 보관하는 서버와 그렇지 않은 서버 사이에는 몇가지 중요한 차이가 있다.
- 상태 정보를 보관하는 서버는 상태 정보를 요청들 사이에 공유되도록 한다. (무상태 서버에는 이런 장치가 없다)

<img width="792" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/833392fb-a63b-44fb-aa75-39b4b2b76660">

- 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다.
- 대부분의 로드밸런서가 이를 지원하기 위해 고정 세션이라는 기능을 제공하는데, 이는 로드밸런서에 부담을 준다.
- 게다가 로드밸런서 뒷단에 서버를 추가하거나 제거하기도 까다로워지고, 서버의 장애를 처리하기도 복잡해진다.

**무상태 아키텍처**  

<img width="624" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/fbd1e93a-3dc9-44bf-8f4e-1b1304645a5a">

- 이 구조에서는 HTTP 요청이 어떤 웹 서버로도 전달될 수 있다. 
- 웹 서버는 상태 정보가 필요할 경우 공유 저장소로부터 데이터를 가져온다. 
- 따라서 상태 정보는 웹 서버로부터 물리적으로 분리되어 있고, 구조가 단순하고 안정적이며 규모 확장이 쉬워진다.

<img width="854" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/28e3d617-a065-4051-8dc0-5d260f515a23">

- 세션 데이터를 웹 계층에서 분리하고 지속성 데이터 보관소에 저장하도록 만들었다.
- 이 공유 저장소는 RDB가 될수도 있고, Memcached/Redis 같은 캐시 시스템일 수도 있고 NoSQL일 수도 있다.
- 여기서는 NoSQL을 사용하였으며, 규모 확장이 간편해서다.


가용성을 높이고 전 세계 어디서도 쾌적하게 사용할 수 있도록 하려면  
여러 데이터 센터를 지원하는 것이 필수다.

### 데이터 센터

<img width="854" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/d87c323d-99d8-48be-862e-314b314af0cf">

- 두 개의 데이터 센터를 이용하는 사례다.
- 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데, 이것을 지리적 라우팅이라고(geoDNS-routing or geo-routing) 부른다.
- 지리적 라우팅에서의 geoDNS는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해주는 DNS 서비스다.

<img width="854" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/0345acc1-a6c7-444b-8f52-a3f313d2265a">

- 데이터 센터 중 하나에 심각한 장애가 발생하면 모든 트래픽이 장애가 없는 데이터 센터로 전송된다.
- 위 그림은 US-West에 장애가 발생하여, US-East로 전송되는 상황이다.

이 사례와 같은 다중 데이터센터 아키텍처를 만들려면 몇가지 기술적 난제를 해결해야 한다.
- 트래픽 우회: 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야한다. ex) GeoDNS
- 데이터 동기화: 데이터 센터마다 별도의 DB를 사용하면, 장애가 자동으로 복구되어 트래픽이 다른 DB로 우회되도, 해당 데이터센터에는 찾는 데이터가 없을 수 있다. 이런 상황을 막는 보편적 전략은 데이터를 여러 데이터센터에 걸쳐 다중화하는 것이다.
- 테스트와 배포: 웹 사이트 또는 애플리케이션을 여러 위치에서 테스트해보는 것이 중요하다. 또, 자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 하는 데 중요한 역할을 한다.

시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여, 각기 독립적으로 확장될 수 있도록 하여야 한다.  
메시지 큐는 많은 실제 분산 시스템이 이 문제를 풀기 위해 채용하고 있는 핵심적 전략 가운데 하나다. 

### 메시지 큐 
- 메시지의 무손실을 보장하는, 비동기 통신을 지원하는 컴포넌트다. 
- 메시지의 버퍼 역할을 하며, 비동기적으로 전송한다. 
- 메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다. 


<img width="759" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/737f8c57-6d92-4747-92f6-b7f087553fbb">

- 이미지의 크로핑, 샤프닝, 블러핑 등을 지원하는 사진 보정 애플리케이션을 만든다고 해 보자.
- 보정은 시간이 오래 걸릴 수 있는 프로세스이므로 비동기적으로 처리하면 편하다.
- 웹 서버는 사진 보정 작업을 메시지 큐에 넣는다. 
- 사진 보정 작업(worker) 프로세스들은 이 작업을 메시지 큐에서 꺼내어 비동기적으로 완료한다.
- 생산자와 소비자 서비스의 규모는 각기 독립적으로 확장될 수 있다. 
- 큐의 크기가  커지면 작업 프로세스를 늘리고, 큐가 항상 비어 있는 상태라면 작업 프로세스의 수를 줄일 수 있다. 

### 로그, 메트릭, 그리고 자동화 
- 소규모 웹 사이트에선 필요 없지만, 웹사이트와 함께 사업 규모가 커지고나면 로그나 메트릭, 자동화 같은 도구에 필수적으로 투자해야 한다.
- 로그: 에러 로그를 서버 단위로 모니터링 할 수도 있지만, 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 검색하고 조회할 수 있다. 
- 메트릭
  - 호스트 단위 메트릭: CPU, 메모리, 디스크 I/O에 관한 메트릭
  - 종합 메트릭: DB 계층의 성능, 캐시 계층의 성능 
  - 핵심 비즈니스 메트릭: 일별 능동 사용자, 수익, 재방문 등
- 자동화: 시스템이 크고 복잡해지면 생산성을 높이기 위해 자동화 도구를 활용해야 한다. 
  - 지속적 통합을 도와주는 도구를 활용하면 개발자가 만드는 코드가 어떤 검증 절차를 자동으로 거치도록 할 수 있어서 문제를 쉽게 감지할 수 있다.


**메시지 큐, 로그, 메트릭, 자동화 등을 반영하여 수정한 설계안**  

<img width="831" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/0ebc156a-6ab2-4ccb-a255-52b55b38f090">

1. 메시지큐는 각 컴포넌트가 느슨히 결합될 수 있도록 하고, 결함에 대한 내성을 높인다.
2. 로그, 모니터링 메트릭, 자동화 등을 지원하기 위한 장치를 추가했다.


### 데이터베이스의 규모 확장  
- 저장할 데이터가 많아지면 DB에 대한 부하가 증가하고, 그때엔 DB를 증설할 방법을 찾아야 한다.
- DB 규모를 확장하는데는 수직적 규모 확장법, 수평적 규모 확장법이 있다.

**수직적 확장**  
- 고성능의 자원(CPu, RAM, 디스크 등)을 증설하는 방법
- 수직적 접근법에는 단점이 있다.
  - 무한 증설이 불가능 하다.
  - SPOF 위험성
  - 고성능 서버로 갈수록 가격이 올라가서, 비용이 많이 든다.

**수평적 확장**  
- 샤딩이라고도 부름, 더 많은 서버를 추가해서 성능 향상 
- 대규모 DB를 샤드라고 부르는 작은 단위로 분할하는 기술을 일컫는다. 
- 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.

<img width="834" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/71ac5974-e3c0-4203-8d4c-5f3cc64a27ed">

- 샤드로 분할된 데이터베이스의 예다.
- 이 케이스에서는 사용자 데이터를 어느 샤드에 넣을지는 사용자 ID에 따라 정한다.
- 샤딩 전략을 구현할 때 고려해야 할 가장 중요한 것은 샤딩 키를 어떻게 정하느냐다.
- 샤딩 키는 파티션 키라고도 부르는데, 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성된다. 
- 위 케이스에서는 샤딩키가 user_id 이다. 
- 샤딩 키를 정할 때는 데이터를 고르게 분할 할 수 있도록 하는게 가장 중요하다. 


샤딩은 DB 규모 확장을 실현하는 훌륭한 기술이지만 완벽하진 않고, 도입하면 시스템이 복잡해지고 풀어야할 새로운 문제도 생긴다. 
- 데이터의 재 샤딩(resharding)
  - 1) 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때
  - 2) 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때 
  - 샤드소진 이라고도 부르는 이런 현상이 발생하면 샤드 키를 계싼하는 함수를 변경하고 데이터를 재배치해야 한다. 안정해시 기법을 활용하면 이 문제를 해결할 수 있다.
- 유명인사(celebrity) 문제
   - 핫스팟 키 문제라고도 부르는데, 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제다.
   - 이 문제를 풀려면 샤드를 잘 쪼개는게 중요하다.
- 조인과 비정규화
  - 하나의 DB를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다. 
  - 이를 해결하는 한 가지 방법은 DB를 비정규화하여 하나의 테이블에서 질의가 수행할 수 있도록 하는 것이다. 

<img width="834" alt="image" src="https://github.com/sinkyoungdeok/TIL/assets/28394879/d259088b-afa8-4afc-9849-cfb544856613">

- 샤딩을 적용 하고 DB에 대한 부하를 줄이기 위해 굳이 RDB가 요구되지 않는 기능들은 NoSQL로 이전했다.


### 백만 사용자, 그리고 그 이상
- 시스템의 규모를 확장하는 것은 지속적이고 반복적인 과정이다. 
- 수백만 사용자 이상을 지원하려면 새로운 전략을 도입해야 하고 지속적으로 시스템을 가다듬어야 할 것이다. ex) 시스템을 최적화하고 더 작은 단위의 서비스로 분할해야 할 수도 있다. 
- 이번 장에서 시스템 규모 확장을 위해 살펴본 기법들을 정리해보면
  - 웹 계층은 무상태 계층으로
  - 모든 계층에 다중화 도입
  - 가능한 한 많은 데이터를 캐시
  - 여러 데이터 센터를 지원
  - 정적 콘텐츠는 CDN 사용 
  - 데이터 계층은 샤딩을 통해 확장
  - 각 계층은 독립적 서비스로 분할
  - 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것

