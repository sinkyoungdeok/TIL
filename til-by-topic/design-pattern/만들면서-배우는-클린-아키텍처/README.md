

- [1. 계층형 아키텍처의 문제는 무엇일까?](#1-계층형-아키텍처의-문제는-무엇일까)
    - [계층형 아키텍처의 좋은점](#계층형-아키텍처의-좋은점)
    - [계층형 아키텍처의 문제점](#계층형-아키텍처의-문제점)
  - [a. 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다](#a-계층형-아키텍처는-데이터베이스-주도-설계를-유도한다)
    - [모든것이 영속성 계층을 토대로 만들어진다.](#모든것이-영속성-계층을-토대로-만들어진다)
    - [우리가 만드는 애플리케이션의 목적](#우리가-만드는-애플리케이션의-목적)
    - [도메인 로직이 아니라 데이터베이스를 토대로 아키텍처를 만드는 이유](#도메인-로직이-아니라-데이터베이스를-토대로-아키텍처를-만드는-이유)
  - [b. 지름길을 택하기 쉬워진다](#b-지름길을-택하기-쉬워진다)
    - [전통적인 계층형 아키텍처에서는 하나의 규칙만 있다.](#전통적인-계층형-아키텍처에서는-하나의-규칙만-있다)
    - [택하기 쉬운 지름길](#택하기-쉬운-지름길)
    - [지름길을 없애는 방법](#지름길을-없애는-방법)
  - [c. 테스트하기 어려워진다](#c-테스트하기-어려워진다)
    - [계층을 건너 뛰다.](#계층을-건너-뛰다)
    - [계층을 건너 뛰는것의 문제점](#계층을-건너-뛰는것의-문제점)
  - [d. 유스케이스를 숨긴다](#d-유스케이스를-숨긴다)
    - [새로운 유스케이스 조와](#새로운-유스케이스-조와)
    - [계층형 아키텍처의 문제점](#계층형-아키텍처의-문제점-1)
  - [e. 동시 작업이 어려워진다](#e-동시-작업이-어려워진다)
    - [지연되는 소프트웨어 프로젝트에 인력을 더하는 것은 개발을 늦출 뿐이다.](#지연되는-소프트웨어-프로젝트에-인력을-더하는-것은-개발을-늦출-뿐이다)
    - [적절한 규모에서의 인력 추가](#적절한-규모에서의-인력-추가)
    - [계층형 아키텍처의 동시작업](#계층형-아키텍처의-동시작업)
  - [f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#f-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까)
- [2. 의존성 역전하기](#2-의존성-역전하기)
  - [a. 단일 책임 원칙](#a-단일-책임-원칙)
    - [단일 책임 원칙의 오해](#단일-책임-원칙의-오해)
    - [변경할 이유](#변경할-이유)
  - [b. 부수효과에 관한 이야기](#b-부수효과에-관한-이야기)
  - [c. 의존성 역전 원칙](#c-의존성-역전-원칙)
    - [의존성으로 인한 도메인 계층 변경](#의존성으로-인한-도메인-계층-변경)
    - [의존성 역전 원칙](#의존성-역전-원칙)
  - [d. 클린 아키텍처](#d-클린-아키텍처)
    - [클린 아키텍처란](#클린-아키텍처란)
    - [클린 아키텍처의 대가](#클린-아키텍처의-대가)
  - [e. 육각형 아키텍처(헥사고날 아키텍처)](#e-육각형-아키텍처헥사고날-아키텍처)
    - [육각형 아키텍처](#육각형-아키텍처)
    - [육각형 아키텍처를 계층으로 구성](#육각형-아키텍처를-계층으로-구성)
  - [f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#f-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까-1)
- [3. 코드 구성하기](#3-코드-구성하기)
  - [a. 계층으로 구성하기](#a-계층으로-구성하기)
    - [계층으로 코드를 구성하면 기능적인 측면들이 섞이기 쉽다.](#계층으로-코드를-구성하면-기능적인-측면들이-섞이기-쉽다)
  - [b. 기능으로 구성하기](#b-기능으로-구성하기)
    - [기능을 기준으로 코드를 구성하면 기반 아키텍처가 명확하게 보이지 않는다.](#기능을-기준으로-코드를-구성하면-기반-아키텍처가-명확하게-보이지-않는다)
  - [c. 아키텍처적으로 표현력 있는 패키지 구조](#c-아키텍처적으로-표현력-있는-패키지-구조)
  - [d. 의존성 주입의 역할](#d-의존성-주입의-역할)
  - [e. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#e-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까)
- [4. 유스케이스 구현하기](#4-유스케이스-구현하기)
  - [a. 도메인 모델 구현하기](#a-도메인-모델-구현하기)
  - [b. 유스케이스 둘러보기](#b-유스케이스-둘러보기)
  - [c. 입력 유효성 검증](#c-입력-유효성-검증)
  - [d. 생성자의 힘](#d-생성자의-힘)
  - [e. 유스케이스마다 다른 입력 모델](#e-유스케이스마다-다른-입력-모델)
  - [f. 비즈니스 규칙 검증하기](#f-비즈니스-규칙-검증하기)
  - [g. 풍부한 도메인 모델 vs 빈약한 도메인 모델](#g-풍부한-도메인-모델-vs-빈약한-도메인-모델)
  - [h. 유스케이스마다 다른 출력 모델](#h-유스케이스마다-다른-출력-모델)
  - [i. 읽기 전용 유스케이스는 어떨까?](#i-읽기-전용-유스케이스는-어떨까)
  - [j. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#j-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까)
  - [k. 의존성 역전](#k-의존성-역전)
- [5. 웹 어댑터 구현하기](#5-웹-어댑터-구현하기)
  - [a. 웹 어댑터의 책임](#a-웹-어댑터의-책임)
  - [b. 컨트롤러 나누기](#b-컨트롤러-나누기)
  - [c. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#c-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까)
  - [d. 의존성 역전](#d-의존성-역전)
- [6. 영속성 어댑터 구현하기](#6-영속성-어댑터-구현하기)
  - [a. 영속성 어댑터의 책임](#a-영속성-어댑터의-책임)
  - [b. 포트 인터페이스 나누기](#b-포트-인터페이스-나누기)
  - [c. 영속성 어댑터 나누기](#c-영속성-어댑터-나누기)
  - [d. 스프링 데이터 JPA 예제](#d-스프링-데이터-jpa-예제)
  - [e. 데이터베이스 트랜잭션은 어떻게 해야 할까?](#e-데이터베이스-트랜잭션은-어떻게-해야-할까)
  - [f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#f-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까-2)
- [7. 아키텍처 요소 테스트하기](#7-아키텍처-요소-테스트하기)
- [8. 경계 간 매핑하기](#8-경계-간-매핑하기)
- [9. 애플리케이션 조립하기](#9-애플리케이션-조립하기)
- [10. 아키텍처 경계 강제하기](#10-아키텍처-경계-강제하기)
- [11. 의식적으로 지름길 상요하기](#11-의식적으로-지름길-상요하기)
- [12. 아키텍처 스타일 결정하기](#12-아키텍처-스타일-결정하기)




# 1. 계층형 아키텍처의 문제는 무엇일까?

```mermaid
graph TD;
    웹 --> 도메인 
    도메인 --> 영속성
```
- 위의 그림은 일반적인 3계층 아키텍처이다.
- 웹계층
  - 요청을 받아 도메인 or 비즈니스 계층에 있는 서비스로 요청 
- 도메인 혹은 서비스
  - 필요한 비즈니스 로직을 수행하고
  - 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 영속성 계층의 컴포넌트를 호출 

### 계층형 아키텍처의 좋은점 
- 계층을 잘 이해하고 구성한다면 웹계층이나 영속성 계층에 독립적으로 도메인 로직을 작성할 수 있다.
- 도메인 로직에 영향을 주지 않고 웹 계층과 영속성 계층에 사용된 기술을 변경할 수 있다.
- 기존 기능에 영향을 주지 않고 새로운 기능을 추가할 수 있다. 
- 잘 만들면 선택의 폭을 넓히고, 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있다. 

### 계층형 아키텍처의 문제점 
- 코드에 나쁜 습관들이 스며들기 쉽다.
- 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 많은 허점들을 노출한다.


## a. 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다

### 모든것이 영속성 계층을 토대로 만들어진다.
- 전통적인 계층형 아키텍처의 토대는 DB이다.
- 웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 자연스럽게 데이터베이스에 의존한다.

### 우리가 만드는 애플리케이션의 목적 
- 비즈니스를 관장하는 규칙이나 정책을 반영한 모델을 만들어서 사용자가 이러한 규칙과 정책을 더욱 편리하게 활용할 수 있게 한다. 
- 상태(state)가 아니라 행동(behavior)을 중심으로 모델링한다.
- 행동이 상태를 바꾸는 주체이기 때문에 행동이 비즈니스를 이끌어간다. 

### 도메인 로직이 아니라 데이터베이스를 토대로 아키텍처를 만드는 이유 
- 계층형 아키텍처에서는 의존성 방향에 따라 자연스럽게 데이터베이스의 구조를 먼저 생각하고, 이를 토대로 도메인 로직을 구현한다.
  - 이 구현 방법은 비즈니스 관점에서는 맞지 않는 방법이다.
  - 도메인 로직을 먼저 만들고, 로직을 제대로 이해 했는지 확인한 후에 이를 기반으로 영속성 계층과 웹 계층을 만들어야 한다.
- 가장 큰 이유는, ORM 프레임워크를 사용하기 때문이다.
  - 계층형 + ORM 프레임워크 결합은 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.

```mermaid
graph TD;
    도메인.서비스 --> 영속성.엔티티 
    도메인.서비스 --> 영속성.리포지터리
    영속성.리포지터리 --> 영속성.엔티티
``` 
- ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 둔다.
  - 계층은 아래방향으로만 접근 가능하기 때문에 도메인 계층에서는 이러한 엔티티에 접근할 수 있다.
  - 그리고, 이러한 엔티티에 접근할 수 있다면 분명 사용되기 마련이다.
- 하지만, 이렇게 구성되면 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다.
  - 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 
  - 이로 인해 도메인 로직 뿐만 아니라 즉시 로딩/지연 로딩, 데이터베이스 트랜잭션, 캐시 플러시 등 영속성 계층과 관련된 작업들을 해야 한다. 
- 영속성 코드가 사실상 도메인 코드에 녹아들어서 둘 중 하나만 바꾸는 것이 어려워 진다.
  - 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 정확히 반대되는 상황이다.


## b. 지름길을 택하기 쉬워진다

### 전통적인 계층형 아키텍처에서는 하나의 규칙만 있다.
- 특정 계층에서 같은 계층 또는 아래에 있는 계층에만 접근 가능하다.
- 위의 규칙 이외에는 아키텍처에서의 강제성은 없다.

### 택하기 쉬운 지름길
- 상위 계층에 접근해야 하는 경우, 그 컴포넌트를 내리면 그만이다.
- 한번이 어렵지, 유혹을 뿌리치기가 쉽지 않다.

```mermaid
graph TD;
    도메인.서비스 --> 영속성.헬퍼 
    도메인.서비스 --> 영속성.리포지터리
    도메인.서비스 --> 영속성.유틸리티
    영속성.리포지터리 --> 영속성.헬퍼
    영속성.리포지터리 --> 영속성.유틸리티
```
- 영속성 계층에서는 모든 것에 접근이 가능하기 떄문에 시간이 지나면서 점점 비대해진다.
- 수년에 걸친 개발과 유지보수로 결국 위의 그림으로 될 확률이 높다.

### 지름길을 없애는 방법 
- 규칙이 깨졌을 때 빌드가 실패하도록 만드는 규칙이 필요하다.
- 위와 같은 규칙이 없다면 계층형 아키텍처는 최선의 선택이 아니다. 
- 시니어 개발자가 코드 리뷰를 한다고 해도 의미는 없다. 


## c. 테스트하기 어려워진다

### 계층을 건너 뛰다.
- 엔티티의 필드를 단 하나만 조작하면 되는 경우에 웹 계층에서 바로 영속성 계층에 접근하면 도메인 계층을 건드릴 필요가 없지 않을까? 란 생각이 종종 든다.

```mermaid
graph TD;

웹.컨트롤러 --> 영속성.엔티티 
웹.컨트롤러 --> 영속성.리포지터리
도메인.서비스 --> 영속성.엔티티
도메인.서비스 --> 영속성.리포지터리
영속성.리포지터리 --> 영속성.엔티티
```
- 처음 몇번은 괜찮게 느껴지지만, 이런일이 자주 발생하면 두가지 문제점이 생긴다.

### 계층을 건너 뛰는것의 문제점 
1. 단하나의 필드를 조작하는 것에 불과 하더라도 도메인 로직을 웹 계층에 구현하게 된다. 
   - 만약 유스케이스가 확장된다면 어떻게 될까? 
   - 더 많은 도메인 로직을 웹 계층에 추가해서 어플리케이션 전반에 걸쳐 책임이 섞이고 핵심 도메인 로직들이 퍼져나갈 확률이 높다 
2. 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 모킹해야 한다.
   - 테스트의 복잡도가 올라간다.
   - 테스트 설정이 복잡해짐으로써 테스트를 전혀 작성하지 않는 방향으로 가는 첫 걸음이다. (복잡한 설정을 할 시간이 없기 떄문)
   - 컴포넌트의 규모가 커지면 테스트 코드를 작성하는 것보다 종속성을 이해하고 목을 만드는데 더 많은 시간이 걸린다. 

## d. 유스케이스를 숨긴다

### 새로운 유스케이스 조와
- 개발자들은 새로운 유스케이스를 구현하는 새로운 코드를 짜는 것을 좋아한다.
- 그러나, 실제로는 기존 코드를 바꾸는 데 더 많은 시간을 쓴다.
- 레거시 프로젝트에만 해당 되는 것이 아니라, 신규 프로젝트에서도 해당이 되는 이야기이다.
- 기능을 추가하거나 변경할 적절한 위치를 찾는일이 많기 떄문에 아키텍처는 코드를 빠르게 탐색하는데 도움이 돼야 한다.
- 이런 관점에서 계층형 아키텍처의 문제는 무엇일까?

### 계층형 아키텍처의 문제점
- 계층형 아키텍처는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다.
  - 유스케이스가 간단해서 도메인 계층을 생략한다면 웹 계층에 존재할 수도 있고,
  - 도메인 계층과 영속성 계층 모두에서 접근할 수 있도록 특정 컴포넌트를 아래로 내렸다면 영속성 계층에 존재할 수도 있다
  - 이럴 경우 새로운 기능을 추가할 적당한 위치를 찾는 일은 이미 어려워 진다.

```mermaid
graph TD;

웹.컨트롤러1 --> 도메인.서비스
웹.컨트롤러2 --> 도메인.서비스
도메인.서비스 --> 영속성.헬퍼
도메인.서비스 --> 영속성.리포지토리
도메인.서비스 --> 영속성.유틸리티 
영속성.리포지토리 --> 영속성.헬퍼
영속성.리포지토리 --> 영속성.유틸리티
```
- 계층형 아키텍처는 도메인 서비스의 너비에 관한 규칙을 강제하지 않는다.
  - 시간이 지날수록 여러개의 유스케이스를 담당하는 아주 넓은 도메인 서비스가 만들어지기도 한다
  - 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다.
  - 그럼 서비스를 테스트하기도 어려워지고 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.
- 고도로 특화된 좁은 도메인 서비스가 유스케이스 하나씩만 담당하게 된다면 어떨까?
  - UserService에서 사용자 등록 유스케이스를 찾는 대신 
  - RegisterUserService를 바로 열어서 작업을 시작하면 유스케이스를 책임지는 서비스를 찾기가 수월해진다.

## e. 동시 작업이 어려워진다

### 지연되는 소프트웨어 프로젝트에 인력을 더하는 것은 개발을 늦출 뿐이다.
- 지연되지 않은 소프트웨어 프로젝트에 대해서도 마찬가지다.
- 모든 상황에서 50명 정도의 큰 규모의 개발팀이 10명 정도 되는 작은 규모의 개발 팀 보다 5배 빠를거라고 기대할 수 없다.
- 여러 하위팀으로 쪼개서 각기 분리된 파트를 개발할 수 있는 아주 규모가 큰 애플리케이션을 만들고 있다면 그럴 수도 있지만, 대부분은 서로 도움을 주고 받으며 개발해야 한다

### 적절한 규모에서의 인력 추가
- 적절한 규모에서는 프로젝트에 인원이 더 투입될 경우 확실히 더 빨라지지만, 이것도 아키텍처가 동시 작업을 지원해야 한다.
- 그 아키텍처가 계층형 아키텍처는 아니다.

### 계층형 아키텍처의 동시작업
- 새로운 유스케이스를 추가할 때 
  - 개발자가 3명이 있다.
  - 한명은 웹 계층, 한명은 도메인 계층, 한명은 영속성 계층에 기능을 추가한다고 상상해보자.
- 계층형 아키텍처에서는 하나의 유스케이스를 동시작업을 할 수 없다.
  - 모든 것이 영속성 게층 위에 만들어지기 떄문에 영속성 계층을 먼저 개발해야 하고, 그다음 도메인 계층, 그다음 웹계층을 만들어야 한다.
  - 그렇기 때문에 특정 기능은 동시에 한명의 개발자만 작업할 수 있다.
- 인터페이스를 먼저 같이 정의하고, 구현을 기다릴 필요 없이 인터페이스로 작업하면 될까?
  - 데이터베이스 주도 설계를 하지 않는 경우에만 가능하다.
  - 데이터베이스 주도 설계는 영속성 로직이 도메인 로직과 뒤섞여서 각 측면을 개별적으로 작업할 수 없다
- 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어렵다
  - 서로 다른 유스케이스에 대한 작업을 하게 되면 같은 서비스를 동시에 편집하는 상황이 발생하고, 
  - 이는 병합 충돌과 잠재적으로 이전 코드로 되돌려야 하는 문제가 생긴다.

## f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 
- 올바르게 구축하고 몇 가지 추가적인 규칙들을 적용하면 계층형 아키텍처는 유지보수에 적합할 수 있다.
- 하지만, 많은 것들이 잘못된 방향으로 흘러가도록 용인한다.
- 아주 엄격한 자기 훈련 없이는 시간이 지날수록 품질이 저하되고 유지보수하기가 어려워지기 쉽다
- 어느 아키텍처로 만들던, 게층형 아키텍처의 함정을 염두에 두고 지름길을 택하지 않으면 유지보수하기 적합한 소프트웨어가 만들어질 수 있다.

# 2. 의존성 역전하기

- 1장에서는 계층형 아키텍처의 단점만 늘어놓았고, 이번엔 대안에 대해서 이야기 해보자.

## a. 단일 책임 원칙

### 단일 책임 원칙의 오해
- `단일 책임의 원칙하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다`
- 위의 해석은 단일 책임이라는 말을 가장 직관적으로 해석한것이고, 실제 정의는 아래와 같다.
- `컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.`
- 컴포넌트를 변경할 이유가 한 가지라면 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 신경쓸 필요가 없어진다.

### 변경할 이유 
- 변경할 이유는 컴포넌트 간의 의존성을 통해 쉽게 전파된다.

```mermaid
graph LR;

A --> B
A --> C
B --> E
C --> D
D --> E
```
- 위 그림에서는 A -> E, A -> D 는 직접적으로 연결되진 않았지만, 간접적으로 의존하고 있고 이것을 전이 의존성이라고 한다.
- 컴포넌트 A는 다른 컴포넌트에 모두 의존하고 있지만, E는 의존하는것이 전혀 없다.
- 컴포넌트 E를 변경할 유일한 이유는 새로운 요구사항에 의해 E의 기능을 바꿔야 할 때 뿐이다.
- 반면 컴포넌트 A의 경우에는 모든 컴포넌트에 의존하고 있기 때문에 다른 어떤 컴포넌트가 바뀌든지 같이 바뀌어야 한다.
- 많은 코드가 단일 책임 원칙을 위반하기 때문에 시간이 갈수록 변경하기가 더 어려워지고 변경 비용도 증가한다.
  - 시간이 갈수록 컴포넌트를 변경할 이유가 더 많아진다.
  - 변경할 이유가 많아지면 한 컴포넌트를 바꾸는 것이 다른 컴포넌트가 실패하는 원인으로 작용할 수 있다. 

## b. 부수효과에 관한 이야기

저자님의 에피소드 

- 다른 소프트웨어 회사에서 개발한 10년 된 코드를 받아서 진행하는 프로젝트에 참여한적이 있었다.
- 예상했던 대로 코드가 실제로 어떤 일을 하는지를 이해하기가 쉽지 않았고, 코드의 한 영역을 변경했더니 다른 영역에서 부수효과가 생겨났었다.
  - 하지만 철저하게 테스트하고 자동화된 테스트를 추가하고 리팩터링을 많이해서 어찌저찌 해나갔다.
- 코드를 성공적으로 유지보수하고 확장한 후, 클라이언트는 이 소프트웨어의 사용자 입장에서 굉장히 이상한 방식으로 동작하는 새로운 기능을 구현해 달라고 요청했다.
  - 그래서 저자는 조금 더 사용자 친화적이면서도 전반적인 변경이 더 적어 구현하는 비용도 더 저렴한 방식을 제안했다.
  - 하지만, 이는 아주 핵심적인 특정 컴포넌트를 변경해야 하는 작업이었다.
- 클라이언트는 필자의 제안을 거절했고, 더 이상하고 비용이 많이 드는 방식을 주문했다.
  - 그 이유를들어보니, 이전 개발팀에서 과거에 그 컴포넌트를 변경했을 때 언제나 다른 무언가가 망가졌기 때문에 변경에 대한 부수효과를 우려했던 것이다.
- 안타깝게도 이 사례는 클라이언트로 하여금 잘못 구조화된 소프트웨어를 변경하는 데 더 많은 비용을 지불하도록 만드는 경우를 보여준다.
  - 다행히 대부분의 클라이언트는 이런식으로 대응하지 않을 것이다.
  - 그러니 이러한 방식 대신 좋은 소프트웨어를 만들도록 노력해보자.


## c. 의존성 역전 원칙

### 의존성으로 인한 도메인 계층 변경
- 계층형 아키텍처는 항상 다음 계층인 아래방향으로 의존한다.
  - 단일 책임 원칙을 고수준에서 적용할 때 하위계층보다 상위계층이 변경할 이유가 많다.
- 영속성 계층을 변경할 때마다 도메인 계층도 변경해야 한다.
  - 도메인 계층은 애플리케이션에서 가장 중요한 코드이므로 영속성 코드가 바뀐다고 해서 도메인 코드까지 바꾸고 싶지 않다.
- 이 의존성을 어떻게 제거 할까? 


### 의존성 역전 원칙 
`코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수)있다`
- 사실 의존성의 양쪼 코드를 모두 제어할 수 있을 때만 의존성을 역전시킬 수 없다.
  - 만약, 서드파티 라이브러리에 의존성이 있다면 해당 라이브러리를 제어할 수 없기 때문에 이 의존성은 역전할 수 없다.
- 도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 영속성 코드가 도메인 코드에 의존하고, 도메인 코드의 `변경할 이유`의 개수를 줄여보자.
- 엔티티는 도메인 객체를 표현하고 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 하기 때문에 먼저 엔티티를 도메인 계층으로 올린다.
- 그러나 영속성 계층의 리포지토리가 도메인 계층에 있는 엔티티에 의존하기 때문에 두 계층 사이에 순환 의존성이 생긴다.
  - 이부분이 바로 DIP를 적용하는 부분이다.
  - 도메인 계층에 리포지토리에 대한 인터페이스를 만들고
  - 실제 리포지토리는 영속성 계층에서 구현한다.

```mermaid
graph TD;

도메인.서비스 --> 도메인.엔티티 
도메인.서비스 --> 도메인.리포지토리
도메인.리포지토리 --> 도메인.엔티티
영속성.리포지토리구현체 --> 도메인.리포지토리
영속성.리포지토리구현체 --> 영속성.엔티티-ORM-Managed
```
- 영속성 코드에 있는 숨막히는 의존성으로부터 도메인 로직을 해방시켰다.
- 이것이 바로 다음 절에서 살펴볼 두 가지 아키텍처 스타일의 핵심 기능이다.


## d. 클린 아키텍처

### 클린 아키텍처란 
- 설계가 비즈니스 규칙의 테스트를 용이하게 하고 
- 비즈니스 규칙은 프레임워크, 데이터베이스, UI 기술, 그밖의 외부 애플리케이션이나 인터페이스로부터 독립적이어야 한다.
- 이는 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함을 의미한다. 
  - 대신 의존성 역전 원칙의 도움으로 모든 의존성이 도메인코드를 향하고 있다.

![image](https://user-images.githubusercontent.com/28394879/189476142-1a9600c7-e219-4eb6-b470-9170bf75d43a.png)
- 이 아키텍처에서 계층들은 동심원으로 둘러싸여 있다.
  - 이 아키텍처에서 가장 주요한 규칙은 의존성 규칙으로, 계층 간의 모든 의존성이 안쪽으로 향해야 한다.
- 이 아키텍처의 코어에는 주변 유스케이스에서 접근하는 도메인 엔티티들이 있다.
  - 유스케이스는 서비스인데, 단일 책임을 갖기 위해 조금 더 세분하여 넓은 서비스 문제를 피한다.
- 코어 주변으로 비즈니스 규칙을 "지원"하는 애플리케이션의 다른 모든 컴포넌트들을 확인할 수 있다.
  - "지원": 영속성을 제공하거나 UI를 제공하는 것 등 을 의미
  - 바깥쪽 계층들은 다른 서드파티 컴포넌트에 어댑터를 제공할 수 있다.
- 도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고 비즈니스 규칙에 집중할 수 있다.
  - 그래서 도메인 코드를 자유롭게 모델링할 수 있다.
  - 예) DDD를 가장 순수한 형태로 적용할 수 있다.
  - 영속성이나 UI에 특화된 문제를 신경 쓰지 않아도 된다.

### 클린 아키텍처의 대가
- 도메인 계층이 영속성이나 UI 같은 외부 계층과 철저하게 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야 한다.
- ORM 프레임워크를 사용하면
  - 데이터베이스 구조 및 객체 필드와 데이터베이스 칼럼의 매핑을 서술한 메타데이터를 담고 있는 엔티티 클래스를 필요로 한다.
  - 도메인 계층은 영속성 계층을 모르기 떄문에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 함께 사용할 수 없고 두 계층에서 각각 엔티티를 만들어야 한다.
  - 즉, 도메인 계층과 영속성 계층이 데이터를 주고 받을 때, 두 엔티티를 서로 변환해야 한다. (도메인 계층과 다른 계층들 사이에서도 마찬가지)
- 하지만 이것은 바람직한 일이다.
  - 도메인 코드를 프레임워크에 특화된 문제로부터 해방시키고자 했던, 결합이 제거된 상태다.
  - JPA에서는 ORM이 관리하는 엔티티에 인자가 없는 기본 생성자를 추가하도록 강제한다.
  - 이것은 도메인 모델에는 포함해서는 안 될 플이무어크에 특화된 결합의 예다.
  - 8장에서 도메인 계층과 영속성 계층의 결합을 그대로 수용하는 '매핑 하지 않기' 전략을 비롯한 여러 매핑 전략에 대해 살펴보자.


## e. 육각형 아키텍처(헥사고날 아키텍처)

### 육각형 아키텍처
![image](https://user-images.githubusercontent.com/28394879/189481658-b74c759d-fa50-4153-890b-88ec96ec6c64.png)
- 애플리케이션 코어가 각 어댑터와 상호작용하기 위해 특정 포트를 제공하기 때문에 `포트와 어댑터` 아키텍처라고도 한다.
- 육각형 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있다.
  - 육각형에서 외부로 향하는 의존성이 없고 코어로만 의존성이 있다.
- 육각형 바깥에는 애플리케이션과 상호작용하는 다양한 어댑터들이 있다.
  - 웹 어댑터: 웹 브라우저와 상호작용
  - 일부 어댑터: 외부 시스템과 상호작용
  - 데이터베이스와 상호 작용하는 어댑터도 있다. 
- 왼쪽에 있는 어댑터들은 
  - 애플리케이션 코어를 호출하기 떄문에
  - 애플리케이션을 주도하는 어댑터들이다.
- 오른쪽에 있는 어댑터들은
  - 애플리케이션 코어에 의해 호출되기 떄문에
  - 애플리케이션에 의해 주도되는 어댑터들이다.
- 애플리케이션 코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각각의 포트를 제공해야 한다.
  - 주도하는 어댑터에게는 그러한 포트가 코어에 있는 유스케이스 클래스들에 의해 구현되고 호출된느 인터페이스가 된다
  - 주도되는 어댑터에게는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 된다

### 육각형 아키텍처를 계층으로 구성
- 가장 바깥쪽 계층: 애플리케이션과 다른 시스템 간의 번역을 담당하는 어댑터 계층 
- 다음 계층: 포트와 유스케이스 구현체를 결합해서 애플리케이션 계층 
- 마지막 계층: 위 두계층에서 애플리케이션의 인터페이스를 정의하고, 이 계층에서는 도메인 엔티티가 위치한다.

## f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 
- 어떤 아키텍처던 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 변경할 이유의 수를 줄일 수 있다.
  - 변경할 이유가 적을수록 유시보수성은 더 좋아진다.
  - 도메인 코드는 비즈니스 문제에 딱 맞도록 자유롭게 모델링할 수 있다.
  - 영속성 코드와 UI코드도 영속성 문제와 UI 문제에 맞게 자유롭게 모델링 될 수 있다.

# 3. 코드 구성하기 

- 이 장에서는 육각형 아키텍처를 직접적으로 반영하는 표현력 있는 패키지 구조를 소개한다.
- 본인의 계좌에서 다른 계좌로 돈을 송금할 수 있는 `송금하기` 유스케이스를 살펴보자.

## a. 계층으로 구성하기


### 계층으로 코드를 구성하면 기능적인 측면들이 섞이기 쉽다.
```
buckpal
├─ domain
│  ├─ Account
│  ├─ Activity 
│  ├─ AccountRepository   
│  └─ AccountService
├─ persistence
│  └─ AccountRepositoryImpl
├─ web
   └─ AccountController
```
- 웹 계층, 도메인 계층, 영속성 계층 패키지인 web, domain, persistence이다.
- 1장에서 소개한 것 처럼 여러가지 이유로 간단한 구조의 계층은 가장 적합한 구조가 아닐 수 있다.
- 그래서 이번에는 먼저 의존성 역전 원칙을 적용해서 의존성이 domain 패키지에 있는 도메인 코드만을 향하도록 해뒀다. 
  - domain 패키지에 AccountRepository 인터페이스를 추가하고
  - persistence 패키지에 AccountRepositoryImpl 구현체를 둠으로써 의존성을 역전시켰다.
- 그러나 적어도 3가지 이유로 이 패키지 구조는 최적의 구조가 아니다.

1. 애플리케이션의 기능 조각이나 특성을 구분 짓는 패키지 경계가 없다.
   - 사용자를 관리하는 기능을 추가해야 한다면 
   - web 패키지에 UserController를 추가하고 
   - domain 패키지에 UserService, UserRepository, User를 추가하고
   - persistence 패키지에 UserRepositoryImpl을 추가해야 한다.
   - 추가적인 구조가 없다면, 아주 빠르게 서로 연관되지 않은 기능들끼리 예상하지 못한 부수효과를 일으킬 수 있는 클래스들의 엉망진창 묶음으로 변모할 가능성이 크다.
2. 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다.
   - AccountService와 AccountController가 어떤 유스케이스를 구현했는지 파악할 수 있겠는가?
   - 특정 기능을 찾기 위해서는 어떤 서비스가 이를 구현했는지 추측해야 하고
   - 해당 서비스 내의 어떤 메서드가 그에 대한 책임을 수행하는지 찾아야 한다
3. 패키지 구조를 통해서는 우리가 목표로 하는 아키텍처를 파악할 수 없다.
   - 육각형 아키텍처 스타일을 따랐다고 추측할 수는 있고, 
   - 그렇기 때문에 웹 어댑터와 영속성 어댑터를 찾기 위해 web, persistence 패키지의 클래스들을 조사해볼 수 있다.
   - 하지만 어떤 기능이 웹 어댑터에서 호출되는지, 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한눈에 볼 수 없다.
   - 인커밍 포트와 아웃고잉 포트가 코드속에 숨겨져 있다.   


## b. 기능으로 구성하기

### 기능을 기준으로 코드를 구성하면 기반 아키텍처가 명확하게 보이지 않는다. 
```
buckpal
├─ account
   ├─ Account
   ├─ AccountController 
   ├─ AccountRepository   
   ├─ AccountRepositoryImpl   
   └─ SendMoneyService

```
- 각 기능을 묶은 새로운 그룹은 account와 같은 레벨의 새로운 패키지로 들어간다
  - 패키지 외부에서 접근되면 안되는 클래스에 대해 package-private 접근 수준을 이용해 패키지 간의 경계를 강화할 수 있다. 
  - 패키지 경계를 package-private 접근 수준과 결합하면 각 기능 사이의 불필요한 의존성을 방지할 수 있다. 
- AccountService의 책임을 좁히기 위해 SendMoneyService로 클래스명을 바꿨다.
  - 이는 계층에 의한 패키지 구조 방식에서도 할 수 있긴 했다.
  - 이제 '송금하기' 유스케이스를 구현한 코드는 클래스명만으로도 찾을 수 있다. 
  - 애플리케이션의 기능을 코드를 통해 볼 수 있게 만드는 것을 '소리치는 아키텍처'라고 한다. -> 코드가 그 의도를 우리에게 소리친다.
- 그러나 기능에 의한 패키징 방식은 계층에 의한 패키징 방식보다 아키텍처의 가시성을 훨씬 더 떨어뜨린다.
  - 어댑터를 나타내는 패키지명이 없고, 인커밍 포트, 아웃고잉 포트를 확인할 수 없다.
  - 심지어 도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 SendMoneyService가 AccountRepository 인터페이스만 알고 있고 구현체는 알 수 없도록 했음에도 불구하고, package-private 접근 수준을 이용해 도메인 코드가 실수로 영속성 코드에 의존하는 것을 막을 수 없다.
  
## c. 아키텍처적으로 표현력 있는 패키지 구조

## d. 의존성 주입의 역할

## e. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 


# 4. 유스케이스 구현하기

## a. 도메인 모델 구현하기 

## b. 유스케이스 둘러보기

## c. 입력 유효성 검증

## d. 생성자의 힘

## e. 유스케이스마다 다른 입력 모델

## f. 비즈니스 규칙 검증하기

## g. 풍부한 도메인 모델 vs 빈약한 도메인 모델

## h. 유스케이스마다 다른 출력 모델 

## i. 읽기 전용 유스케이스는 어떨까?

## j. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 

## k. 의존성 역전
 


# 5. 웹 어댑터 구현하기

## a. 웹 어댑터의 책임

## b. 컨트롤러 나누기

## c. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 

## d. 의존성 역전


# 6. 영속성 어댑터 구현하기 

## a. 영속성 어댑터의 책임

## b. 포트 인터페이스 나누기

## c. 영속성 어댑터 나누기

## d. 스프링 데이터 JPA 예제

## e. 데이터베이스 트랜잭션은 어떻게 해야 할까?

## f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 


# 7. 아키텍처 요소 테스트하기


# 8. 경계 간 매핑하기


# 9. 애플리케이션 조립하기


# 10. 아키텍처 경계 강제하기


# 11. 의식적으로 지름길 상요하기


# 12. 아키텍처 스타일 결정하기
