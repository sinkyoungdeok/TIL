

- [1. 계층형 아키텍처의 문제는 무엇일까?](#1-계층형-아키텍처의-문제는-무엇일까)
    - [계층형 아키텍처의 좋은점](#계층형-아키텍처의-좋은점)
    - [계층형 아키텍처의 문제점](#계층형-아키텍처의-문제점)
  - [a. 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다](#a-계층형-아키텍처는-데이터베이스-주도-설계를-유도한다)
    - [모든것이 영속성 계층을 토대로 만들어진다.](#모든것이-영속성-계층을-토대로-만들어진다)
    - [우리가 만드는 애플리케이션의 목적](#우리가-만드는-애플리케이션의-목적)
    - [도메인 로직이 아니라 데이터베이스를 토대로 아키텍처를 만드는 이유](#도메인-로직이-아니라-데이터베이스를-토대로-아키텍처를-만드는-이유)
  - [b. 지름길을 택하기 쉬워진다](#b-지름길을-택하기-쉬워진다)
  - [c. 테스트하기 어려워진다](#c-테스트하기-어려워진다)
  - [d. 유스케이스를 숨긴다](#d-유스케이스를-숨긴다)
  - [e. 동시 작업이 어려워진다](#e-동시-작업이-어려워진다)
  - [f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#f-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까)
- [2. 의존성 역전하기](#2-의존성-역전하기)
  - [a. 단일 책임 원칙](#a-단일-책임-원칙)
  - [b. 부수효과에 관한 이야기](#b-부수효과에-관한-이야기)
  - [c. 의존성 역전 원칙](#c-의존성-역전-원칙)
  - [d. 클린 아키텍처](#d-클린-아키텍처)
  - [e. 육각형 아키텍처(헥사고날 아키텍처)](#e-육각형-아키텍처헥사고날-아키텍처)
  - [f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#f-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까-1)
- [3. 코드 구성하기](#3-코드-구성하기)
  - [a. 계층으로 구성하기](#a-계층으로-구성하기)
  - [b. 기능으로 구성하기](#b-기능으로-구성하기)
  - [c. 아키텍처적으로 표현력 있는 패키지 구조](#c-아키텍처적으로-표현력-있는-패키지-구조)
  - [d. 의존성 주입의 역할](#d-의존성-주입의-역할)
  - [e. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#e-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까)
- [4. 유스케이스 구현하기](#4-유스케이스-구현하기)
  - [a. 도메인 모델 구현하기](#a-도메인-모델-구현하기)
  - [b. 유스케이스 둘러보기](#b-유스케이스-둘러보기)
  - [c. 입력 유효성 검증](#c-입력-유효성-검증)
  - [d. 생성자의 힘](#d-생성자의-힘)
  - [e. 유스케이스마다 다른 입력 모델](#e-유스케이스마다-다른-입력-모델)
  - [f. 비즈니스 규칙 검증하기](#f-비즈니스-규칙-검증하기)
  - [g. 풍부한 도메인 모델 vs 빈약한 도메인 모델](#g-풍부한-도메인-모델-vs-빈약한-도메인-모델)
  - [h. 유스케이스마다 다른 출력 모델](#h-유스케이스마다-다른-출력-모델)
  - [i. 읽기 전용 유스케이스는 어떨까?](#i-읽기-전용-유스케이스는-어떨까)
  - [j. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#j-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까)
  - [k. 의존성 역전](#k-의존성-역전)
- [5. 웹 어댑터 구현하기](#5-웹-어댑터-구현하기)
  - [a. 웹 어댑터의 책임](#a-웹-어댑터의-책임)
  - [b. 컨트롤러 나누기](#b-컨트롤러-나누기)
  - [c. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#c-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까)
  - [d. 의존성 역전](#d-의존성-역전)
- [6. 영속성 어댑터 구현하기](#6-영속성-어댑터-구현하기)
  - [a. 영속성 어댑터의 책임](#a-영속성-어댑터의-책임)
  - [b. 포트 인터페이스 나누기](#b-포트-인터페이스-나누기)
  - [c. 영속성 어댑터 나누기](#c-영속성-어댑터-나누기)
  - [d. 스프링 데이터 JPA 예제](#d-스프링-데이터-jpa-예제)
  - [e. 데이터베이스 트랜잭션은 어떻게 해야 할까?](#e-데이터베이스-트랜잭션은-어떻게-해야-할까)
  - [f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?](#f-유지보수-가능한-소프트웨어를-만드는-데-어떻게-도움이-될까-2)
- [7. 아키텍처 요소 테스트하기](#7-아키텍처-요소-테스트하기)
- [8. 경계 간 매핑하기](#8-경계-간-매핑하기)
- [9. 애플리케이션 조립하기](#9-애플리케이션-조립하기)
- [10. 아키텍처 경계 강제하기](#10-아키텍처-경계-강제하기)
- [11. 의식적으로 지름길 상요하기](#11-의식적으로-지름길-상요하기)
- [12. 아키텍처 스타일 결정하기](#12-아키텍처-스타일-결정하기)




# 1. 계층형 아키텍처의 문제는 무엇일까?

```mermaid
graph TD;
    웹 --> 도메인 
    도메인 --> 영속성
```
- 위의 그림은 일반적인 3계층 아키텍처이다.
- 웹계층
  - 요청을 받아 도메인 or 비즈니스 계층에 있는 서비스로 요청 
- 도메인 혹은 서비스
  - 필요한 비즈니스 로직을 수행하고
  - 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 영속성 계층의 컴포넌트를 호출 

### 계층형 아키텍처의 좋은점 
- 계층을 잘 이해하고 구성한다면 웹계층이나 영속성 계층에 독립적으로 도메인 로직을 작성할 수 있다.
- 도메인 로직에 영향을 주지 않고 웹 계층과 영속성 계층에 사용된 기술을 변경할 수 있다.
- 기존 기능에 영향을 주지 않고 새로운 기능을 추가할 수 있다. 
- 잘 만들면 선택의 폭을 넓히고, 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있다. 

### 계층형 아키텍처의 문제점 
- 코드에 나쁜 습관들이 스며들기 쉽다.
- 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 많은 허점들을 노출한다.


## a. 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다

### 모든것이 영속성 계층을 토대로 만들어진다.
- 전통적인 계층형 아키텍처의 토대는 DB이다.
- 웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 자연스럽게 데이터베이스에 의존한다.

### 우리가 만드는 애플리케이션의 목적 
- 비즈니스를 관장하는 규칙이나 정책을 반영한 모델을 만들어서 사용자가 이러한 규칙과 정책을 더욱 편리하게 활용할 수 있게 한다. 
- 상태(state)가 아니라 행동(behavior)을 중심으로 모델링한다.
- 행동이 상태를 바꾸는 주체이기 때문에 행동이 비즈니스를 이끌어간다. 

### 도메인 로직이 아니라 데이터베이스를 토대로 아키텍처를 만드는 이유 
- 계층형 아키텍처에서는 의존성 방향에 따라 자연스럽게 데이터베이스의 구조를 먼저 생각하고, 이를 토대로 도메인 로직을 구현한다.
  - 이 구현 방법은 비즈니스 관점에서는 맞지 않는 방법이다.
  - 도메인 로직을 먼저 만들고, 로직을 제대로 이해 했는지 확인한 후에 이를 기반으로 영속성 계층과 웹 계층을 만들어야 한다.
- 가장 큰 이유는, ORM 프레임워크를 사용하기 때문이다.
  - 계층형 + ORM 프레임워크 결합은 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.

```mermaid
graph TD;
    도메인.서비스 --> 영속성.엔티티 
    도메인.서비스 --> 영속성.리포지터리
    영속성.리포지터리 --> 영속성.엔티티
``` 
- ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 둔다.
  - 계층은 아래방향으로만 접근 가능하기 때문에 도메인 계층에서는 이러한 엔티티에 접근할 수 있다.
  - 그리고, 이러한 엔티티에 접근할 수 있다면 분명 사용되기 마련이다.
- 하지만, 이렇게 구성되면 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다.
  - 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 
  - 이로 인해 도메인 로직 뿐만 아니라 즉시 로딩/지연 로딩, 데이터베이스 트랜잭션, 캐시 플러시 등 영속성 계층과 관련된 작업들을 해야 한다. 
- 영속성 코드가 사실상 도메인 코드에 녹아들어서 둘 중 하나만 바꾸는 것이 어려워 진다.
  - 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 정확히 반대되는 상황이다.


## b. 지름길을 택하기 쉬워진다



## c. 테스트하기 어려워진다

## d. 유스케이스를 숨긴다

## e. 동시 작업이 어려워진다

## f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 


# 2. 의존성 역전하기

## a. 단일 책임 원칙

## b. 부수효과에 관한 이야기

## c. 의존성 역전 원칙

## d. 클린 아키텍처

## e. 육각형 아키텍처(헥사고날 아키텍처)

## f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 


# 3. 코드 구성하기 

## a. 계층으로 구성하기

## b. 기능으로 구성하기

## c. 아키텍처적으로 표현력 있는 패키지 구조

## d. 의존성 주입의 역할

## e. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 


# 4. 유스케이스 구현하기

## a. 도메인 모델 구현하기 

## b. 유스케이스 둘러보기

## c. 입력 유효성 검증

## d. 생성자의 힘

## e. 유스케이스마다 다른 입력 모델

## f. 비즈니스 규칙 검증하기

## g. 풍부한 도메인 모델 vs 빈약한 도메인 모델

## h. 유스케이스마다 다른 출력 모델 

## i. 읽기 전용 유스케이스는 어떨까?

## j. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 

## k. 의존성 역전
 


# 5. 웹 어댑터 구현하기

## a. 웹 어댑터의 책임

## b. 컨트롤러 나누기

## c. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 

## d. 의존성 역전


# 6. 영속성 어댑터 구현하기 

## a. 영속성 어댑터의 책임

## b. 포트 인터페이스 나누기

## c. 영속성 어댑터 나누기

## d. 스프링 데이터 JPA 예제

## e. 데이터베이스 트랜잭션은 어떻게 해야 할까?

## f. 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 


# 7. 아키텍처 요소 테스트하기


# 8. 경계 간 매핑하기


# 9. 애플리케이션 조립하기


# 10. 아키텍처 경계 강제하기


# 11. 의식적으로 지름길 상요하기


# 12. 아키텍처 스타일 결정하기
