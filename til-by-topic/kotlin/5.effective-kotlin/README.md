


# 1. 좋은 코드 


#### 1. 가변성을 제한하라 
- var 보다는 val을 사용
- mutable 프로퍼티, 객체, 클래스 보다는 immutable 프로퍼티, 객체, 클래스 사용
- 변경이 필요한 대상을 만들어야 하면, immutable + copy 활용 
- 컬렉션에 상태를 저장해야 하면, mutable 컬렉션보다는 읽기 전용 컬렉션을 사용
- 불필요한 변이 지점은 만들지 않는것이 좋다.
- mutable 객체는 외부에 노출하지 않는것이 좋다

#### 2. 변수의 스코프를 최소화하라
- 변수의 스코프는 좁게 만들어서 활용하는 것이 좋다.
- var 보다는 val 사용 

#### 3. 최대한 플랫폼 타입을 사용하지 말라
- nullable 여부를 알 수 없는 타입을 플랫폼 타입이라고 부른다.
- 플랫폼 타입을 사용하는 코드는 해당 부분만 위험할 뿐만 아니라, 이를 활용하는 곳까지 영향을 줄 수 있는 위험한 코드이다.
- 연결되어 있는 자바 생성자, 메서드, 필드에 nullable 여부를 지정하는 어노테이션을 활용하는 것도 좋다.

#### 4. inferred 타입으로 리턴하지 말라
- 타입을 확실하게 지정해야 하는 경우에는 명시적으로 타입을 지정해야 한다는 원칙만 갖고 있으면 된다.
- 안전을 위해서 외부 API를 만들 때는 반드시 타입을 지정하는것이 좋다.
- inferred 타입은 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수 있다.

#### 5. 예외를 활용해 코드에 제한을 걸어라
- require 블록
- check 블록
- assert 블록
- return throw와 함께 Elvis 연산자 사용 
위의 메커니즘을 통해서 얻을 수 있는 이득은 다음과 같다.
- 제한을 더 쉽게 확인
- 애플리케이션을 더 안정적으로 운영
- 코드를 잘못 쓰는 상황을 막을 수 있다. 
- 스마트 캐스팅을 활용할 수 있다. 

#### 6. 사용자 정의 오류보다는 표준 오류를 사용하라 

#### 7. 결과 부족이 발생할 경우 null과 Failure를 사용하라 

#### 8. 적절하게 null을 처리하라

- null을 안전하게 처리하기
  - 안전 호출, 스마트 캐스팅으로 안전하게 처리 
- 오류 throw하기
- not-null assertion(!!)과 관련된 문제
  - !!를 사용하면 자바에서 nullable을 처리할 때 발생하는 문제와 동일하게 발생함.
- 의미 없는 nullability 피하기 

#### 9. use를 사용하여 리소스를 닫아라

- use를 사용하면 Closeable/AutoCloseable을 구현한 객체를 쉽고 안전하게 처리할 수 있다.
- 파일을 처리할 떄는 파일을 한 줄씩 읽어 들이는 useLines를 사용하는 것이 좋다.

#### 10. 단위 테스트를 만들어라

- 가장 중요한 것은 애플리케이션이 진짜로 올바르게 동작하는지 확인하는 것이고 이게 테스트이다.
- 테스트 중에서 개발 과정에서 가장 효율적으로 활용할 수 있는 테스트가 단위 테스트이다.
- 비즈니스 애플리케이션 등에서는 최소한 몇 개라도 단위 테스트가 꼭 필요하다


# 2. 가독성 

#### 11. 가독성을 목표로 설계하라 

- 극단적이 되지 않기
  - let으로 인해서 에상하지 못한 결과가 나올 수 있다고 했는데, 이것을 left은 절대로 쓰면 안된다로 이해 하면 안됨
  - let을 사용하는 것은 좋으나 자칫 과도하게 사용하면 디버그 하기 어렵고, 경험이 적은 코틀린 개발자는 이해하기 어려워서 비용이 발생할 수 있다.
  - 어떤 것이 비용을 지불할 만한 코드인지 아닌지는 항상 논란이 있을 수 있지만, 균현을 잘 맞추는게 중요하다.

#### 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라

- 연산자 오버로딩은 그 이름의 의미에 맞게 사용해야 한다.
- 연산자 의미가 명확하지 않다면, 연산자 오버로딩을 사용하는 것보다는 이름이 있는 일반 함수를 사용하자.
- 꼭 연산자 같은 형태로 사용하고 싶다면, infix 확장 함수 또는 톱레벨 함수를 활용하자.

#### 13. Unit? 을 리턴하지 말라 

- Unit?은 Unit 또는 null이라는 값을 가질 수 있으므로 Boolean 과 Unit? 타입은 서로 바꿔서 사용할 수 있다.
- Unit?으로 불을 표현하는 것은 오해의 소지가 있으며, 예측하기 어려운 오류를 만들 수 있다.
- 따라서 Boolean을 사용하는 형태로 변경하는 것이 좋다. 


#### 14. 변수 타입이 명확하지 않은 경우 확실하게 지정하라

- 코틀린은 타입을 지정하지 않아도, 타입을 지정해서 넣어주는 수준 높은 타입 추론 시스템이 있다.
- 이는 코드가 짧아지므로 코드의 가독성이 크게 향상되지만 유형이 명확하지 않을 때는 남용하면 좋지 않다.
- 코드 정의로 쉽게 이동할 수 없는 깃허브 등의 환경에서 코드를 읽기 어려울 수 있다.
- 그렇다고 타입을 무조건 지정하라는 것이 아니므로 상황에 맞게 사용하자.


#### 15. 리시버를 명시적으로 참조하라
- 짧게 적을 수 있다는 이유만으로 리시버를 제거 하지 말자.
- 여러 개의 리시버가 있는 상황 등에는 리시버를 명시적으로 적어 주는 것이 좋다.
  - 어떤 리시버의 함수인지를 명확하게 알 수 있어서, 가독성이 향상됨 
- DSL에서 외부 스코프에 있는 리시버를 명시적으로 적게 강제하고 싶다면, DslMarker 메타 어노테이션을 사용한다.


#### 16. 프로퍼티는 동작이 아니라 상태를 나타내야 한다 
- 코틀린의 프로퍼티는 자바의 필드와 비슷해 보이지만 사실 서로 완전히 다른 개념이다.
- 둘 다 데이터를 저장한다는 점은 같지만 프로퍼티에는 더 많은 기능이 있다.
  - 코틀린의 프로퍼티는 디폴트로 캡슐화되어 있다.
  - 프로퍼티를 함수 대신 사용할 수도 있다. 하지만 완전히 대체해서 사용은 하지 말자
  - 상태를 추출/설정할 때는 프로퍼티를 사용해야 한다.

#### 17. 이름 있는 아규먼트를 사용하라
- 이름 있는 아규먼트는 디폴트 값들을 생략할 때만 유용한 것이 아니다.
- 이름 있는 아규먼트는 개발자가 코드를 읽을 때도 편리하게 활용되고, 코드의 안정성도 향상시킬 수 있다.
- 이 때는 이름 있는 아규먼트를 사용하는 것이 좋다.
  - 함수에 같은 타입의 파라미터가 여러개 있는 경우
  - 함수 타입의 파라미터가 있는 경우
  - 옵션 파라미터가 있는 경우
- 마지막 파라미터가 DSL처럼 특별한 의미를 갖고 있는 경우에는 사용 안하는 것이 좋다.

#### 18. 코딩 컨벤션을 지켜라
- 코틀린은 굉장히 잘 정리된 코딩 컨벤션을 갖고 있다.
- 가능하면 컨벤션을 최대한 지켜주는 지켜 주는 것이 좋다.
- 지켜주면
  - 어떤 프로젝트를 접해도 이해할 수 있다.
  - 다른 외부 개발자도 프로젝트의 코드를 쉽게 이해할 수 있음
  - 코드를 병합하고, 한 프로젝트의 코드 일부를 다른 코드로 이동하는 것이 쉽다.
- ktlint, intellij formatter 두 도구를 활용하면 컨벤션을 지킬 때 도움이 된다.
- 프로젝트의 모든 코드는 여러 사람이 싸우는 느낌으로 작성되면 안 되며, 마치 한 사람이 작성한 것처럼 작성되어야 한다.
- 정적 검사기를 활용해서 프로젝트의 코딩 컨벤션 일관성을 유지하자.


# 3. 재사용성

- 코틀린의 System.out.print 같은 함수를 직접 구현하려면, JNI를 통해 C를 사용해, 운영체제와 통신하는 부분까지 만들어야 한다. 따로 직접 해보지 않아도, 어렵다는 것을 알 수 있다.
- 뿐만아니라 다른 함수들도 마찬가지고, 프로젝트를 진행할 떄 마다 다시 해야 한다면 끔직한 일이 아닐 수 없다.
- 누군가 정렬 알고리즘 관련 함수 등을 한번 만들어 놓고, 필요할 때 이를 활용하는 것을 재사용성이라고 한다.
- 재사용성은 프로그래밍 언어의 핵심 특징이다.
- 하지만 재사용성에도 위험한 점이 있다.
  - print 함수를 약간만 변경해도, 프로그램에 수많은 문제가 발생할 수 있다.
  - A와 B에서 공통 부분을 추출한다면, 이후에 공통 부분을 수정할 일이 있을 때 한꺼번에 수정할 수 있다.
  - 하지만 실제로 해 보면, A를 대상으로 수정한 것이 B에서 문제될 수 있고, B를 대상으로 수정한 것이 A에서 문제가 될 수도 있다.
  - 그래서 재사용성을 고려하는 일은 생각보다 어렵고, 다양한 오류를 발생시킬 수 있다.
- 재사용성은 어떠한 답이 있는 것이 아니라, 지금까지 수많은 개발자가 개발하는 과정에서 만들어진 방법들이다.
  - 예로 무언가르 추출했는데 문제가 발생한다 혹은 추출하지 않았을 때 어떠한 문제가 발생한다 처럼 과거의 코드가 현재에 어떠한 영향을 미치는지 등을 확인하면서 정립된 것들이다.
  - 하지만, 이는 수년간의 연습이 필요하다.
- 이번 장에서는 연습 속도를 빠르게 하고 지식을 체계화하기 위해, 장기적으로 코드를 개선하는 데 도움이 되는 여러 가지 방법을 소개한다.

#### 19. knowledge를 반복하여 사용하지 말라
- 공통 knowledge가 있다면, 이를 추출해서 변화에 대비해야 한다.
- 여러 요소에 비슷한 부분이 있는 경우, 변경이 필욯라 때 실수할 수 있으니 추출하는 것이 좋다.
- 의도하지 않은 수정을 피하거나 다른곳에서 조작하는 부분이 있다면 분리해서 사용하자.
- 비슷해 보이는 코드를 모두 추출하는 것은 좋지 않다. 극단적인 것은 좋지 않다.
- 어떤 것을 추출해야 할지 결정하기 어려울 수 있는데, 이것은 수많은 시간과 연습이 필요하다.

#### 20. 일반적인 알고리즘을 반복해서 구현하지 말라
- 알고리즘의 대부분은 stdlib에 이미 정의되어 있을 가능성이 높다.
- 특정 알고리즘을 반복해서 사용해야 하는 경우에만 프로젝트 내부에 직접 정의하자.
- 일반적으로 이런 알고리즘들은 확장 함수로 정의하는 것이 좋다.

#### 21. 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라 
- 프로퍼티 델리게이트는 프로퍼티와 관련된 다양한 조작을 할 수 있으며, 컨텍스트와 관련된 대부분의 정보를 갖는다.
- 이러한 특징으로 인해서 다양한 프로퍼티의 동작을 추출해서 재사용할 수 있다.
  - lazy와 observable이 대표적인 예 
- 프토퍼티 위임은 프토퍼티 패턴을 추출하는 일반적인 방법이라 많이 사용되므로, 코틀린 개발자라면 프로퍼티 위임은 잘 알아야 한다.
 
#### 22. 일반적인 알고리즘을 구현할 때 제네릭을 사용하라
- 타입 파라미터를 사용해서 type-safe 제네릭 알고리즘과 제네릭 객체를 구현 할 수 있다.
- 타입 파라미터는 구체 자료형의 서브타입을 제한할 수 있고, 이렇게하면 특정 자료형이 제공하는 메서드를 안전하게 사용할 수 있다.

#### 23. 타입 파라미터의 섀도잉을 피하라 
- 프로퍼티와 파라미터가 같은 이름을 가지는 것을 섀도잉이라고 부른다. 
- 타입 파라미터 섀도잉이 발생한 코드는 이해하기 어려울 수 있으니 피하자.

#### 24. 제네릭 타입과 variance 한정자를 활용하라
- 코틀린은 타입 아규먼트의 관계에 제약을 걸 수 있는 굉장히 강력한 제네릭 기능을 제공한다.
- 코틀린에는 다음과 같은 타입 한정자가 있다.
  - 타입 파라미터의 기본적인 variance의 동작은 invariant이다. 만약 Cup<T> 라고 하면, 타입 파라미터 T는 invariant이다. A가 B의 서브타입이라고 할 때, Cup<A>와 Cup<B>는 아무런 관계를 갖지 않는다.
  - out 한정자는 타입 파라미터를 covariant하게 만든다. 만약 Cup<out T>라고 하면, 타입 파라미터 T는 covariant이다. A가 B의 서브타입이라고 할 때, Cup<A>는 Cup<B>의 서브타입이 된다. 
  - in 한정자는 타입파라미터를 contravariant하게 만든다. 만약 Cup<in T>라고 하면, 타입 파라미터 T는 contravariant이다. A가 B의 서브타입이라고 할 때, Cup<B>는 Cup<A>의 슈퍼타입이 된다. 

#### 25. 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라

- 풀스택 개발
  - 코틀린이 js로 컴파일될 수 있다.
  - 그래서 코틀린으로 리액트 프레임워크를 사용해서 웹 FE를 만들 수 있다.
- 모바일 개발 
  - 안드로이드는 당연히 코틀린으로 개발할 수 있다.
  - iOS도 LLVM을 사용하여 네이티브 코드로 컴파일할 수 있는 코틀린/네이티브를 사용하면, Objective-C 프레임워크로 변환할 수 있다.
  - 이렇게 변환하면 XCode 또는 AppCode에서 스위프트로 활용할 수 있다.
  - 참고로 코틀린/네이티브를 사용해 전체 애플리케이션을 만들어버리는 방법도 있다.
- 라이브러리
  - 공통 모듈을 정의할 수 있따는 것은 라이브러리에 있어서 강력한 도구이다.
- 함께 사용하기 
  - 코틀린을 사용하면 널리 사용되는 대부분의 장치와 플랫폼을 대상으로 개발할 수 있으며, 원하는 코드들을 재사용할 수 있다. 