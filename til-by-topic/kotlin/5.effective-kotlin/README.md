


# 1. 좋은 코드 


#### 1. 가변성을 제한하라 
- var 보다는 val을 사용
- mutable 프로퍼티, 객체, 클래스 보다는 immutable 프로퍼티, 객체, 클래스 사용
- 변경이 필요한 대상을 만들어야 하면, immutable + copy 활용 
- 컬렉션에 상태를 저장해야 하면, mutable 컬렉션보다는 읽기 전용 컬렉션을 사용
- 불필요한 변이 지점은 만들지 않는것이 좋다.
- mutable 객체는 외부에 노출하지 않는것이 좋다

#### 2. 변수의 스코프를 최소화하라
- 변수의 스코프는 좁게 만들어서 활용하는 것이 좋다.
- var 보다는 val 사용 

#### 3. 최대한 플랫폼 타입을 사용하지 말라
- nullable 여부를 알 수 없는 타입을 플랫폼 타입이라고 부른다.
- 플랫폼 타입을 사용하는 코드는 해당 부분만 위험할 뿐만 아니라, 이를 활용하는 곳까지 영향을 줄 수 있는 위험한 코드이다.
- 연결되어 있는 자바 생성자, 메서드, 필드에 nullable 여부를 지정하는 어노테이션을 활용하는 것도 좋다.

#### 4. inferred 타입으로 리턴하지 말라
- 타입을 확실하게 지정해야 하는 경우에는 명시적으로 타입을 지정해야 한다는 원칙만 갖고 있으면 된다.
- 안전을 위해서 외부 API를 만들 때는 반드시 타입을 지정하는것이 좋다.
- inferred 타입은 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수 있다.

#### 5. 예외를 활용해 코드에 제한을 걸어라
- require 블록
- check 블록
- assert 블록
- return throw와 함께 Elvis 연산자 사용 
위의 메커니즘을 통해서 얻을 수 있는 이득은 다음과 같다.
- 제한을 더 쉽게 확인
- 애플리케이션을 더 안정적으로 운영
- 코드를 잘못 쓰는 상황을 막을 수 있다. 
- 스마트 캐스팅을 활용할 수 있다. 

#### 6. 사용자 정의 오류보다는 표준 오류를 사용하라 

#### 7. 결과 부족이 발생할 경우 null과 Failure를 사용하라 

#### 8. 적절하게 null을 처리하라

- null을 안전하게 처리하기
  - 안전 호출, 스마트 캐스팅으로 안전하게 처리 
- 오류 throw하기
- not-null assertion(!!)과 관련된 문제
  - !!를 사용하면 자바에서 nullable을 처리할 때 발생하는 문제와 동일하게 발생함.
- 의미 없는 nullability 피하기 

#### 9. use를 사용하여 리소스를 닫아라

- use를 사용하면 Closeable/AutoCloseable을 구현한 객체를 쉽고 안전하게 처리할 수 있다.
- 파일을 처리할 떄는 파일을 한 줄씩 읽어 들이는 useLines를 사용하는 것이 좋다.

#### 10. 단위 테스트를 만들어라

- 가장 중요한 것은 애플리케이션이 진짜로 올바르게 동작하는지 확인하는 것이고 이게 테스트이다.
- 테스트 중에서 개발 과정에서 가장 효율적으로 활용할 수 있는 테스트가 단위 테스트이다.
- 비즈니스 애플리케이션 등에서는 최소한 몇 개라도 단위 테스트가 꼭 필요하다


# 2. 가독성 

#### 11. 가독성을 목표로 설계하라 

- 극단적이 되지 않기
  - let으로 인해서 에상하지 못한 결과가 나올 수 있다고 했는데, 이것을 left은 절대로 쓰면 안된다로 이해 하면 안됨
  - let을 사용하는 것은 좋으나 자칫 과도하게 사용하면 디버그 하기 어렵고, 경험이 적은 코틀린 개발자는 이해하기 어려워서 비용이 발생할 수 있다.
  - 어떤 것이 비용을 지불할 만한 코드인지 아닌지는 항상 논란이 있을 수 있지만, 균현을 잘 맞추는게 중요하다.

#### 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라

- 연산자 오버로딩은 그 이름의 의미에 맞게 사용해야 한다.
- 연산자 의미가 명확하지 않다면, 연산자 오버로딩을 사용하는 것보다는 이름이 있는 일반 함수를 사용하자.
- 꼭 연산자 같은 형태로 사용하고 싶다면, infix 확장 함수 또는 톱레벨 함수를 활용하자.

#### 13. Unit? 을 리턴하지 말라 

- Unit?은 Unit 또는 null이라는 값을 가질 수 있으므로 Boolean 과 Unit? 타입은 서로 바꿔서 사용할 수 있다.
- Unit?으로 불을 표현하는 것은 오해의 소지가 있으며, 예측하기 어려운 오류를 만들 수 있다.
- 따라서 Boolean을 사용하는 형태로 변경하는 것이 좋다. 


#### 14. 변수 타입이 명확하지 않은 경우 확실하게 지정하라

- 코틀린은 타입을 지정하지 않아도, 타입을 지정해서 넣어주는 수준 높은 타입 추론 시스템이 있다.
- 이는 코드가 짧아지므로 코드의 가독성이 크게 향상되지만 유형이 명확하지 않을 때는 남용하면 좋지 않다.
- 코드 정의로 쉽게 이동할 수 없는 깃허브 등의 환경에서 코드를 읽기 어려울 수 있다.
- 그렇다고 타입을 무조건 지정하라는 것이 아니므로 상황에 맞게 사용하자.


#### 15. 리시버를 명시적으로 참조하라
- 짧게 적을 수 있다는 이유만으로 리시버를 제거 하지 말자.
- 여러 개의 리시버가 있는 상황 등에는 리시버를 명시적으로 적어 주는 것이 좋다.
  - 어떤 리시버의 함수인지를 명확하게 알 수 있어서, 가독성이 향상됨 
- DSL에서 외부 스코프에 있는 리시버를 명시적으로 적게 강제하고 싶다면, DslMarker 메타 어노테이션을 사용한다.


#### 16. 프로퍼티는 동작이 아니라 상태를 나타내야 한다 
- 코틀린의 프로퍼티는 자바의 필드와 비슷해 보이지만 사실 서로 완전히 다른 개념이다.
- 둘 다 데이터를 저장한다는 점은 같지만 프로퍼티에는 더 많은 기능이 있다.
  - 코틀린의 프로퍼티는 디폴트로 캡슐화되어 있다.
  - 프로퍼티를 함수 대신 사용할 수도 있다. 하지만 완전히 대체해서 사용은 하지 말자
  - 상태를 추출/설정할 때는 프로퍼티를 사용해야 한다.

#### 17. 이름 있는 아규먼트를 사용하라
- 이름 있는 아규먼트는 디폴트 값들을 생략할 때만 유용한 것이 아니다.
- 이름 있는 아규먼트는 개발자가 코드를 읽을 때도 편리하게 활용되고, 코드의 안정성도 향상시킬 수 있다.
- 이 때는 이름 있는 아규먼트를 사용하는 것이 좋다.
  - 함수에 같은 타입의 파라미터가 여러개 있는 경우
  - 함수 타입의 파라미터가 있는 경우
  - 옵션 파라미터가 있는 경우
- 마지막 파라미터가 DSL처럼 특별한 의미를 갖고 있는 경우에는 사용 안하는 것이 좋다.

#### 18. 코딩 컨벤션을 지켜라
- 코틀린은 굉장히 잘 정리된 코딩 컨벤션을 갖고 있다.
- 가능하면 컨벤션을 최대한 지켜주는 지켜 주는 것이 좋다.
- 지켜주면
  - 어떤 프로젝트를 접해도 이해할 수 있다.
  - 다른 외부 개발자도 프로젝트의 코드를 쉽게 이해할 수 있음
  - 코드를 병합하고, 한 프로젝트의 코드 일부를 다른 코드로 이동하는 것이 쉽다.
- ktlint, intellij formatter 두 도구를 활용하면 컨벤션을 지킬 때 도움이 된다.
- 프로젝트의 모든 코드는 여러 사람이 싸우는 느낌으로 작성되면 안 되며, 마치 한 사람이 작성한 것처럼 작성되어야 한다.
- 정적 검사기를 활용해서 프로젝트의 코딩 컨벤션 일관성을 유지하자.


# 3. 재사용성

- 코틀린의 System.out.print 같은 함수를 직접 구현하려면, JNI를 통해 C를 사용해, 운영체제와 통신하는 부분까지 만들어야 한다. 따로 직접 해보지 않아도, 어렵다는 것을 알 수 있다.
- 뿐만아니라 다른 함수들도 마찬가지고, 프로젝트를 진행할 떄 마다 다시 해야 한다면 끔직한 일이 아닐 수 없다.
- 누군가 정렬 알고리즘 관련 함수 등을 한번 만들어 놓고, 필요할 때 이를 활용하는 것을 재사용성이라고 한다.
- 재사용성은 프로그래밍 언어의 핵심 특징이다.
- 하지만 재사용성에도 위험한 점이 있다.
  - print 함수를 약간만 변경해도, 프로그램에 수많은 문제가 발생할 수 있다.
  - A와 B에서 공통 부분을 추출한다면, 이후에 공통 부분을 수정할 일이 있을 때 한꺼번에 수정할 수 있다.
  - 하지만 실제로 해 보면, A를 대상으로 수정한 것이 B에서 문제될 수 있고, B를 대상으로 수정한 것이 A에서 문제가 될 수도 있다.
  - 그래서 재사용성을 고려하는 일은 생각보다 어렵고, 다양한 오류를 발생시킬 수 있다.
- 재사용성은 어떠한 답이 있는 것이 아니라, 지금까지 수많은 개발자가 개발하는 과정에서 만들어진 방법들이다.
  - 예로 무언가르 추출했는데 문제가 발생한다 혹은 추출하지 않았을 때 어떠한 문제가 발생한다 처럼 과거의 코드가 현재에 어떠한 영향을 미치는지 등을 확인하면서 정립된 것들이다.
  - 하지만, 이는 수년간의 연습이 필요하다.
- 이번 장에서는 연습 속도를 빠르게 하고 지식을 체계화하기 위해, 장기적으로 코드를 개선하는 데 도움이 되는 여러 가지 방법을 소개한다.

#### 19. knowledge를 반복하여 사용하지 말라
- 공통 knowledge가 있다면, 이를 추출해서 변화에 대비해야 한다.
- 여러 요소에 비슷한 부분이 있는 경우, 변경이 필욯라 때 실수할 수 있으니 추출하는 것이 좋다.
- 의도하지 않은 수정을 피하거나 다른곳에서 조작하는 부분이 있다면 분리해서 사용하자.
- 비슷해 보이는 코드를 모두 추출하는 것은 좋지 않다. 극단적인 것은 좋지 않다.
- 어떤 것을 추출해야 할지 결정하기 어려울 수 있는데, 이것은 수많은 시간과 연습이 필요하다.

#### 20. 일반적인 알고리즘을 반복해서 구현하지 말라
- 알고리즘의 대부분은 stdlib에 이미 정의되어 있을 가능성이 높다.
- 특정 알고리즘을 반복해서 사용해야 하는 경우에만 프로젝트 내부에 직접 정의하자.
- 일반적으로 이런 알고리즘들은 확장 함수로 정의하는 것이 좋다.

#### 21. 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라 
- 프로퍼티 델리게이트는 프로퍼티와 관련된 다양한 조작을 할 수 있으며, 컨텍스트와 관련된 대부분의 정보를 갖는다.
- 이러한 특징으로 인해서 다양한 프로퍼티의 동작을 추출해서 재사용할 수 있다.
  - lazy와 observable이 대표적인 예 
- 프토퍼티 위임은 프토퍼티 패턴을 추출하는 일반적인 방법이라 많이 사용되므로, 코틀린 개발자라면 프로퍼티 위임은 잘 알아야 한다.
 
#### 22. 일반적인 알고리즘을 구현할 때 제네릭을 사용하라
- 타입 파라미터를 사용해서 type-safe 제네릭 알고리즘과 제네릭 객체를 구현 할 수 있다.
- 타입 파라미터는 구체 자료형의 서브타입을 제한할 수 있고, 이렇게하면 특정 자료형이 제공하는 메서드를 안전하게 사용할 수 있다.

#### 23. 타입 파라미터의 섀도잉을 피하라 
- 프로퍼티와 파라미터가 같은 이름을 가지는 것을 섀도잉이라고 부른다. 
- 타입 파라미터 섀도잉이 발생한 코드는 이해하기 어려울 수 있으니 피하자.

#### 24. 제네릭 타입과 variance 한정자를 활용하라
- 코틀린은 타입 아규먼트의 관계에 제약을 걸 수 있는 굉장히 강력한 제네릭 기능을 제공한다.
- 코틀린에는 다음과 같은 타입 한정자가 있다.
  - 타입 파라미터의 기본적인 variance의 동작은 invariant이다. 만약 Cup<T> 라고 하면, 타입 파라미터 T는 invariant이다. A가 B의 서브타입이라고 할 때, Cup<A>와 Cup<B>는 아무런 관계를 갖지 않는다.
  - out 한정자는 타입 파라미터를 covariant하게 만든다. 만약 Cup<out T>라고 하면, 타입 파라미터 T는 covariant이다. A가 B의 서브타입이라고 할 때, Cup<A>는 Cup<B>의 서브타입이 된다. 
  - in 한정자는 타입파라미터를 contravariant하게 만든다. 만약 Cup<in T>라고 하면, 타입 파라미터 T는 contravariant이다. A가 B의 서브타입이라고 할 때, Cup<B>는 Cup<A>의 슈퍼타입이 된다. 

#### 25. 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라

- 풀스택 개발
  - 코틀린이 js로 컴파일될 수 있다.
  - 그래서 코틀린으로 리액트 프레임워크를 사용해서 웹 FE를 만들 수 있다.
- 모바일 개발 
  - 안드로이드는 당연히 코틀린으로 개발할 수 있다.
  - iOS도 LLVM을 사용하여 네이티브 코드로 컴파일할 수 있는 코틀린/네이티브를 사용하면, Objective-C 프레임워크로 변환할 수 있다.
  - 이렇게 변환하면 XCode 또는 AppCode에서 스위프트로 활용할 수 있다.
  - 참고로 코틀린/네이티브를 사용해 전체 애플리케이션을 만들어버리는 방법도 있다.
- 라이브러리
  - 공통 모듈을 정의할 수 있따는 것은 라이브러리에 있어서 강력한 도구이다.
- 함께 사용하기 
  - 코틀린을 사용하면 널리 사용되는 대부분의 장치와 플랫폼을 대상으로 개발할 수 있으며, 원하는 코드들을 재사용할 수 있다. 

# 4. 추상화 설계

#### 26. 함수 내부의 추상화 레벨을 통일하라 

- 별도의 추상화 계층을 만드는 것은 프로그래밍에서 일반적으로 사용되는 개념이다.
- 이는 knowledge를 체계화하고, 서브시스템의 세부 사항을 숨김으로써 상호 운영성과 플랫폼 독립성을 얻게 한다.
- 함수, 클래스, 모듈 등의 다양한 방식을 통해서 추상화를 분리한다.
- 이 때 각각의 레이어가 너무 커지는 것은 좋지 않다.
- 추상화 레벨은 구체적인 동작, 프로세서, 입출력과 가까울수록 낮은 레벨이라고 표현한다.
- 낮은 추상화 계층에서는 높은 계층에서 사용하는 요소(API)를 만든다.

#### 27. 변화로부터 코드를 보호하려면 추상화를 사용하라 

- 추상화는 단순하게 중복성을 제거해서 코드를 구성하기 위한 것이 아니다.
- 추상화는 코드를 변경해야 할 때도 도움이 된다. 
- 다만 추상적인 구조를 사용하면, 결과를 이해하기 어려울 수 있다.
- 추상화를 사용할 때의 장단점을 모두 이해하고 ,프로젝트 내에서 그 균형을 찾아야 한다.

#### 28. API 안전성을 확인하라 

- API는 일반적으로 시멘틱 버저닝을 사용하고, 각 부분은 0이상의 정수로 구성되며, 0부터 시작해서 API에 다음과 같은 변경 사항이 있을 때 1씩 증가시킨다. 
  - MAJOR 버전: 호환되지 않는 수준의 API 변경
  - MINOR 버전: 이전 변경과 호환되는 기능을 추가
  - PATCH 버전: 간단한 버그 수정 
- 널리 사용되는 API도 사용자의 변경 적응 시간을 몇년으로 잡기도 한다.
- 사용자는 API의 안정성에 대해 알아야 한다.
- 다만 안정적이라고 생각했던 API에 예상하지 못한 변경이 일어나면, 가장 나쁜 상황이다.
  - 이러한 변경을 수많은 사람들에게 고통을 줄 수 있으니
  - 모듈과 라이브러리를 만드는 사람과 이를 사용하느 사람들 사이에 커뮤니케이션은 중요하다.

#### 29. 외부 API를 랩(wrap)해서 사용하라 
- 불안정한 API를 사용해야 한다면, 최대한 이러한 API를 로직과 직접 결합시키지 않는 것이 좋다.
- 그래서 잠재적으로 불안정하다고 판단되는 외부 라이브러리 API를 랩(wrap)해서 사용하자.
- wrap해서 사용하면, 다음과 같은 자유와 안정성을 얻을 수 있다.
  - 문제가 있다면 wrapper만 변경하면 되므로, API 변경에 쉽게 대응 할 수 있다.
  - API를 프로젝트의 스타일에 맞출 수 있다. 
  - 특정 라이브러리에서 문제가 발생하면, 래퍼를 수정해서 다른 라이브러리를 사용하는것이 쉽다.
  - 필요한 경우 쉽게 동작을 추가하거나 수정할 수 있다.
- 단점도 있습니다.
  - 래퍼를 따로 정의
  - 다른 개발자가 프로젝트를 다룰 떄, 어떤 래퍼들이 있는지 따로 확인해야 함
  - 문제가 생기면 오버플로우에 질문하기 어렵다. 

#### 30. 요소의 가시성을 최소화하라 
- 가시성은 최대한 제한적인 것이 좋다.
- 인터페이스가 작을수록 이를 공부하고 유지하는 것이 쉽다 
- 최대한 제한이 되어 있어야 변경이 쉽다
- 클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임 질 수 없다
- 가시성이 제한되면 API의 변경을 쉽게 추적할 수 있다.

#### 31. 문서로 규약을 정의하라
- 요소, 특히 외부 API를 구현할 때는 규약을 잘 정의해야 함
- 이러한 규약은 이름, 문서, 주석, 타입을 통해 구현할 수 있음 
- 규약은 사용자가 객체를 사용하는 방법을 쉽게 이해하는 등 요소를 쉽게 예측할 수 있게 해줌
- 규약은 요소가 현재 어떻게 동작하고, 앞으로 어떻게 동작할지를 사용자에게 전달해준다.
- 이를 기반으로 사용자는 요소를 확실하게 사용할 수 있고, 규약에 없는 부분을 변경할 수 있는 자유를 얻는다.

#### 32. 추상화 규약을 지켜라 
- 프로그램을 안정적으로 유지하고 싶다면, 규약을 지키자.
- 규약을 깰 수 밖에 없다면, 이를 문서화 하자.
- 이러한 정보는 코드를 유지하고 관리하는 사람에게 큰 도움이 된다.

# 5. 객체 생성

#### 33. 생성자 대신 팩토리 함수를 사용하라 
- 코틀린은 팩토리 함수를 만들 수 있는 다양한 방법들을 제공한다.
- 객체를 생성할 때는 여러 특징을 잘 파악하고 사용해야 한다.
- 가짜 생성자, 톱레벨 팩토리 함수, 확장 팩토리 함수 등 일부는 신중하게 사용해야 함.
- 팩토리 함수를 정의하는 가장 일반적인 방법은 companion 객체를 사용하는 것이다.
  - 이 방법은 자바 정적 팩토리 메서드 패턴과 굉장히 유사하다.
  - 코틀린은 자바의 스타일과 관습을 대부분 상속하고 있으므로, 대부분의 개발자에게 안전하고 익숙하다.

#### 34. 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라 
- 일반적으로 기본 생성자를 사용해 객체를 만든다.
- 코틀린에서는 점층적 생성자 패턴을 사용하는 대신, 디폴트 아규먼트를 활용하는 것이 좋다.
- 빌더 패턴도 거의 사용하지 않는다.
  - 기본 생성자를 사용하는 코드로 바꾸거나, DSL을 활용하는 것이 좋다. 

#### 35. 복잡한 객체를 생성하기 위한 DSL을 정의하라
- DSL은 언어 내부에서 사용할 수 있는 특별한 언어이다.
- 복잡한 객체, HTML 코드, 복잡한 설정 등의 계층 구조를 갖는 객체를 간단하게 표현할 수 있게 해준다.
- 하지만 DSL 구현은 DSL이 익숙치 않은 개발자에겐 어려울 수 있다.
- 따라서 DSL은 복잡한 객체를 만들거나, 복잡한 게층 구조를 갖는 객체를 만들 떄만 활용하는 것이 좋다.
- 좋은 DSL을 만드는 작업은 굉장히 어렵다.


# 6. 클래스 설계

#### 36. 상속보다는 컴포지션을 사용하라
컴포지션 예시 
```kotlin
class Progress {
    fun showProgress() { /* 프로그레스 바 표시 */ }
    fun hideProgress() { /* 프로그레스 바 숨김 */ }
}

class ProfileLoader {
    val progress = Progress()
    
    fun load() {
        progress.showProgress()
        // 프로필 읽어들임
        progress.hideProgress()
    }
}

class ImageLoader {
    val progress = Progress()
    
    fun load() {
        progress.showProgress()
        // 이미지 읽어들임
        progress.hideProgress()
    }
}
```

**컴포지션 vs 상속**
- 컴포지션은 더 안전하다 
  - 다른 클래스의 내부적인 구현에 의존하지 않고, 외부에서 관찰되는 동작에만 의존
- 컴포지션은 더 유연하다 
  - 상속은 한 클래스만 대상, 컴포지션은 여러 클래스를 대상 
  - 상속은 모든 것을 받지만, 컴포지션은 필요한 것만 받음 
  - 슈퍼클래스의 동작을 변경하면, 서브클래스의 동작도 큰 영향을 받음
  - 하지만 컴포지션을 활용하면 영향이 제한적이다.
- 컴포지션은 더 명시적이다.
  - 이것은 장점이자 단점
  - 슈퍼클래스의 메서드를 사용할 때는 리시버를 따로 지정하지 않아도 돼서 덜 명시적이다. 
  - 즉, 코드가 짧아 질 수 있지만, 메서드가 어디에서 왔는지 혼동될 수 있으므로 위험할 수 있다.
  - 컴포지션을 활용하면, 리시버를 명시적으로 활용할 수 밖에 없으므로 메서드가 어디에 있는 것인지 확실하게 알 수 있다. 
- 컴포지션은 생각보다 번거롭다. (변경할 일이 많다)
  - 객체를 명시적으로 사용해야 하므로, 대상 클래스에 일부 기능을 추가할 때 이를 포함하는 객체의 코드를 변경해야 한다.
  - 그래서 상속보다 코드를 수정할 일이 더 많다.
- 상속은 다형성을 활용할 수 있다.
  - 이것은 양날의검.
  - 상속을 사용하면, 슈퍼클래스와 서브클래스의 규약을 항상 잘 지켜서 코드를 작성해야한다.

- 상속은 명확한 is-a 관계 일 때 사용하는 것이 좋다.
- 슈퍼클래스의 모든 단위 테스트는 서브클래스로도 통과할 수 있어야 한다.
- JavaFX의 Application, Android의 Activity, IOS의 UIViewController, 리액트의 React.Component, 뷰 위에 사용되는 뷰 요소들 등은 상속을 사용하는 것이 좋을 수 있다.
- 상속을 위해 설계되지 않은 메서드는 final로 만들어 두는 것이 좋다.

#### 37. 데이터 집합 표현에 data 한정자를 사용하라 
- data 한정자를 붙이면 다음과 같은 몇 가지 함수가 자동으로 생성된다.
  - toString
  - equals & hashCode
  - copy
  - componentN(compoentn1 등)
- 튜플 대신 데이터 클래스 사용하기
  - 코틀린에 남아 있는 마지막 튜플은 Pair, Triple
  - 튜플은 데이터 클래스와 같은 역할을 하지만, 훨씬 가독성이 나쁘다.
  - 튜플만 보고는 어떤 타입을 나타내는지 예측할 수 없다.
  - 값에 간단하게 이름을 붙일 때, 표준 라이브러리에서 볼 수 있는 것 처럼 미리 알 수 없는 aggregation(집합)을 표현할 때를 제외하면 무조건 데이터 클래스를 사용하는 것이 좋다.
  - 튜플 대신 데이터 클래스를 사용하면 다음과 같이 함수를 더 명확하게 해준다
    - 함수의 리턴 타입이 더 명확해짐
    - 리턴 타입이 더 짧아지며, 전달하기 쉬워짐
    - 사용자가 데이터 클래스에 적혀 있는 것과 다른 이름을 활용해 변수를 해제하면, 경고가 출력됨
- 코틀린에서 클래스는 큰 비용없이 사용할 수 있는 좋은 도구이니, 적극적으로 활용하자.

#### 38. 연산 또는 액션을 전달할 떄는 인터페이스 대신 함수 타입을 사용하라 
- 대부분의 프로그래밍 언어에는 함수 타입이라는 개념이 없다.
- 그래서 연산 또는 액션을 전달할 때 메서드가 하나만 있는 인터페이스를 활용한다.
- 이러한 인터페이스를 SAM이라고 함.

**SAM**
```kotlin
fun setOnClickListener(listener: OnClick) {
  // ...
}

setOnClickListener(object: OnClick {
  override fun clicked(view: View) {
    // ...
  }
})
```

**함수 타입**
```kotlin
fun setOnClickListener(listener: (View) -> Unit) {

}
```

- 함수 타입을 사용하는 코드로 변경하면, 더 많은 자유를 얻을 수 있다.

- 람다 표현식 또는 익명 함수로 전달
```kotlin
setOnClickListener { }
setOnClickListener(fun(view) {})
```

- 함수 레퍼런스 또는 제한된 함수 레퍼런스로 전달
```kotlin
setOnClickListener(::println)
setClickListener(this::showUsers)
```

- 선언된 함수 타입을 구현한 객체로 전달
```kotlin
class ClickListener: (View) ->Unit {
  override fun invoke(view: View) {

  }
}

setOnClickListener(ClickListener())
```  

- SAM의 장점은 '그 아규먼트에 이름이 붙어있는 것'이라고도 하는데, 타입별칭을 사용하면 함수타입도 이름을 가질 수 있음 
```kotlin
typealias OnClick = (View) -> Unit
```

- 파라미터도 이름을 가질 수 있음 -> 이름을 붙이면, IDE의 지원을 받을 수 있는 큰 장점이 있음 
```kotlin
fun setOnClickListener(listener: OnClick) {}
typealias OnClick = (view: View)->Unit
```

- 람다 표현식을 사용할 때는 아규먼트 분해도 사용할 수 있음 -> 이것도 SAM 보다 훨씬 더 좋은점임
- 인터페이스를 사용해야 하는 특별한 이유가 없다면, 함수 타입을 활용하는게 좋다.

**SAM을 언제 사용해야 할까?**
- 코틀린이 아닌 다른 언어에서 상요할 클래스를 설계할 때이다. ex) 자바 


#### 39. 태그 클래스보다는 클래스 계층을 사용하라 

```kotlin
class ValueMatcher<T> private constructor(
  private val value: T? = null,
  private val matcher: Matcher
) {
  
  fun match(value: T?) = when(matcher) {
    Matcher.EQUAL -> value == this.value
    Matcher.NOT_EQUAL -> value != this.value
    Matcher.LIST_EMPTY -> value is List<*> && value.isEmpty()
    Matcher.LIST_NOT_EMPTY -> value is List<*> && value.isNotEmpty()
  }

  enum class Matcher(
    Equal,
    NOT_EQUAL,
    LIST_EMPTY,
    LIST_NOT_EMPTY
  )

  companion object {
    fun equal..
    fun notEqual..
    ...
  }
}
```
- 위 코드가 태그 클래스의 예시이다.
- 이러한 태그 클래스는 다양한 문제를 내포하고 있다. 
- 서로 다른 책임을 한 클래스에 태그로 구분해서 넣는다는 것에서 문제가 시작된다.
- 이러한 접근 방법에는 굉장히 많은 단점이 있다.
  - 한 클래스에 여러 모드를 처리하기 위한 상용구가 추가됨
  - 여러 목적으로 사용해야 하므로 프로퍼티가 일관적이지 않게 사용될 수 있으며, 더 많은 프로퍼티가 필요하다. 예를 들어 위의 예제에서 value는 모드가 LIST_EMPTY 또는 LIST_NOT_EMPTY일 때 아예 사용되지도 않는다.
  - 요소가 여러 목적을 가지고, 요소를 여러 방법으로 설정할 수 있는 경우에는 상태의 일관성과 정확성을 지키기 어렵다.
  - 팩토리 메서드를 사용해야 하는 경우가 많다. 그렇지 않으면 객체가 제대로 생성되었는지 확인하는 것 자체가 굉장히 어렵다.
- 코틀린은 그래서 일반적으로 태그클래스보다 sealed 클래스를 많이 사용한다.
- 한 클래스에 여러 모드를 만드는 방법 대신에, 각각의 모드를 여러 클래스로 만들고 타입 시스템과 다형성을 활용하는 것이다.
```kotlin
sealed class ValueMatcher<T> {
  ...
  class Equal...

  class NotEqual...
  ...
}
```
- 이렇게 구현하면 책임이 분산되므로 훨씬 깔끔하다.
  - 각각의 객체들은 자신에게 필요한 데이터만 있으며, 적절한 파라미터만 갖는다.


**sealed 한정자**
- sealed class대신 abstract 한정자를 사용할수도 있지만, sealed 한정자는 외부 파일에서 서브 클래스를 만드는 행위 자체를 모두 제한하므로 타입이 추가되지 않을 거라는게 보장된다.
- when을 사용할 때 else 브랜치를 따로 만들 필요도 없다.
- 각각의 서브클래스에 구현할 필요 없이, when을 활용하는 확장 함수로 정의하면 한번에 구현할수도 있다. 
- 예시로 reversed 확장함수를 봐보자.
```kotlin
fun <T> ValueMatcher<T>.reversed(): ValueMatcher<T> = 
when (this) {
  is ValueMatcher.EmptyList -> ValueMatcher.NotEmptyList<T>()
  ...
}
```
- sealed 한정자를 사용하면, 확장 함수를 사용해서 클래스에 새로운 함수를 추가하거나, 클래스의 다양한 변경을 쉽게 처리할 수 있다.
- abstract는 상속과 관련된 설계를 할 때 사용합니다.

**태그 클래스와 상태 패턴의 차이**
- 상태 패턴은 객체의 내부 상태가 변화할 때, 객체의 동작이 변하는 소프트웨어 디자인 패턴이다.
- 타입 계층과 상태 패턴은 실질적으로 함께 사용하는 협력 관계라고 할 수 있다.
- 하나의 뷰를 가지는 경우 보다는 여러 개의 상태로 구분할 수 있는 뷰를 가질 때 많이 활용된다.

#### 43. API의 필수적이지 않는 부분을 확장 함수로 추출하라.
- 클래스 멤버로 메서드 정의하는것이랑 확장함수로 메서드 정의하는 두 방법은 거의 비슷하다.
  - 호출하는 방법도 비슷하고, 리플렉션으로 레퍼런싱하는 방법도 비슷하다.
  - 두 방식 중에 어떤 방식이 우월하다는 것은 없다.
  - 각각 장단점을 모두 갖고 있으므로 상황에 맞게 사용해야 한다.
- 멤버와 확장의 가장 큰 차이점은 확장은 따로 가져와서 사용해야 하므로 일반적으로 확장은 다른 패키지에 위치한다.
  - 임포트해서 사용한다는 특징 덕분에 확장은 같은 타입에 같은 이름으로 여러 개 만들 수도 있다.
  - 따라서 여러 라이브러리에서 여러 메서드를 받을 수도 있고, 충돌이 발생하지도 않는다는 장점이 있다.
  - 하지만 같은 이름으로 달느 동작을 하는 확장이 있는게 위험할 수도 있다.
  - 위험 가능성이 있다면 그냥 멤버 함수로 만ㄷ르어서 사용하는 것이 좋다. -> 컴파일러가 항상 확장 대신 멤버함수를 호출한다.
- 또 다른 차이점은 확장은 가상이 아니라는 것이다.
  - 파생 클래스에서 오버라이드 할 수 없다.
- 마지막으로 중요한 차이점은 확장은 클래스 레퍼런스에서 멤버로 표시되지 않는다는 것이다.
  - 그래서 확장 함수는 어노테이션 프로세서가 따로 처리하지 않는다.
  - 따라서 필수저이지 않은 요소를 확장 함수로 추출하면, 어노테이션 프로세스로부터 숨겨진다.
  - 이는 확장 함수가 클래스 내부에 있는 것은 아니기 때문이다.

- 정리: 멤버와 확장 함수의 차이 
  - 화강 함수는 읽어 들여야 한다.
  - 확장 함수는 가상이 아니다.
  - 멤버는 높은 우선 순위를 갖는다
  - 확장 함수는 클래스 위가 아니라 타입 위에 만들어진다
  - 확장 함수는 클래스 래퍼런스에 나오지 않는다.
- 즉, 확장함수는 더 많은 자유와 유연성을 준다.
  - 확장 함수는 상속, 어노테이션 처리 등을 지원하지 않고, 클래스 내부에 없으므로 약간 혼동을 줄 수도 있다.
- API의 필수적인 부분은 멤버로 두는 것이 좋지만, 필수적이지 않은 부분은 확장 함수로 만드는 것이 여러모로 좋다.

#### 44. 멤버 확장 함수의 사용을 피하라.
- 어떤 클래스에 대한 확장 함수를 정의할 때, 이를 멤버로 추가하는 것은 좋지 않다.
- 확장 함수는 첫 번째 아규먼트로 리시버를 받는 단순한 일반 함수로 컴파일 된다. 

예를 들어 다음과 같은 함수는 
```kotlin
fun String.isPhoneNumber(): Boolean = length == 7 && all { it.isDigit() }
```

컴파일 되면, 다음과 같이 변한다.
```kotlin
fun isPhoneNumber('$this': String): Boolean = '$this'.length == 7 && '$this'.all {it.isDigit()}
```

- 위와 같이 단순하게 변환되는 것이므로, 확장 함수를 클래스 멤버로 정의할 수도 있고, 인터페이스 내부에 정의할 수도 있다.
- DSL을 제외하면 가시성 제한을 위해 확장 함수를 멤버로 정의하는 것은 굉장히 좋지 않다.
  - 한가지 큰 이유: 가시성 제한을 하지 못한다.
  - 단순하게 확장함수를 사용하는 형태를 어렵게 만들 뿐이다.
  - 쓰려면 이렇게 써야함 
    ```kotlin
    PhoneBookIncorrect().apply { "123456790".test() }
    ``` 
- 확장 함수의 가시성을 제한하고 싶다면, 멤버로 만들지 말고, 가시성 한정자를 붙이면 된다.
```kotlin
class PhoneBookCorrect {
  // ...
}

private fun String.isPhoneNumber() = length == 7 && all { it.isDigit() }
```

- 멤버 확장을 피해야 하는 몇 가지 타당한 이유를 정리해보면 
  - 레퍼런스를 지원하지 않음
  - 암묵적 접근 할 때, 두 리시버 중에 어떤 리시버가 선택될지 혼동된다.
    ```kotlin
    class A {
      val a = 10
    }
    
    class B {
      val a = 20
      val b = 30

      fun A.test() = a + b // 40 ? 50 ?
    }
    ```
  - 확장 함수가 외부에 있는 다른 클래스를 리시버로 받을 때, 해당 함수가 어떤 동작을 하는지 명확하지 않는다.