- [1. 아마존 비즈니스 민첩성의 비밀](#1-아마존-비즈니스-민첩성의-비밀)
  - [1.1. 성공한 인터넷 기업들과 비즈니스 민첩성](#11-성공한-인터넷-기업들과-비즈니스-민첩성)
    - [1.1.1 성공 사례: 아마존의 배포속도](#111-성공-사례-아마존의-배포속도)
    - [1.1.2 클라우드 인프라의 등장](#112-클라우드-인프라의-등장)
    - [1.1.3 클라우드 인프라에 어울리는 애플리케이션의 조건](#113-클라우드-인프라에-어울리는-애플리케이션의-조건)
      - [스케일 업과 스케일 아웃](#스케일-업과-스케일-아웃)
      - [특정 서비스만 탄력성 있게 확장 (스케일 아웃)](#특정-서비스만-탄력성-있게-확장-스케일-아웃)
      - [클라우드 프렌들리와 클라우드 네이티브](#클라우드-프렌들리와-클라우드-네이티브)
  - [1.2 마이크로서비스란 무엇인가?](#12-마이크로서비스란-무엇인가)
    - [1.2.1 모노리스와 마이크로서비스 비교](#121-모노리스와-마이크로서비스-비교)
    - [1.2.2 SOA와 마이크로서비스](#122-soa와-마이크로서비스)
  - [1.3 마이크로서비스를 위한 조건은 무엇인가?](#13-마이크로서비스를-위한-조건은-무엇인가)
- [2. MSA의 이해](#2-msa의-이해)
  - [2.1 리액티브 선언: 현대 애플리케이션이 갖춰야 할 바람직한 속성들](#21-리액티브-선언-현대-애플리케이션이-갖춰야-할-바람직한-속성들)
    - [소프트웨어 아키텍처](#소프트웨어-아키텍처)
    - [리액티브 선언문](#리액티브-선언문)
  - [2.2 강 결합에서 느슨한 결합의 아키텍처로의 변화](#22-강-결합에서-느슨한-결합의-아키텍처로의-변화)
    - [과거의 아키텍처](#과거의-아키텍처)
    - [최근의 아키텍처](#최근의-아키텍처)
  - [2.3 마이크로서비스의 외부 아키텍처와 내부 아키텍처](#23-마이크로서비스의-외부-아키텍처와-내부-아키텍처)
  - [2.4 MSA 구성요소 및 MSA 패턴](#24-msa-구성요소-및-msa-패턴)
    - [2.4.1 인프라 구성 요소](#241-인프라-구성-요소)
    - [2.4.2 마이크로서비스 운영과 관리를 위한 플랫폼 패턴](#242-마이크로서비스-운영과-관리를-위한-플랫폼-패턴)
    - [2.4.3 애플리케이션 패턴](#243-애플리케이션-패턴)
  - [2.5 정리](#25-정리)
- [3. 마이크로서비스 애플리케이션 아키텍처](#3-마이크로서비스-애플리케이션-아키텍처)
  - [3.3 마이크로서비스의 내부 구조 정의](#33-마이크로서비스의-내부-구조-정의)
    - [3.3.1 바람직한 마이크로서비스의 내부 아키텍처: 클린 마이크로서비스](#331-바람직한-마이크로서비스의-내부-아키텍처-클린-마이크로서비스)
    - [3.3.2 내부 영역 - 업무 규칙](#332-내부-영역---업무-규칙)
  - [3.4 정리](#34-정리)
- [4. 마이크로서비스와 애자일 개발 프로세스](#4-마이크로서비스와-애자일-개발-프로세스)
  - [4.1 도메인 주도 설계와 마이크로서비스](#41-도메인-주도-설계와-마이크로서비스)
  - [4.2 기민한 설계/개발 프로세스](#42-기민한-설계개발-프로세스)
    - [4.2.1 점진/반복적인 스크럼 생명주기](#421-점진반복적인-스크럼-생명주기)
    - [4.2.2 아키텍처 정의와 마이크로서비스 도출](#422-아키텍처-정의와-마이크로서비스-도출)
    - [4.2.3 스프린트 내 개발 공정](#423-스프린트-내-개발-공정)
  - [4.3 정리](#43-정리)
- [5. 마이로서비스 설계](#5-마이로서비스-설계)
  - [5.1 마이크로서비스를 도출하는 방법](#51-마이크로서비스를-도출하는-방법)

# 1. 아마존 비즈니스 민첩성의 비밀

## 1.1. 성공한 인터넷 기업들과 비즈니스 민첩성
- 아마존, 넷플릭스, 우버를 비롯해 성공한 유니콘 기업들의 공통점이 있다면 자신만의 특화된 서비스를 제공하려는 시도를 누구보다 빨리 실행했고 사용자 피드백을 반영해 끊임없이 서비스를 개선한다.
- `비즈니스 민첩성`은 이러한 기업들의 특출난 장점이자 기업 성공의 가장 큰 요인이다. 


### 1.1.1 성공 사례: 아마존의 배포속도 
- 2019년 아마존의 배포속도는 초당 1.5번
- 빠른 배포 주기는 비즈니스의 민첩성을 간접적으로 보여주는 지표라 할 수 있다.

### 1.1.2 클라우드 인프라의 등장

- 클라우드 인프라전에는 
  - `서버실 공사 -> 서버 장비 구입, 네트워크 연결 -> 운영체제 및 S/W 설치` 과정이 필요해서 많은 시간이 소요됐다.
  - 개발 환경을 구축한 뒤 서비스를 개발해 런칭했지만 서비스가 실패로 끝났다면 초기 투입된 인프라 비용을 건질 수 없다.
- 클라우드 인프라가 나온 뒤에는
  - 위에 문제들이 모두 해결됐다.
  - 시스템 인프라를 준비하는데 오랜 시간이 들지 않는다.

### 1.1.3 클라우드 인프라에 어울리는 애플리케이션의 조건
  
- 클라우드 인프라는 사용량에 따라 비용을 유연하게 조절 할 수 있다.
- 필요한 시점에 필요한 만큼만 애플리케이션을 변경해 배포하고 싶다면 클라우드 인프라를 닮으면 된다.
  - 레고처럼 조각 조각이 모여 하나의 큰 덩어리가 되고 쉽게 분리되야 한다.

#### 스케일 업과 스케일 아웃
- 사용량 증가에 따른 성능 및 가용성을 높이는 방법은 스케일 업과 스케일 아웃이 있다.
- 스케일 업: 시스템 자체의 물리적 용량을 증가시켜 성능을 높이는 방법
- 스케일 아웃: 기존 시스템과 용량이 같은 다수의 장비를 병행 추가해서 가용성을 높이는 방법

#### 특정 서비스만 탄력성 있게 확장 (스케일 아웃)
- 1주일 간의 세일 기간 중 정작 바쁜 업무는 세일 이벤트를 수행하는 부분이다. 나머지 부분은 사용자가 몰리지 않아 더 한가해질 수도 있다.
- 세일 이벤트를 담당하는 조각(서버)만 용량이 증설되고 사용량에 따라 복제되어 트래픽에 대비하면 된다.
- 쇼핑몰 세일을 준비하는 운영자의 운영 시나리오
  1. 타임세일 서비스의 용량만 고려해서 증설한다 (스케일 업)
  2. 트래픽이 증가하면 타임세일 서비스 인스턴스만 복제되도록 설정한다 (스케일 아웃)

#### 클라우드 프렌들리와 클라우드 네이티브
- 물론 작은 단위의 서비스 연계로 시스템을 구성하지 않고 전체 시스템을 하나의 덩어리로 만들어 클라우드 인프라에 올려도 비즈니스를 제공하는데 전혀 문제가 없다.
- 그렇지만 특정 기능만 확장하거나 배포할 수 없는 비효율을 감소해야 한다.
- 클라우드 친화 애플리케이션(Cloud Friendly Application): 큰 덩어리로 클라우드 환경에 올라갈 수 있게만 한 애플리케이션
- 클라우드 네이티브 애플리케이션(Cloud Native Application): 독립적으로 분리되어 배포될 수 있는 조각으로 구성된 애플리케이션 
- 아마존은 클라우드 네이티브 애플리케이션으로 구성되어 있다.


## 1.2 마이크로서비스란 무엇인가?

### 1.2.1 모노리스와 마이크로서비스 비교 
- 모노리스
  - 하나위 단위로 개발되는 일체식 애플리케이션
  - 아무리 작은 변화에도 새로운 버전으로 전체를 빌드해서 배포
  - 보통 로드 밸런서를 앞에 두고 여러 인스턴스 위에 큰 덩어리를 복제해 수평으로 확장 -> 작은 변경에도 전부 빌드하고 배포 
  - 확장 시에 애플리케이션은 병렬로 확장되지만, DB는 탄력적으로 대응할 수 없어서 사전에 성능을 감당하기 위해 스케일 업을 통해 용량을 증설해야 함 
- 마이크로서비스
  - 여러 서비스가 별개의 인스턴스로 로딩됨
  - 확장 시에 특정 기능별로 독립적으로 확장 할 수 있음 
  - 각 서비스가 독립적이어서 서로 다른 언어로 개발 가능
  - 각 서비스의 소유권을 분리해서 서로 다른 팀이 개발 및 운영 가능 

### 1.2.2 SOA와 마이크로서비스

- SOA: 컴포넌트를 모아 비즈니스적으로 의미 있고 완결적인 서비스 단위로 모듈화
- 넓게보면 여러 개의 응집된 비즈니스 서비스의 집합으로 시스템을 개발한다는 점에서 MSA와 개념적으로는 큰 차이 없음
- 그러나 SOA는 구체적이지 않고 이론적이며, 실제 비즈니스 성공 사례가 많지 않았음.
- 반면 MSA는 클라우드 인프라 기술의 발전과 접목되어 아마존, 넷플릭스에 의해 구체화되고 성공 사례가 널리 공유됨.
- 즉, 이상적이었지만 성공을 증명하지 못했던 SOA가 클라우드 인프라의 등장으로 하드웨어를 유연하게 다룰 수 있게 되면서 실현되어 성공적으로 증명된 시스템 구조가 MSA이다.
- 폴리그랏(Polyglot): 특정 서비스를 구축하는 데 사용되는 언어나 저장소를 자율적으로 선택할 수 있는 방식
- SOA에서는 애플리케이션은 모듈로 분리했으나 데이터 저장소까지는 분리하지 못했고, 데이터의 강한 결합으로 애플리케이션도 독립적으로 사용하기 힘들었음.


## 1.3 마이크로서비스를 위한 조건은 무엇인가?

- 마이크로서비스에서는 비즈니스 처리를 위해 일부 데이터의 복제와 중복 허용이 필요하다.
- 각 마이크로서비스의 저장소에 담긴 데이터의 비즈니스 정합성을 맞춰야 하는 데이터 일관성 문제이다.
- 데이터 일관성 처리를 위해서는 보통 2단계 커밋 같은 분산 트랜잭션 기법을 사용하는데, 다른 서비스를 하나의 트랜잭션으로 묶다 보면 각 서비스의 독립성도 침해되고 NOSQL 같은 저장소는 2단계 커밋을 지원하지 않는다.
- 따라서 마이크로서비스는 데이터 일관성 문제를 해결하기 위해 두 서비스를 단일 트랜잭션으로 묶는 방법이 아닌 비동기 이벤트 처리를 통한 협업을 강조한다.
- 이를 가리켜 결과적 일관성(Eventual Consistency)이라는 개념으로 표현하기도 한다.
- 간단히 말하면 두 서비스의 데이터가 일시적으로 불일치하는 시점에 있고 일관성이 없는 상태지만 결국에는 두 데이터가 같아진다는 개념이다.
- 별도의 로컬 트랜잭션을 각각 수행하고 일관성이 달라진 부분은 체크해서 보상 트랜잭션으로 일관성을 맞추는 개념이다.

**주문 배송 서비스 예시**
- 주문이 발생하면 배송 처리가 돼야 하는 비즈니스

1. 주문 서비스가 주문 처리 트랜잭션을 수행
   1. 동시에 주문 이벤트를 발행
   2. 주문 이벤트가 메시지 큐로 전송
   3. 배송 서비스가 주문 이벤트를 인식
2. 배송 서비스가 주문 처리에 맞는 배송 처리 트랜잭션을 수행 (비즈니스 일관성 만족)
3. 배송 처리 트랜잭션 중 오류로 트랜잭션을 실패
   1. 배송 처리 실패 이벤트를 발행
   2. 배송 처리 실패 이벤트가 메시지 큐로 전송
   3. 주문 서비스가 배송 처리 실패 이벤트를 인식 
4. 주문 서비스는 주문 취소(보상 트랜잭션)을 추생 (비즈니스 일관성 만족)

서킷브레이커: 각 서비스를 모니터링하고 있다가 한 서비스가 다운되거나 실패하면 이를 호출하는 서비스의 연계를 차단하고 적절하게 대응

# 2. MSA의 이해

- 모노리스에서 마이크로서비스 시스템으로 변화함에 따라 발생하는 문제점들을 해결하기 위해 등장했던 MSA 패턴들을 살펴보자.

## 2.1 리액티브 선언: 현대 애플리케이션이 갖춰야 할 바람직한 속성들

### 소프트웨어 아키텍처
- 소프트웨어를 구성하는 요소와 그 구성요소 간의 관게를 정의
- 아키텍처를 정의하는 과정: 비기능 요건(성능, 가용성, 보안, 유지보수성, 확장성 등)을 만족하는 다양한 해결 방법을 찾는 과정 

### 리액티브 선언문
- 리액티브 선언문: 사람들이 스마트폰, 데스크톱 애플리케이션 등 여러 기기에 포함된 애플리케이션이 요청에 즉각 응답하고 항상 가동되길 기대하는 것을 잘 표현한 문서
- 리액티브 시스템: 응답성, 탄력성, 유연성, 메시지 기반(Message Driven) 4가지 특성을 강조하고, 이러한 요건을 만족하는 시스템
  - 응답성: 사용자에게 신뢰성 있는 응답을 빠르고 적절하게 제공
  - 탄력성: 장애가 발생하거나 부분적으로 고장 나더라도 시스템 전체가 고장 나지 않고 빠르게 복구하는 능력
  - 유연성: 사용량에 변화가 있더라도 균일한 응답성을 제공, 사용량에 비례해서 자원을 늘리거나 줄이는 능력
  - 메시지 기반: 비동기 메시지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향
- 아키텍처 유연성
  - 리액티브 시스템이 반드시 갖춰야 할 공통적인 특성
  - 시스템을 구성하는 구성요소 간의 관계들이 느슨하게 맺어져 있어 언제든지 대체되거나 추가 확장될 수 있는 특성 
  - 위의 4가지 요소 중에서 '메시지 기반'이라는 요소가 아키텍처 유연성을 만족시키는 요소이다.
  - 메시지 기반 특성은 이후에 살펴볼 마이크로서비스 아키텍처에서도 마이크로서비스 간의 의존성을 줄이는 중요한 특성이 된다.

## 2.2 강 결합에서 느슨한 결합의 아키텍처로의 변화

### 과거의 아키텍처
- 아키텍처 구성요소들을 각 기업이나 특정 벤더의 제품에 전적으로 의존해서 구축하거나 수정이 필요한 부분만 별도로 직접 개발하는 경우가 많았다.
- 특정 벤더 솔루션이나 프레임워크가 변경될 경우 그것에 의존하는 애플리케이션의 많은 부분들을 변경해야 할 정도로 강 결합돼 있었다.
- 검증된 유명 제품군을 사용한다는 점에서 품질이 보장된다고 생각할 수 있는 반면, 특정 기술에 락인되어 쉽게 변경되거나 확장하지 못한다는 단점이 있다.

### 최근의 아키텍처
- 최근에 분위기를 바꿔 하나의 벤더에 의존하거나 직접 구출할 필요가 적어졌다.
  - 왜냐하면 클라우드 환경에서 사용되는 오픈소스 또는 오픈소스를 기반으로 한 상용 제품들이 이전의 유명 벤더의 제품군 만큼이나 품질이 높아지고 다양한 기능을 지원하면서 서로 다른 오픈소스 제품간에도 호환성이 높아졌기 때문이다.
- 이러한 흐름은 아키텍처 설계 활동에도 변화를 가져왔다.
  - 예전에는 검증된 기술이나 솔루션을 기반으로 기술을 직접 구현하는 폐쇄적인 방식
  - 최근의 아키텍처 설계는 필요한 영역에 적절한 솔루션을 선택하고 조합하는 개방적인 방식으로 바뀜 

## 2.3 마이크로서비스의 외부 아키텍처와 내부 아키텍처

![KakaoTalk_Photo_2023-01-11-12-29-35](https://user-images.githubusercontent.com/28394879/211711352-af7feceb-86d2-4995-b5f4-2af0cf24175a.jpeg)
- 밑에서부터 인프라, 플랫폼, 애플리테이션 영역으로 구분
- 각 관계
  - 맨 아래에 기반이 되는 하드웨어 인프라 
  - 인프라 영역위에 애플리케이션을 운영 및 구동하기 위한 플랫폼
  - 플랫폼 위에 애플리케이션인 서비스가 구독 
- MSA 외부 아키텍처
  - 인프라 영역과 플랫폼 영역, 애플리케이션 영역에 있는 구성 요소 및 그것들의 관계를 정의
  - 마이크로서비스가 운영되는 환경을 정의
  - 인프라 환경, 플랫폼 환경, 마이크로서비스가 운영되는 애플리케이션 환경이 모두 포함, 특히 애플리케이션 측면에서는 여러 개의 마이크로서비스를 관리하고 운영하기 위한 애플리케이션도 모두 포함
  - 이러한 환경을 클라우드 아키텍처가 요구하는 유연성과 확장성을 고려해서 정의해야 함
- MSA 내부 아키텍처
  - 실제로 비즈니스가 실행되는 비즈니스 애플리케이션, 즉 각 MSA의 내부 구조를 정의
  - MSA가 제공하는 API, 비즈니스 로직, 이벤트 발행, 데이터 저장 처리 등을 어떻게 구조화해야 하는가에 대한 내용 
  - 당연히 이 구조도 변화에 적응 가능하도록 유연하고 확장성 있게 구현해야 함

## 2.4 MSA 구성요소 및 MSA 패턴

- 아키텍처 스타일 또는 아키텍처 패턴이란?
  - 어떤 문제 영역에 대해 여러 사람들에 의해 검증되어 정리된 유용한 해법
- 마이크로 서비스 아키텍처에도 아키텍처 패턴이 있다.
  - 크리스 리처드슨은 MSA 아키텍처 패턴을 인프라 패턴, 애플리케이션 인프라 패턴, 애플리케이션 패턴 등으로 분류해서 정의했다.

| 패턴 유형 | 설명 |
| --- | --- |
| 인프라 구성요소 | 마이크로서비스를 지탱하는 하부구조 인프라를 구축하는데 필요한 구성요소 |
| 플랫폼 패턴 | 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴 |
| 애플리케이션 패턴 | 마이크로서비스 애플리케이션을 구성하는 데 필요한 패턴 |


### 2.4.1 인프라 구성 요소

- 인프라: 하드웨어, 소프트웨어, 네트워킹 구성요소, 운영체제, 데이터 스토리지 등 
- 클라우드 환경에서는 위 인프라 구성요소가 가상화되어 제공됨.
- 각 유형을 살펴보자.

**퍼블릿 클라우드와 베어 메탈, 프라이빗 클라우드 환경**  
- IaaS PaaS 서비스를 통해 시스템의 구성, 할당, 관리, 모니터링 등이 설정 작업을 몇번의 버튼 클릭만으로 처리할 수 있다.
- 위 같은 환경에서 아키텍트가 해야 할일은 
  - 맨 하부의 시스템의 기반이 되는 인프라 구축 
  - 기존의 물리적인 베어 메탈 장비를 구매해서 구축 할지, 가상화 환경을 선택해서 이용할지 를 고민
  - 클라우드 사업자가 서비스로 제공하는 퍼블릭 IaaS, PaaS를 선택할지 또는 직접 구매하거나 기존의 보유한 베어 메탈 서버에 프라이빗 PaaS를 구축할지 고민
- 마이크로 서비스는 어떠한 장비에도 구동될 수 있다.
  - 특정 인프라를 고집할 필요는 없다.
  - 그렇지만 가상화 장치 없이 베어 메탈 장비로 구동하는것은 쉽지 않다.
  - 따라서 가상 인프라 환경을 검토할 필요가 있다.
- 예전에는 인프라 선택이 소프트웨어 구성요소에 영향을 끼쳤지만 요즘은 어떤 것을 선택하든 다른 아키텍처 요소와 유연하게 결합할 수 있어 크게 신경 안써도 된다.
  - 모든 소프트웨어들이 상호 독립적이고 서로 호환되도록 유연한 구조로 만들어졌기 때문 
  - 이처럼 유연성이 클라우드 기반 소프트웨어의 필수 요소로 자리 잡고 있는 것이 추세이다.

**VM과 컨테이너**
- 가상 인프라 환경을 활용하기로 선택하면 그다음으로 가장 먼저 고민해야 할 사항은 가상머신 vs 컨테이너 기반을 선택하는 것이다.
- 가상머신은
  - 하이퍼바이저라는 소프트웨어를 이용해 하나의 시스템에서 여러 개의 운영체제를 사용하는 기술
  - 운영체제 패치 설치나 관련 라이브러리 설치 같은 오버헤드가 지속적으로 발생 (게스트OS 사용)
- 컨테이너는
  - 하이퍼바이저 없이 컨테이너 엔진을 사용해 가상의 격리된 공간을 생성
  - 마이크로 서비스 같은 작은 서비스를 패키지하고 배포하기에 적합하다(게스트 OS 사용 X)
  - 대표적으로 도커를 많이 사용
  - 컨테이너 이미지 레이어 (기반 이미지 -> 이미지 레이어 1[운영체제] -> 이미지 레이어2[런타임] -> 이미지 레이어3[애플리케이션])
- 도커 컨테이너의 이점은
  - 이식성: 호스트 커널이나 플랫폼 버전에 상관없이 사용 가능하며 동일하게 동작
  - 신속성: 크기가 작고 가볍기 때문에 빠르게 배포 가능, 문제 발생 시 수정 없이 새로 기동하면 됨 
  - 재사용성: 동일한 환경을 재사용해서 쉽게 설정 가능하기 떄문에 개발, 테스트, 스테이징, 프로덕션 환경을 동일한 환경으로 구축하기 쉬움 
- 마이크로서비스가 가변적이고 유연한 속성을 컨테이너가 쉽고 빠르게 지원할 수 있다.

**컨테이너 오케스트레이션**
- 컨테이너 기술을 선택했다면 컨테이너를 관리하기 위한 기술 또한 필요 
- 컨테이너가 많아지면 컨테이너의 자동 배치 및 복제, 장애 복구, 확장 및 축소, 컨테이너 간 통신, 로드 밸런싱 등의 컨테이너 관리를 위한 기능이 필요해짐
- 이러한 기술을 컨테이너 오케스트레이션이라 한다.
- 도커 스웜, 아파치 메소스, 쿠버네티스 등이 있다.
- 쿠버네티스는 다음과 같은 주요 기능을 제공한다.
  - 자동화된 자원 배정: 각 컨테이너가 필요로 하는 CPU와 메모리를 쿠버네티스에 요청하면 컨테이너를 노드에 맞춰 자동으로 배치
  - 셀프 치유: health check해서 실패한 경우 자동으로 교체하고 재스케줄링 
  - 수평 확장: 일정 CPU 및 메모리 사용량을 초과하면 자동으로 확장 

**서비스 유형별 대표적인 클라우드 서비스**
- IaaS
  - 가상 머신, 스토리지 네트워크 같은 인프라를 필요한 만큼 적시에 제공하는 서비스
  - 사용자는 이러한 인프라를 이용해 개발 환경을 구성한 후 애플리케이션을 배포 
  - 가상 서버, 가상 네트워크, 가상 스토리지라 생각하면 쉽다.
  - ex) AWS EC2, Azure VM
- CaaS
  - 컨테이너 기반 가상화를 사용해 컨테이너를 업로드, 구성, 실행, 확장, 중지할 수 있는 서비스 
  - 애플리케이션을 바로 구동할 수 있는 환경을 제공한다는 점에서 PaaS와 유사 하지만, 다른 환경에도 이식 가능한 컨테이너 기반 가상화를 제공한다는 점에서 다름
  - ex) AKS, EKS, GKE, ECS
- PaaS
  - 복잡함 없이 애플리케이션을 곧바로 개발, 실행, 관리할 수 있는 플랫폼 환경을 서비스 형태로 제공
  - IaaS 위에 실제로 애플리케이션이 실행될 수 있는 미들웨어나 런타임까지 탑재된 환경
  - ex) Azure Web App, Google App Engine, AWS Elastic Beanstalk

### 2.4.2 마이크로서비스 운영과 관리를 위한 플랫폼 패턴 
- 지금까지는 MSA를 적재하기 위한 기반이 되는 클라우드 인프라 요소를 살펴봄.
- 다음으로 MSA의 원활한 동작을 지원하는 플랫폼 환경을 살펴보자.
- 애플리케이션이 실제로 구동되는 인프라 환경을 결정했다면 그 다음으로 선택한 인프라 환경 위에서 애플리케이션을 운영하고 관리하는 환경을 구성하는 방법을 생각해야 됨.
- 특히 애플리케이션을 빌드하고 인프라에 배로할 수 있는 환경이 중요함.

**개발 지원 환경: 데브옵스 인프라 구성**
- 그래서 필요한 요소가 마이크로서비스를 빌드하고 테스트한 뒤 배포할 수 있게 도와주는 개발 지원 환경인 데브옵스 환경이다.
- 개발과 운영을 병행 가능하게끔 높은 품질로 소프트웨어를 빠르게 개발하도록 지원하는 빌드, 테스트, 배포를 위한 자동화 환경을 말함.
- 수동 배포 절차
  1. 컴파일, 수동 테스트 오류수정 
  2. 수동 테스트 오류 수정 
  3. 배포 승인 
  4. 운영 환경에 야간 수동 배포 
- 이러한 수동 빌드/배포 과정에는 정말 많은 시간이 소요됨
- 여러 개의 마이크로서비스를 배포해야 하는 환경에서는 배포가 잦을 수 밖에 없기 때문에 자동화가 절실하다.
- 자동화된 빌드나 배포 작업을 보통 CI/CD라고 한다.
  - CI: 지속적 통합, 자동으로 통합 및 테스트하고 그 결과를 리포트로 기록하는 활동
  - CD: 지속적 배포, 실행 환경에 내보내는 활동

**빌드/배포 파이프라인 설계**
- 빌드/배포되는 과정 동안 수행해야 할 태스크가 정의된 것을 빌드/배포 파이프라인이라고 한다.
- 빌드/배포 파이프라인은 통합 및 배포까지 이어지는 일련의 프로세스를 하나로 연계해서 자동화하고 시각화된 절차로 구축하는 것을 말함
- 배포 파이프 라인 절차
  - 리포지토리 -> 빌드 & 유닛 테스트 -> 정적 분석 -> 통합 테스트 -> 배포 -> 마이크로 서비스 
  - 여기에 UI 테스트, 통합 테스트, 배포 승인 프로세스 등을 추가해서 재설계 할 수도 있다.
- Infrastructure as Code
  - 인프라 구성을 마치 프로그래밍하는 것처럼 처리하고 소수의 인원으로 많은 컨테이너 배포 처리를 할 수 있게 된것을 의미
  - 이것으로 배포 파이프라인 절차를 완벽하게 자동화 할 수 있으며, 대규모 인프라 관리를 수행할 수 있고, 코드이기 떄문에 쉽게 공유 및 재사용이 가능 

**마이크로서비스 생태계와 운영 관리 요소의 탄생**
- AWS의 클라우드 환경, 도커 컨테이너, 넷플리긋가 공유한 오픈소스, 스프링 프레임워크, 구글의 쿠버네티스 같은 것들이 MSA 생태계의 발전을 계속 이끌음.
- 이러한 과정을 거쳐 MSA 아키텍처의 주요 문제 영역들이 논의되고 그에 대한 해결책이 제새돼 왔음. 

**경험으로 획득한 지혜: 마이크로서비스 관리/운영 패턴**
- API 게이트웨이, 서비스 디스커버리, 모니터링, 트레이싱 등 다수의 마이크로서비스를 관리 및 운영하기 위한 플랫폼 패턴으로서 넷플릭스에서 소스를 공개하고 나서 패턴으로 정착되고
- 나중에 이러한 패턴을 적용한 다른 여러 도구와 오픈소스들이 생겨나는 밑거름으로 작용했다.
- 또한 넷플릭스 OSS를 더 쉽게 쓸 수 있도록 넷플릭스 OSS 모듈들을 스프링 프레임워크로 감싸서 스프링 클라우드라는 명칭으로 발표했다. 

**스프링 클라우드: 스프링 부트 + 스프링 OSS**
- 넷플릭스가 공개한 줄, 유레카, 히스트릭스, 리본 등의 넷플릭스 오픈소스를 스프링 부트 프레임워크 기반으로 사용하기 쉽게 통합한 것
- 예시로 비즈니스를 구현한 마이크로서비스 서비스와 스프링 클라우드 서비스의 연계 흐름 요약
  1. 모든 마이크로서비스는 인프라에 종속되지 않도록 DB, 파일 등에 저장된 환경 설정 정보를 형상관리 시스템에 연계된 `Config 서비스`에서 가져와 설정 정보를 주입한 후 클라우드 인프라의 개별 인스턴스로 로딩
  2. 로딩과 동시에 `서비스 레지스트리`에 자신의 서비스명과 클라우드 인프라부터 할당받은 물리 주소를 매핑해서 등록
  3. 클라이언트가 `API 게이트웨이`를 통해 마이크로서비스에 접근하고, 이 때 API 게이트웨이는 적절한 라우팅 및 부하 관리를 위해 로드 밸런싱을 수행
  4. 또한 API 게이트웨이에서 클라이언트가 마이크로서비스에 접근하기 위한 주소를 알기 위해 `서비스 레지스트리` 검색을 통해 서비스의 위치를 가져옴
  5. 동시에 API 게이트웨이는 클라이언트가 각 서비스에 접근할 수 있는 권한이 있는지 `권한 서비스` 와 연계해 인증/인가 처리를 수행 
  6. 이러한 모든 마이크로서비스 간의 호출 흐름은 `모니터링 서비스`와 `추적 서비스`에 의해 모니터링되고 추적된다
- 스프링 클라우드 외에 각 클라우드 제공 업체의 플랫폼에도 유사한 형태의 서비스로 각기 존재한다. 

**다양한 서비스의 등록 및 탐색을 위한 서비스 레지스트리, 서비스 디스커버리 패턴**
- 서비스 디스커버리 패턴의 탄생
  - 프론트엔드 클라이언트가 여러 개의 백엔드 마이크로서비스를 어떻게 호출해야 할까? 
  - 또한 스케일 아웃을 통해 인스턴스가 여러 개로 복제됐다면 어떻게 부하를 적절히 분산할 수 있을까?
  - 위의 질문을 위한 패턴이 서비스 디스커버리 패턴이다.
- 클라이언트가 여러 개의 마이크로서비스를 호출하기 위해서는 최적 경로를 찾아주는 라우팅 기능과 적절한 부하 분산을 위한 로드 밸런싱 기능이 제공돼야 한다.
  - 줄(Zuul): 라우팅 기능 담당
  - 리본(Ribbon): 로드 밸런싱 담당
- 라우터는 최적 경로를 탐색하기 위해 서비스 명칭에 해당하는 IP 주소를 알아야 한다.
  - 그런데 이러한 라우팅 정보를 클라이언트가 가지고 있으면 클라우드 환경에서 동적으로 변경되는 백엔드의 유동 IP 정보를 매번 전송받아 변경해야 한다.
  - 따라서 제3의 공간에서 이러한 정보를 관리하는 것이 좋다.
  - 즉, 백엔드 마이크로서비스 서비스의 명칭과 유동적인 IP 정보를 매핑해서 보관할 저장소가 필요하다.
  - 넷플릭스 유레카(Eureka)가 그 기능을 담당하고, 이러한 패턴을 서비스 레지스트리 패턴이라 한다.

![IMG_1787 (1)](https://user-images.githubusercontent.com/28394879/224304488-109c5220-25e6-4ad5-ab8a-7c54f2903105.jpg)
- 각 서비스 인스턴스가 로딩 될 떄 자신의 서비스 이름과 할당된 IP 주소를 레지스트리 서비스에 등록한다
  - 그런 다음, 클라이언트가 해당 서비스명을 호출할 때 라우터가 레지스트리 서비스를 검색해 해당 서비스의 이름과 매핑된 IP 저옵를 확인한 후 호출한다.
  - 이 레지스트리 서비스는 모든 마이크로서비스의 인스턴스의 주소를 알고 있는 서비스 매핑 저장소가 된다.
  - 모든 마이크로서비스가 처음 기동할 때 자신의 위치 정보를 저장하고, 서비스가 종료될 때 위치 정보가 삭제된다.
- 쿠버네티스에서는 DNS 및 서비스(Kubernetes Service)로 제공한다. 

**서비스 단일 진입을 위한 API 게이트웨이 패턴**
- 여러 클라이언트가 여러 개의 서버 서비스를 각각 호출하게 된다면 매우 복잡한 호출 관계가 만들어진다. 
- 위의 문제를 해결하기 위한 해결책 중 한가지가 API 게이트웨이다.
- 다양한 클라이언트가 다양한 서비스에 접근하기 위해서 단일 진입점을 만들어 놓으면 여러모로 효율적이다.
  - 다른 유형의 클라이언트에게 다른 API 조합을 제공할 수 있다.
  - 각 서비스에 접근할 때 필요한 인증/인가 기능을 한 번에 처리할 수도 있다.
  - 정상적으로 동작하던 서비스에 문제가 생겨 서비스 요청에 대한 응답 지연이 발생하면 정상적인 다른 서비스로 요청 경로를 변경하는 기능이 작동되게 할 수도 있다.
- 이러한 서비스 흐름 제어를 위한 서비스 라우팅 기능은 L4 같은 하드웨어 장비로 구현할 수도있고 소프트웨어로 구현할 수도 있다.
  - 소프트웨어로 구현할 경우 API 게이트웨이가 애플리케이션 레벨의 라우팅 기능을 수행한다.
  - 또한 여러 인스턴스로 부하를 분산하는 로드 밸런싱도 수행하고, 
  - 라우팅시 필터를 둬서 라우팅 전과 후에 각각 수행되는 선행 처리와 후행 처리, 에러 처리 등을 손쉽게 구현할 수 있다.
- API 게이트웨이의 기능 요약
  - 레지스트리 서비스와 연계한 동적 라우팅, 로드 밸런싱
  - 보안: 권한 서비스와 연계한 인증/인가
  - 로그 집계 서비스와 연계한 로깅, ex) API 소비자 정보, 요청/응답 데이터
  - 매트릭, ex) 에러율, 평균/최고 지연시간, 호출 빈도 등 
  - 트래이싱 서비스와 연계한 서비스 추적, ex) 트래킹 ID 등록
  - 모니터링 서비스와 연계한 장애 격리(서킷 브레이커 패턴)
- 스프링 클라우드의 스프링 API 게이트웨이라는 제품으로 구현할 수 있다.
- 쿠버네티스의 경우 쿠버네티스 서비스와 인그레스 리소스로 구현할 수 있다.
- 프론트엔드가 백엔드를 호출할 때도 쓰지만, 외부 레거시 시스템과 단일 지점에서 서로 다른 형태의 API를 연계하는 용도로도 사용한다

**BFF패턴**
- 다양한 클라이언트를 위해서 특화된 처리를 위한 API 조합이나 처리가 필요한데, 이를 위한 해결방법이 BFF패턴이다.
- BFF패턴은 프론트엔드의 유형에 따라 각각 두는 패턴이다.
  - 웹을 위한 API 게이트웨이, 모바일을 위한 API 게이트웨이 등 클라이언트 종류에 따라 최적화된 처리를 수행할 수 있게 구성한다.
  - 각 프론트엔드에 대한 처리만 수행하는 BFF를 두고 이후에 통합적인 API 게이트웨이를 둠으로써 공통적인 인증/인가, 로깅 등의 처리를 통제하는 구조로 구성할 수 있다.


**외부 구성 저장소 패턴**
- 애플리케이션 구성 정보 설정에 관련된 패턴이다. 
- 클라우드 인프라와 같이 유연한 인프라를 사용하는 상황에서 데이터베이스 연결 정보, 파일 스토리지 정보 같은 내용을 애플리케이션에 포함하면 변경 시 반드시 재배포를 해야 하는데, 이 경우 서비스를 중단해야 한다.
  - 또한 마이크로서비스가 동일한 구성 정보를 사용하는 경우에도 일일이 변경하기 어렵고 변경 시점에 일부 마이크로서비스의 구성 정보가 불일치할 수도 있다.
  - 따라서 마이크로서비스가 사용하는 자원의 설정 정보를 쉽고 일관되게 변경 가능하도록 관리할 필요가 있다.
- 이를 위한 방법이 외부 저장소 패턴이다.
- 외부 저장소는 각 마이크로서비스의 외부 환경 설정 정보를 공동으로 저장하는 백업 저장소다.
- Config 원칙: 애플리케이션이 배포되는 환경(스테이징, 프로덕션, 개발, 테스트 환경)이 매번 달라지기 떄문에 코드에서 사용하는 환경 설정 정보는 코드와 완전히 분리되어 관리해야 한다는 원칙
  - 클라우드에서 운영되는 애플리케이션은 특정한 배포 환경에 종속된 정보를 코드에 두면 안 된다는 원칙이다.
  - 분리해야 할 환경 정보 ex) DB 연결 정보, 배포시 변경해야 할 호스트명, 백엔드 서비스의 연결을 위한 리소스 정보 등 
- 스프링 클라우드 컨피그를 이용하면 이러한 환경 정보를 코드에서 분리하고 컨피그 서비스를 통해 런타임 시 주입되게 할 수 있다.
  - 환경 정보는 Git 에서 보관하고 컨피그 서비스는 해당 서비스에 특정 환경에 배포될 때 적절한 환경 정보를 Git에서 가져와 해당 서비스에 주입한다.

**인증/인가 패턴**
- 각 서비스가 모두 인증/인가를 중복으로 구현하면 비효율적이다.
- 따라서, 마이크로서비스 인증/인가를 처리하기 위해서는 일반적으로 다음과 같은 패턴을 활용한다.
- 중앙 집중식 세션 관리
  - 기존 모노리스 방식에서 가장 많이 사용했던 방식은 서버 세션에 사용자의 로그인 정보 및 권한 정보를 저장하고, 이를 통해 애플리케이션의 인증/인가를 판단하는 것이다.
  - 하지만 마이크로서비스는 사용량에 따라 수시로 수평 확장할 수 있고 로드 밸런싱 처리가 되기 떄문에 데이터가 손실될 수 있다.
  - 따라서 마이크로서비스는 각자의 서비스에 세션을 저장하지 않고 공유 저장소에 세션을 저장하고 모든 서비스가 동일한 사용자 데이터를 얻게 한다.
  - 이 때 세션 저장소로 보통 redis 나 memcached를 사용한다 
- 클라이언트 토큰 
  - 세션은 중앙 서버에 저장되고 토큰은 사용자의 브라우저에 저장된다.
  - 토큰은 사용자의 신원 정보를 가지고 있고 서버로 요청을 보낼 때 전송되기 떄문에 서버에서 인가 처리를 할 수 있다.
- API 게이트웨이를 사용한 클라이언트 토큰
  - 사용자 인증 프로세스는 토큰 인증 프로세스와 유사하다.
  - 차이점은 API 게이트웨이가 외부 요청의 입구로 추가된다는 것이다.
  - 또한 인증/인가를 처리하기 위한 별도의 전담 서비스를 만들어서 다른 서비스의 인증/인가 처리를 위임할 수 있다.
  - 이러한 서비스를 인증 서비스라 하는데, API 게이트웨이와 연동해서 인증/인가를 처리한다.
  1. 클라이언트가 리소스 서비스에 접근을 요청하면 API 게이트웨이는 인증 서비스에게 전달한다.
  2. 인증 서비스는 해당 요청이 인증된 사용자가 보낸 것인지, 해당 리소스에 대한 접근 권한이 있는지 확인하고, 모두 확인하고 나면 리소스에 접근 가능한 증명서인 액세스 토큰을 발급한다.
  3. 클라이언트는 다시 액세스 토큰을 활용해 접근을 요청한다
  4. 그럼 각 리소스 서비스는 이러한 요청이 액세스 토큰을 포함하고 있는지 판단해서 리소스에 대한 접근을 허용한다.
 
**장애 및 실패 처리를 위한 서킷 브레이커 패턴**
- 한 서비스에 장애가 발생했을 때 다른 서비스가 영향을 받을 수 있다.
- 이 때 장애가 발생한 서비스를 격리해서 유연하게 처리할 수 있는 방법 중 하나가 서킷 브레이커 패턴이다.
- 서비스의 수가 많아지면 장점도 있지만 단점도 있다.
  - ex) 사용자가 접하는 전체 시스템은 정상적인데 특정 기능을 선택하면 즉각 에러가 발생하지도 않고 한참 동안 대기하는 상황이 발생할 수 있다.
  - 사용자는 장애인지 아닌지 파악도 안되고 단순히 시스템이 느려졌다고 판단할 수도 있다.
  - 위 상황은 정상적인 서비스가 장애가 발생한 서비스에 의존해서 서비스를 제공할 떄 발생하는 상황으로서 장애가 다른 서비스로 전이된 상태다.
- 시스템 과부하나 특정 서비스에 문제가 생겼을 때 자연스럽게 다른 정상적인 서비스로 요청 흐름이 변경되게 해야 한다.
  - 그러려면 서비스 상태를 항상 실시간으로 관리하고 시각화하고 모니터링할 수 있어야 하고, 
  - 특정 서비스에서 장애가 감지되면 장애가 다른 서비스로 전이되지 않게 하는 방법이 반드시 필요하다.
  - 이를 서킷 브레이커 패턴이다.
- 예를 들어 A라는 서비스가 B라는 서비스를 호출해서 자신의 서비스를 제공한다고 하자.
  - B서비스에서 장애가 발생하면 동기 요청의 성격상 A는 계속 기다린다.
  - 이 경우 A라는 서비스까지도 장애가 발생한 것처럼 사용자가 느끼게 된다.
  - 서킷브레이커 패턴은 이 상황에서 B 서비스 호출에 대한 연속 실패 횟수가 임곗값을 초과하면 회로 차단기가 작동해서 이후에 서비스를 호출하려는 모든 시도를 즉시 실패하게 만든다.
  - 그리고 fallback 메서드를 지정해 두면 장애가 발생했을 때 fallback 메서드가 자연스럽게 처리를 진행하게 된다.
  - 그럼 사용자는 특정 서비스에 장애가 발생했는지 눈치채지 못하고 시간이 흘러 장애가 복구됏을 때 다시 호출을 정상화하면 된다.

**모니터링과 추적 패턴**
- 서킷 브레이커 패턴을 가능하게 하려면 각 마이크로서비스의 장애를 실시간으로 감지해야 하고, 서비스 간의 호출이 어떤지 알아야 한다.
- 즉, 모니터링하고 추적하는 패턴이 필요하다.
- 스프링 클라우드에서는 히스트릭스라느 라이브러리를 제공, 히스트릭스 라이브러리가 배포된 서비스를 모니터링할 수 있는 히스트릭스 대시보드를 제공함으로써 MSA 요청을 실시간으로 모니터링할 수 있다.
- 분산 트레이싱 서비스는 
  - 모니터링과 함께 각 서비스 트랜잭션의 호출을 추적하면 MSA 운영에 매우 유용하다. 
  - 트위터에서 공개한 Zipkin이라는 오픈소스 프로젝트의 대시보드는 분산된 서비스 간의 호출이나 지연 구간별 장애포인트를 확인할 수 있다. 
  - 또한 서비스 API를 선택하면 각 API가 다른 API를 어떻게 호출하는지 호출 시의 반응 시간이나 지연 구간 등을 확인할 수 있다.
  - 정적인 다이어그램을 통해 전체적인 API간의 호출 빈도도 확인할 수 있다.

**중앙화된 로그 집계 패턴**
- 마이크로서비스가 사용량에 따라 탄력적으로 변화하면서 언제든지 인스턴스가 생성/삭제되는 과정에서 로컬 로그가 초기화 될 수 있다.
- 마이크로 서비스에서 로그 스트리므이 전달이나 저장에 관여하면 특정 기술이나 인프라에 의존할 수 밖에 없고 유연성이 떨어지므로 관여하지 않는게 좋다.
- 중앙화된 로그 집계 패턴은
  - ELK스택을 이용하면 각 서비스의 인스턴스 로그를 집계해서 중앙에서 집중 관리할 수 있다.
  - 특정 메시지가 로그에 나타나거나 특정 예외가 발생할 때 운영자나 개발자에게 직접 통보하게 할 수 도 있다. 

**MSA 기술 변화 흐름**
- 추적, 모니터링, 로깅, 인증, 탐색, 유연성, 탄력성 등의 문제를 해결하기 위해 초기 MSA생태계에서는 넷플릭스 OSS나 스프링 클라우드를 이용해 각각의 서비스를 별도로 만들어서 해결하거나 유연성처럼 수평 확장이 필요한 요소는 AWS IaaS 서비스를 이용해 해결했다.
- 그러나 이후 여러 문제의 해결책을 한꺼번에 제공하는 솔루션이 등당했는데, 바로 쿠버네티스나 오픈시프트 같은 제품이다.
- 특히 인프라 유연성을 보장하기 위해 AWS IaaS의 인프라 차원에서 해결했던 역할을 쿠버네티스가 소프트웨어 차원, 즉 컨테이너의 레플리카 기술로 탐색, 호출 문제와 함께 통합해서 지원하면서 쿠버네티스가 각광받고 있다.
- 그런데 최근 동향은 쿠버네티스에 덧붙여 이스티오(Istio) 기술이 함께 사용되고 있다. 

**서비스 메시 패턴**
- 초창기 MSA 기술인 넷플릭스 OSS나 스프링 클라우드 기반의 서비스를 구축 및 운용할 때의 문제점은
  - API 게이트웨이, 서비스 레지스트리, 컨피그 서비스와 같이 운영 관리를 위한 여러 개의 기반 서비스를 별도로 각각 만들어야 한다는 번거로움
  - 더불어 업무 처리 마이크로서비스에 스프링 클라우드 서비스를 사용하기 위한 라이브러리를 비즈니스 로직과 함게 탑재해야 한다는 점이었다.
  - 기능 구현에 집중해야 하는 마이크로서비스 입장에서 이러한 코드까지 관리 및 운영해야 한다면 번거로울 수 밖에 없다.
  - 마이크로서비스가 자바 외의 다른 언어로 폴리그랏하게 구현된 경우에는 스프링 클라우드 서비스를 아예 사용할 수 조차 없다.
- 그래서 최근에는 MSA 문제 영역 해결을 위한 기능(서비스 탐색, 서킷 브레이크, 추적, 로드 밸런싱 등)을 비즈니스 로직과 분리해서 네트워크 인프라 계층에서 수행하게 하는 서비스 메시 패턴이 선호되고 있다.
- 서비스 메시는 인프라 레이어로서 서비스 간의 통신을 처리하며 앞에서 위의 여러 문제들을 해결 한다.
- 서비스 메시 패턴의 대표적 구현체는 구글의 이스티오(Istio)이다.
  - 이스티오는 애플리케이션이 배포된느 컨테이너에 완전히 격리되어 별도의 컨테이너로 배포되는 사이드카(sidecar) 패턴을 적용해서 서비스 디스커버리, 라우팅, 로드 밸런싱, 로깅, 모니터링, 보안, 트레이싱 등의 기능을 제공한다.
- 서비스 메시가 없다면 애플리케이션 자체 코드 내부에 스프링 클라우드 사용을 위한 클라이언트 코드가 탑재돼야 하지만,
- 서비스 메시를 적용한다면 마이크로서비스마다 함께 배포되는 사이드카 프락시에 운영 관리를 위한 기능이 별도로 담겨 있기 때문에 마이크로서비스는 순수 비즈니스 로직에 집중할 수 있다.
- 쿠버네티스의 컨테이너 단위인 파드(pod)에 서비스 컨테이너와 사이드카 구현체인 Envoy(엔보이) 컨테이너가 함께 배포된다.
- 이스티오는 스프링 클라우드와 넷플릭스 OSS에서 제공했던 대부분의 기능을 모두 제공하면서 동시에 차별점도 있다.
  - 주요 기능 
    - 트래픽 관리: 동적 라우팅, 로드 밸런싱
    - 보안: 보안 통신 채널(TLS), 인증/인가/암호화
    - 관측성: 메트릭, 분산, 트레이싱, 로깅
  - 차별점
    - 애플리케이션 코드의 변경이 거의 없다. 완전히 사이드카로 격리되어 yaml 파일과 같은 설정 파일에 의해 정의된다.
    - 폴리글랏 애플리케이션도 지원한다. 자바외의 다른 언어도 지원 가능
    - 이스티오는 쿠버네티스와 완벽하게 통합된 환경을 지원한다
 

### 2.4.3 애플리케이션 패턴
- 지금까지는 마이크로서비스를 위한 인프라 구성 요소 및 MSA 관리 운영 패턴을 살펴봤다.
- 지금부터는 실제로 개발자가 구현해야 할 애플리케이션 영여긍로 넘어와서 마이크로서비스 애플리케이션을 구성하기 위한 패턴을 살펴보자.
- 마이크로서비스의 구성과 관계를 설계할 때도 마찬가지로 유연성과 확장성, 독립성 등을 염두에 두고 설계해야 한다.
- 먼저 프론트엔드는 어떤 패턴으로 구성해야 할까?
  - 단순한 방법은 예전처럼 단일 모노리스로 구성하는 방법이다.
  - 이 경우 고민은 프론트엔드가 한 덩어리일 경우 과연 마이크로서비스 기반 시스템의 장점인 서비스의 독립적인 변경과 배포가 가능할지 이다.
  - 백엔드는 수정해서 하나의 서비스로 독립적으로 배포가능하지만 프런트엔드는 덩어리이기 때문에 변경되지 않은 다른 기능들도 함께 빌드되고 배포해야 한다.
  - 따라서 이전의 백엔드가 모노리스였을 때 겪었던 문제(독립적인 기능 변경 및 배포 불가, 독립적인 기능 확장 불가)를 프론트엔드의 모노리스 서비스도 동이랗게 겪을 수 밖에 없다.
  - 이를 위한 해결방안이 UI 컴포지트 패턴과 마이크로 프런트엔드라고 하는 패턴이다.

**UI 컴포지트 패턴 또는 마이크로 프런트엔드**
- 프런트엔드도 백엔드 마이크로서비스처럼 기능별로 분리하고 이를 조합하기 위한 프레임 형태의 부모 창을 통해 각 프런트엔드를 조합해서 동작하게 한다.
- 부모 서비스는 틀만 가지고 있고, 실제 각 기능 표현은 마이크로 프론트엔드 조각이 구현하게 한다.
- 마이크로 프런트엔드들은 비즈니스 구현을 위해 여러 개의 백엔드 마이크로서비스 API를 호출한다.

**마이크로서비스 통신 패턴**
- 프론트와 백엔드, 백엔드 간의 마이크로 서비스 호출에는 어떤 방법을 사용해야 할까?  
- 동기 통신 방식
  - 클라이언트에서 서버 측에 존재하는 마이크로 서비스 REST API를 호출할 때 사용되는 기본 통신 방법 
  - 다양한 클라이언트 채널 연계나 라우팅 및 로드 밸런싱을 원활하게 하기 위한 방법으로 중간에 API 게이트웨이를 둘 수 있다.
  - 백엔드 마이크로서비스 간의 호출에는 어떤 방법을 사용하면 될까?
  - 물론 맨 먼저 검토해야 할 방법은 REST API 같은 동기식 호출이다.
  - 예를 들어) 
    - 모바일에서 고객의 주문 내역을 확인하기 위해 주문 서비스를 호출하면, 주문 서비스는 고객 정보를 확인하기 위해 고객 서비스에 동기 호출을 수행한다.
    - 바로 요청하면 응답이 오는 직관적인 방식이기 때문에 가장 많이 쓰이고 구현하기 쉽다.
    - 그렇지만, 호출을 받은 마이크로서비스에 장애가 생긴다면 어떻게 될까?
    - 요청을 보낸 서비스는 반응이 올 때 까지 기다리게 되고, 반응이 오지 않으면 계속 기다리면서 재호출하게 된다.
  - 여러 서비스 간의 연계를 통해 업무를 처리하는 마이크로서비스 구조에서는 이 같은 상황에서 장애가 연쇄적으로 발생할 수 있다.
  - 또 서비스가 다른 서비스를 호출해서 얻은 정보를 이용해 기능을 제공한다는 의미는 해당 서비스 간의 의존관계가 높다는 것을 의미한다 
  - 이러한 방식의 서비스 제공은 독자적인 마이크로서비스별로 비즈니스 기능 처리를 어렵게 만든다.
  - 따라서 장애의 파급 효과 및 의존 관계를 낮추기 위한 다른 통신 방법이 필요하다
- 비동기 통신 방식
  - 메시지 기반의 비동기 호출은 
    - 동기 호출처럼 응답을 기다리지 않는다.
    - 보낸 결과가 어떻게 됐는지 응답을 받지 않으므로 동기식처럼 완결성을 보장할 수는 없다.
    - 따라서 이를 보장하기 위한 메커니즘이 필요한데, 보통 Kafka, RabbitMQ, ActiveMQ 같은 메시지 브로커를 활용한다
    - 메시지 브로커에 메시지를 전달하고 자신의 일을 처리하면 메시지 브로커가 전송을 보장하게 된다.
- 비동기 방식의 이벤트 기반 아키텍처
  - 비동기 통신 방식을 이용해 느슨한 연계를 지향하는 아키텍처.
  - 이벤트에 반응한다는 의미로 이벤트 기반 아키텍처라고 부르는데, 이벤트 기반 아키텍처는 예전부터 사용된 개념으로서 분산 시스템 간에 발신자가 이벤트를 생성 및 발행하고, 해당 이벤트를 필요로 하는 수신자에게 전송하면 이벤트를 구독하고 있던 수신자가 이벤트를 받아 처리하는 형태의 시스템 아키텍처다.
  - 여기서 이벤트는 `상태의 변화`를 의미하여, 기존의 순차적 방식의 아키텍처와 달리 특정 행동이 자동으로 순서에 따라 발생하는 것이 아닌 어떤 상태의 변경에 대한 반응으로 동작한다는 점이 차이점이다.
  - 실생활 예)
    - 커피숍에서 손님이 주문을 하면 주문 접수자는 주문을 받는다.
    - 그리고 바리스타에게 커피 제작을 의뢰한다
    - 이 때 주문 접수자는 하나의 주문이 바리스타에 의해 완료될 때 까지 마냥 주문을 받지 않고 기다리지 않는다. 
    - 즉, 주문 접수 -> 커피 제작 -> 고객 전달이라는 하나의 무결하고 완결된 단위로 다루지 않는다.
    - 그 대신 주문이 들어오는 대로 꾸준히 주문 목록에 적고 동시에 커피 주문이 들어왔다는 이벤트를 바리스타에게 계속 전달한다.
    - 커피 제작이 완료되면 커피 제작 완료 이벤트를 보내고, 이것이 진동벨을 통해 손님에게 통보된다.
    - 주문은 많이 들어오는데 바리스타가 부족하다면 추가로 더 투입될 수도 있다.
    - 이러한 이벤트 기반 방식은 여러 개의 주문을 받아 여러 개의 커피를 동시에 제작할 수 있는 효율성을 높인다.
    - 반면 병렬 처리를 하지 않고 하나의 커피 주문을 받고 커피가 제작될 때 까지 다른 주문을 접수 할 수 없다면 매우 비효율적이다.
  - 이러한 이벤트 기반 아키텍처의 전달 메커니즘으로 비동기 메시지 메커니즘을 선택하면 더욱더 효과적이다.
  - 이벤트 기반의 아키텍처와 비동기 통신 메커니즘을 함께 사용하는 마이크로서비스를 이벤트 기반 마이크로서비스라고도 한다.
  - 이벤트 메시지를 사용하면 발신자와 수신자를 장소와 시간에서 쉽게 분리할 수 있으며, 마이크로서비스가 추구하는 느슨한 결합으로 확장성, 탄력성 측면에서 이점이 많다.
  

**저장소 분리 패턴**
- 기존 모노리스 시스템의 저장소는 통합 저장소다. 즉, 애플리케이션 모듈은 분리하되 저장 처리는 모듈별로 격리하지 않고 다른 모듈에서의 호출을 허용하는 구조였다.
  - 업무 규칙 및 흐름 처리를 수행하는 애플리케이션의 코드 라인 수 보다 SQL 코드의 라인 수가 몇배 이상이다.
  - 이러한 구조를 데이터 중심 애플리케이션이라 하는데, 특정 관계형 데이터베이스 벤더에 구속되고 복잡해져 유지보수가 어려워지고 성능 문제가 발생했을 때 SQL 구문 튜닝이나 저장소 증설(스케일 업)에 의존할 수 밖에 없다.
  - 이러한 구조의 애플리케이션은 아무리 여러 개의 마이크로서비스로 분리하더라도 요청이 증가할 경우 서비스는 한가하고 여러 서비스에서 호출되는 통합 데이터베이스만 여전히 바쁜 상황이 되어 마이크로서비스의 자동 확장(스케일 아웃) 기능이 별 소용이 없어질 수 있다.
- 위 문제들을 보완할 수 있는 마이크로서비스 패턴이 저장소 분리 패턴이다.
  - 각 마이크로서비스는 각자의 비즈니스를 처리하기 위한 데이터를 직접 소유해야 한다는 것을 말한다.
  - 그렇기 때문에 자신이 소유한 데이터는 다른 서비스에 직접 노출하지 않고 각자가 공개한 API를 통해서만 접근할 수 있다(정보 은닉)
  - 또한 저장소가 격리돼 있기 때문에 각 저장소를 자율적으로 선택할 수 있다(폴리글랏 저장소)
  - 궁극적으로 이 같은 제약이 데이터를 통한 변경의 파급 효과(영향도)를 줄여 서비스를 독립적으로 만든다 
- 그러나 위처럼 마이크로서비스별로 기능을 분리하고 저장소를 격리함에 따라 이전에는 없었던 문제가 생긴다.
- 즉, 여러 개의 분산된 서비스에 걸쳐 비즈니스 처리를 수행해야 하는 경우 비즈니스 정합성 및 데이터 일관성을 어떻게 보장할 것인가에 대한 문제이다.

**분산 트랜잭션 처리 패턴**
- 손쉽게 적용할 수 있는 한 가지 방법은 여러 개의 분산된 서비스를 하나의 일관된 트랜잭션으로 묶는 것이다.
- 분산 트랜잭션 처리를 위한 전통적인 방법으로 2단계 커밋 같은 기법이 있다.
  - 2단계 커밋은 분산 데이터베이스 환경에서 원자성(atomicity)을 보장하기 위해 분산 트랜잭션에 포함돼 있는 모든 노드가 커밋(commit)되거나 롤백(rollback)하는 메커니즘이다.
  - 그런에 이 방법은 각 서비스에 잠금(lock in)이 걸려 발생하는 성능 문제 탓에 효율적인 방법이 아니다.
  - 특히 각 서비스가 다른 인스턴스로 로딩되기 때문에 통제하기 어렵다.
  - 또한 서비스의 저장소가 각각 다를 경우 문제가 있으며, MongoDB 같은 NoSQL 저장소는 2단계 커밋 자체를 지원하지 않는다.
  - 2단계 커밋을 통한 분산 트랜잭션 처리는 독립적이지 않고 비자율적이다.
- 마이크로서비스의 독립적인 분산 트랜잭션 처리를 지원하는 패턴이 바로 사가(Saga) 패턴이다.
  - 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴
  - 여러 개의 분산된 서비스를 하나의 트랜잭션으로 묶지 않고 각 로컬 트랜잭션과 보상 트랜잭션을 이용해 비즈니스 및 데이터의 정합성을 맞춘다.
  - 각 로컬 트랜잭션은 자신의 데이터베이스를 업데이트 한 다음, 사가 내에 있는 다음 로컬 트랜잭션을 트리거하는 메시지 또는 이벤트를 게시해서 데이터의 일관성을 맞춘다.
  - 다른 트랜잭션 결과에 따라 롤백이 필요하다면, 보상 트랜잭션으로 처리한다.
  - 보상 트랜잭션은 어떤 서비스에서 트랜잭션 처리에 실패할 경우 그 서비스의 앞선 다른 서비스에서 처리된 트랜잭션을 되돌리게 하는 트랜잭션이다.
- 정리하면, 사가는 트랜잭션을 모두 묶어 하나의 트랜잭션으로 처리하지 않고, 각 로컬 트랜잭션으로 분리해서 순차적으로 처리하는 방법이다.
  - 그러다가 트랜잭션이 실패할 경우 이전 로컬 트랜잭션이 작성한 변경 사항을 취소하는 일련의 보상 트랜잭션을 통해 비즈니스 처리의 일관성을 유지한다.
- 예를 들어, 주문 서비스와 고객 서비스가 있다.
  - 주문을 처리할 때 고객의 신용한도 정보에 따라 최종 주문을 승인하는 업무가 있다.
  - 이 두 서비스의 트랜잭션을 하나로 묶지 않고 보상 트랜잭션과 이벤트를 활용해 처리할 수 있다.
  1. 주문 처리가 시작되면 주문 서비스는 가주문을 생성하고 주문자 정보가 담긴 '주문 생성됨' 이벤트를 발생하고 트랜잭션을 종료한다
  2. 고객 서비스가 '주문 생성됨' 이벤트를 확인한 뒤 다음 처리를 수행한다
     1. 이벤트에 존재하는 주문자 정보로 고객의 신용한도를 조회해서 신용한도가 충족되면 '신용 승인됨' 이벤트를 발행한다
     2. 신용한도가 충족되지 않는다면 '신용한도 초과됨' 이벤트를 발행한다
  3. 주문 서비스는 고객 서비스가 발생한 이벤트를 확인해 다음 처리를 수행한다
     1. 고객 서비스가 발행한 이벤트가 '신용 승인됨'인 경우에는 주문 승인 처리를 한다
     2. '신용한도 초과됨' 이벤트인 경우에는 보상 트랜잭션인 주문 처리 취소를 수행한다.
 
**데이터 일관성에 대한 생각의 전환: 결과의 일관성**  
- 모든 애플리케이션에는 비즈니스 처리를 위한 규칙이 있고, 이러한 비즈니스 규칙을 만족하도록 데이터 일관성이 유지돼야 한다.
- 과거에는 이 같은 데이터 일관성이 실시간으로 반드시 맞아야 한다는 생각이 일반적이었다.
- 정말 그래야 하는가는 생각해 볼 문제다.
- 예를 들어
  - 쇼핑몰에서 주문을 하면 결제 처리가 돼야하고 그 결제가 완료되면 결제 내용과 주문 처리 내역이 주문자에게 이메일로 전송돼야 한다.
  - 일반적으로 주문된 다음에 결제가 되고 결제 내용이 이메일로 통보되는 것이 순차적인 일 처리 순서다.
  - 그런데 주문자가 폭주한 경우를 생각해보면, 주문 결제 이메일 처리가 이러한 순차적인 동시 일관성을 추구하는 경우 주무니 폭주하면 결제 처리가 되지 않거나 지연되는 경우가 발생할 수 있다.
  - 그럼 주문 처리 역시 지연될 것이다.
  - 따라서 이러한 상황을 고려했을 때 비즈니스 관점에서 보면 주문과 결제, 이메일 전송을 순차적으로 처리하기보다 무조건 먼저 주문을 많이 받아 놓는 것이 좋을 수 있다.
- 어떤 비즈니스는 데이터의 일관성이 실시간으로 맞지 않더라도 어느 일정 시점이 됐을 때 일관성을 만족해도 되는 것이 있는데, 이러한 개념을 결과적 일관성(eventual consistency)이라고 한다.
- 결과적 일관성의 개념은 고용성을 극대화한다. 반대로 실시간성을 강조하면 결제 서비스에서 발생한 장애가 다른 서비스의 가용성을 떨어뜨릴 수 있다. 결제 서비스의 장애로 주문 서비스마저 사용할 수 없을 수 있다.
- 사가 패턴과 이벤트 메시지 기반 비동기 통신을 사용하면 해결 될 수 있다.
  - 각 마이크로서비스의 트랜잭션은 독립적이고 각 트랜잭션이 성공했을 때 상태 변경 이벤트를 발행해 이 이벤트를 구독한 다른 서비스의 로컬 트랜잭션이 작동되게 한다.
  - 위의 쇼핑몰 예시를 사가패턴과 이벤트 메시지 기반 비동기 통신을 사용하면 다음과 같이 동작한다.
  1. 가주문이 생겅되고 '가주문됨' 이벤트를 발행한다. 주문은 독립적으로 로컬 트랜잭션이기 때문에 끊임없이 받을 수 있다. 주문이 몰릴 경우 주문 서비스만 확장해서 가용성을 높일 수 있다.
  2. '가주문됨' 이벤트는 메시지 브로커에 비동기로 전송된다
  3. 결제 서비스는 발행된 '가주문됨' 이벤트를 확인하고 대금 결제 트랜잭션을 수행하고 '결제 처리됨' 이벤트를 발행한다.
  4. 이메일 서비스는 '결제 처리됨' 이벤트를 확인하고 주문 결제 완료 이메일을 사용자에게 발송한다.
  5. 주문 서비스는 '결제 처리됨' 이벤트를 확인하고 가주문으로 처리됐던 주문을 최종 승인한다. 그리고 '최종 주문 완료됨' 이벤트를 발행한다
  6. 이메일 서비스는 주문 서비스가 발행한 '최종 주문 완료됨' 이벤트를 확인해 최종적으로 주문이 완료됐다는 이메일을 사용자에게 발송한다.
  7. 각 서비스는 각기 작업을 수행하다 오류가 발생하면 '실패 이벤트'를 발행해 다른 서비스가 비즈니스 정합성을 맞출 수 있게 한다.
  8. 이 때 별도로 메시지 큐에 쌓이는 이벤트들을 모니터링 서비스와 연계해 모니터링하고 추적해서 전체적인 비즈니스 정합성 여부를 관리자가 확인할 수도 있다.
- 위처럼 이벤트 기반 아키텍처와 메시지 브로커, 사가 패턴으로 비즈니스 정합성을 결과적으로 보장할 수 있고 비즈니스 및 시스템 가용성을 극대화 할 수 있다.

**읽기와 쓰기 분리: CQRS 패턴**  
- 비즈니스에 대한 기존 관념을 조금만 바꾸면 가용성을 높일 수 있는 방법이 다양하다.
- 서비스의 성능 향상을 위해 서비스 인스턴스를 스케일 아웃해서 여러 개로 실행한 경우 데이터 읽기/수정 작업으로 인한 리소스 교착상태가 발생할 수 있다.
- 위 문제를 해결하기 위한 방법으로 CQRS 패턴이 있는데, CQRS는 명령 조회 책임 분리를 의미한다.
- 일반적으로 사용자의 비즈니스 요청은 크게 시스템 상태를 변경하는 명령과 시스템의 상태를 조회하는 부분으로 나눌 수 있다.
- 두부분 중에서 당연히 상태를 조회하는 부분이 많이 쓰인다.
- 그런데, 서비스 내에 이러한 모든 기능을 넣어 두면 조회 요청 빈도가 증가함에 따라 다른 명령 기능도 함께 확장해야 하므로 효율적이지 않다.
- 따라서 하나의 저장소에 쓰기 모델과 읽기 모델을 분리하는 방식으로 변화시켜 쓰기 서비스와 조회 서비스를 분리할 수도 있고, 더 나아가 아예 물리적으로 쓰기 트랜잭션용 저장소와 조회용 저장소를 따로 준비할 수 있다.
- 이처럼 쓰기 전략과 조회 전략을 각각 분리하면 쓰기 시스템의 부하를 줄이고 조회 대기 시간을 줄이는 등 엄청난 이점을 누릴 수 있다.
- 이러한 CQRS 방식을 이벤트 메시지 주도 아키텍처와 연계해서 살펴보자.


![KakaoTalk_Photo_2023-03-22-19-55-40](https://user-images.githubusercontent.com/28394879/226882762-fa857928-3e76-42bc-a64f-b5708598ea08.jpeg)
- 위 그림처럼 우선 마이크로서비스를 명령 측면과 조회 측면의 두 부분으로 나눈다.
- 좌측의 명령 측면 마이크로서비스는 입력, 수정, 삭제 처리를 수행하고 저장소로는 쓰기에 최적화된 관계형 데이터베이스를 사용한다. 
  - 그리고 프로그래밍 언어도 업무 규칙을 표현하기 좋은 자바 언어를 사용한다
- 반면 오른쪽의 조회 측면의 마이크로서비스에는 조회 성능이 높은 몽고디비나 엘라스틱서치같은 NoSQL 데이터베이스를 저장소로 사용한다. 
  - 프로그래밍 언어도 조회를 간단하게 구현할 수 있는 Node.js를 사용한다.
  - 조회 서비스는 사용량이 많기 때문에 스케일 아웃해서 인스턴스를 증가시켜 놓는다.
- 그런데 이러한 구조에서는 명령 서비스가 사용됨에 따라 조회 서비스와의 데이터 일관성이 깨지게 된다.
  - 이 때 데이터 일관성 유지를 위해 필요한 것이 이벤트 주도 아키텍처다.
  - 명령 서비스는 저장소에 데이터를 쓰면서 저장한 내역이 담긴 이벤트를 발행시켜 메시지 브로커에 전달한다.
  - 조회 서비스는 메시지 브로커의 이벤트를 구독하고 있다가 이벤트 데이터를 가져와 데이터를 최신 상태로 동기화한다.
  - 물론 명령 서비스에 데이터가 들어간 즉시 조회 서비스의 데이터와 일치할 수 없고 시간적 간격이 있을 수 있지만, 어느 시점이 되면 결과적으로 일치하게 된다.
  - 앞에서 언급한 결과적 일관성을 추구하는 것이다.

**API 조합과 CQRS**
- CQRS패턴은 다른 문제를 해결하기도 한다. 마이크로서비스의 저장소가 격리돼 있고 각 마이크로서비스마다 각기 다른 기능을 구현했을 때 여러 개의 마이크로서비스를 연계해서 서비스로 제공하는 경우에는 어떻게 해야 할까?
- 첫 번째 방법은 API 조합(composition)이다. 
  - 예를 들어, '주문 이력' 서비스는 제품 서비스가 제공하는 제품 정보, 주문 서비스의 주문 정보, 고객 서비스의 특정 고객 정보, 배송 서비스의 배송 정보가 모두 다 필요하다.
  - 따라서 각 기능을 제공하는 마이크로서비스를 조합하는 상위 마이크로서비스를 만들어 조합된 기능을 제공할 수 있다.
  - 하위 서비스는 각자 독립적인 API를 제공하면서 연게 API를 위해 상위 서비스에 정보를 제공한다
  - 그렇지만 이러한 구조는 상위 서비스가 하위 서비스에 의존하는 결과를 가져온다.
  - 상위 서비스가 제공하는 API에 정보를 제공하는 하위 서비스 중 하나라도 API를 변경하면 상위 서비스는 그에 따라 변경될 수 밖에 없다.
  - 또한 하위 서비스의 실패가 상위 서비스에 영향을 준다.
  - 이러한 의존성을 줄이기 위한 방법이 필요하다.
- 두 번째 방법은 CQRS를 적용하는 것이다.
  - 주문 이력 서비스를 제공하는 마이크로서비스가 독자적인 저장소를 갖도록 만든다.
  - 또한 주문 이력의 세세한 원천 정보를 보유하고 있는 각각의 서비스도 독자적으로 자신의 저장소를 가지고 서비스를 제공하고 있다.
  - 그리고 이 원천 정보를 보유한 여러 마이크로서비스는 자신의 서비스의 정보가 변경되는 시점에 변경 내역을 각자의 변경 이벤트로 발행한다.
  - 그럼 주문 이력 마이크로서비스에서는 이 이벤트를 구독하고 있다가 이벤트를 가져와서 자신의 서비스의 저장소에 기록함으로써 다른 서비스의 데이터와 데이터 일관성을 맞추고 서비스의 주문 이력 조회 기능으로 제공한다.
  - 이런 경우에는 다른 원천 서비스가 순간적인 장애가 생긴다고 해도 주문 이력 서비스가 영향을 받지 않는다. 
  - 즉, 조회용 마이크로서비스를 별도로 생성하고 다른 서비스로부터 비동기 이벤트로 일관성을 맞춤으로써 API 조합 방식의 단점인 직접적인 의존성을 줄일 수 있다.

**쓰기 최적화: 이벤트 소싱 패턴**
- 사가 패턴 및 CQRS 패턴에서 비즈니스 불일치를 피하기 위해서는 저장소에 저장하는 것과 메시지를 보내는 것이 원자성을 지녀야 한다.
  - 즉, 저장소에 저장하는 일과 메시지를 보내는 작업이 언제나 완전하게 진행되어 함께 실행돼야 한다.
- 그렇지만 객체의 상태 변화를 이벤트 메시지로 발행하고 또 객체 상태를 관계형 데이터베이스에 저장하는 경우 SQL 질의어로 변환해서 처리하기가 매우 번거롭고 까다롭다.
  - 또 메시지 발행과 저장 처리라는 두 가지 기능을 수행하므로 빠르지도 않다.
- 이러한 메시지 발행 및 저장 처리의 원자성을 보장하고 성능도 최적화하는 방법은 무엇일까?
- 보통 비즈니스 처리를 수행할 때 데이터 처리는 항상 처리 상태의 결괏값을 계산하고 데이터의 최종 상태를 확정해서 저장하는 방식으로 진행된다.
  - 예를 들어, 쇼핑몰의 장바구니에 품목을 추가, 삭제하는 과정을 보자.
  - 장바구니, 품목 데이터 모델이 정의돼 있어야 하고 장바구니 상태를 변경할 때 매번 트랜잭션 결과를 반영해서 장바구니 데이터 모델의 결과를 계산해야 한다.
  - 객체의 상태 변화와 데이터 모델의 결과의 변화 양상은 다음과 같다.
  1. 사용자 A의 장바구니 객체 생성 -> 장바구니 테이블에 사용자 A의 장바구니 로우(row)를 생성
  2. 품목 1 객체 추가 -> 품목 테이블에 사용자 A 장바구니의 품목 1을 추가
  3. 품목 2 객체 추가 -> 품목 테이블에 사용자 A 장바구니의 품목 2를 추가
  4. 품목 1 객체 제거 -> 품목 테이블에 사용자 A 장바구니의 품목 1을 삭제
  5. 품목 2 객체의 수량 변경 -> 품목 테이블에 사용자 A 장바구니의 품목 2의 수량 정보를 수정 
  - 이처럼 객체의 상태 변경에 따라 데이터 모델로 처리되고 최종값이 반영돼야 한다.
  - 따라서 이 같은 과정은 복잡해지고 변환 처리로 느릴 수 밖에 없다.
  - 특히 인스턴스가 여러 개로 확장될 때 동시 업데이트 및 교착상태로부터 안전하지 못할 수도 있다.
- 그럼 객체 상태를 데이터 모델에 맞춰 계산하지 않고 상태 트랜잭션 자체를 저장하면 어떨까? 이를 이벤트 소싱 기법이라고 하는데, 트랜잭션 자체를 저장하자는 전략이다.
  - 즉, 상태 변경 이벤트를 계산해서 데이터 모델로 변경하지 않고 바로 이벤트 저장소에 그대로 저장한다.
  - 이렇게 하면 메시지 브로커와 데이터 저장소를 분리하지 않고 하나로 사용할 수 있다.
  - 복잡한 과정이 없으니 쓰기 속도가 훨씬 빠르다.
  - 그럼 현재 시점의 상태가 필요할 때는 어떻게 해야 할까?
  - 상태가 필요하면 상태의 출발점부터 모든 기록된 상태 변경 트랜잭션을 순차적으로 계산한다.
- 처음부터 모든 트랜잭션을 처리하는 것이 부담된다면 매일 자정에 상태를 계산한 후 스냅숏으로 저장한 후 현재 상태 정보가 필요해지면 스냅숏 이후의 트랜잭션만 처리하면 된다.
  - 이 같은 방식은 특정 시점의 상태가 필요하면 재현할 수도 있기 때문에 별도의 트랜잭션성 이력 로그 데이터를 기록할 필요도 없다.
- 또 한가지 중요한 점은 명령 측면과 조회 측면의 서비스가 이벤트 저장소에 대한 CRUD를 모두 처리할 필요 없이 '입력/조회(CR)'만 처리하면 된다는 것이다.
  - 저장소에서 변경과 삭제가 발생하지 않기 때문에 명령 측면의 서비스를 여러 개 확장해도 동시 업데이트 및 교착상태가 발생하지 않는다.

![image](https://user-images.githubusercontent.com/28394879/227130208-a66d5046-fa33-4a93-a513-4d886b928020.png)
- 위 그림은 이벤트 저장소의 데이터 형태예시이다.
- 이벤트 아이디가 있고, 이벤트 타입으로 어떠한 상태인지, 엔티티 타입으로 어떠한 객체의 이벤트인지 ,그리고 변경 내용이 엔티티 데이터 항목에 JSON 형태로 그대로 저장된다.
- JSON은 객체 형태라서 상태 객체가 그대로 들어간 것과 같다.
- 이벤트는 한번 발생한 후에 수정되지 않고 업데이트나 삭제 없이 입력만 되는 개념이라 동시성이나 정합성 등의 문제에 비교적 자유롭다.
- 정리하자면 이벤트 소싱은 모든 트랜잭션의 상태를 바로바로 계산하지 않고 별도의 이벤트 스트림으로 이벤트 스트림 저장소에 저장하는 방식이다.
- 이벤트 스트림 저장소는 오로지 추가만 가능하게끔 해서 계속 이벤트들이 쌓이게 만들고, 실제로 내가 필요한 데이터를 구체화하는 시점에서는 그때까지 축적된 트랜잭션을 바탕으로 상태를 계산해서 구성한다.
- 이벤트 저장소는 이벤트 데이터베이스의 역할뿐 아니라 메시지 브로커처럼 작동한다.
  - 이는 데이터 저장 처리 메커니즘과 메시지 큐 같은 이벤트를 전달하기 위한 메커니즘을 통합해서 복잡성을 줄이고 특히 쓰기 성능을 최적화한다.
  - 또한 상태를 저장하기 때문에 정확한 감사 로깅을 제공하고, 객체의 예전 상태를 재구성하는 것이 간단해지며, 외부 애플리케이션에 이벤트를 전달하는 것도 저장한 이벤트를 그대로 전송하면 되기 떄문에 간편하다.
- 이벤트 스토밍 및 CQRS 구현을 지원하는 프레임워크로 자바 진영에서는 Axon Framework 와 Eventuate 가 주로사용된다.

## 2.5 정리
MSA 아키텍처 흐름과 MSA 아키텍처를 이루는 구성요소와 주요 패턴들을 살펴봤다.

- 현대 애플리케이션 아키텍처에 대해 요구하는 특성을 알아보기 위해 리액티브 선언을 살펴보면 주요 특성으로 응답성, 유연성, 탄력성, 메시지 기반 등이 요구된다. 특히 이러한 요소들은 애플리케이션의 유연성을 강하게 요구한다.
- MSA 아키텍처는 기존의 벤더 중심의 강 결합 아키텍처에서 오픈소스 중심의 느슨한 결합의 아키텍처로 변화할 것을 요구한다.
- MSA 아키텍처는 마이크로서비스 외부의 구성을 위한 외부 아키텍처와 마이크로서비스 내부 정의를 위한 내부 아키텍처로 구성된다.
- MSA 아키텍처 영역의 문제 해결 방식이 다양한 MSA 패턴으로 정의되고 있고, 인프라 구성 요소, 플랫폼 운영 관리 패턴, 애플리케잇녀 연계와 관련된 패턴 등이 존재한다.
- 클라우드 인프라 구성요소로 가상 머신, 컨테이너, 컨테이너 오케스트레이션 등이 고려된다.
- 마이크로서비스의 생태계 발전과 함께 마이크로서비스 운영 관리를 위한 플랫폼 패턴들이 탄생했다.
- 플랫폼 패턴으로 넷플릭스 OSS 기반의 애플리케이션을 활용한 패턴이 최초로 등장, 이를 발전시킨 패턴이 쿠버네티스, 이스티오 등의 기술로 발전하고 있다.
- 마이크로서비스 애플리케이션을 구성하고 연계하기 위해 UI 컴포지트, 통신 패턴, 이벤트 기반 아키텍처 등이 고려된다.
- 저장소 분리 등으로 인한 분산 트랜잭션의 근본적인 문제 등을 해결하기 위해 사가 패턴, CQRS, 이벤트 소싱 패턴 등이 고려된다.

# 3. 마이크로서비스 애플리케이션 아키텍처

## 3.3 마이크로서비스의 내부 구조 정의 

### 3.3.1 바람직한 마이크로서비스의 내부 아키텍처: 클린 마이크로서비스
- 마이크로서비스의 내부 구조를 정의할 때 반드시 고려해야 할 한 가지는 마이크로서비스 시스테멩서 정의해야 할 마이크로서비스의 내부 구조가 다양 할 수 있다는 것이다. 
- 마이크로서비스 아키텍처에서 각 서비스는 각기 목표와 활용도에 따라 명확하게 분리돼야 하고, 각 서비스의 목적에 따라 적절한 개발 언어 및 저장소, 내부 아키텍처를 정의하는것이 바람직앋.
- 조회나 아주 간단한 기능의 경우 헥사고날 아키텍처나 클린 아키텍처 방식의 구조를 고수할 필요는 없다.
- 그렇지만 비즈니스 규칙이 복잡한 서비스는 헥사고날 아키텍처나 클린 아키텍처의 구조를 기반으로 정의하는것이 바람직하다.


- 여러 아키텍처가 지향하는 원칙들을 정리해보자.
  - 지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮추게 해야 한다.
  - 업무 규칙을 정의하는 비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리하기 위해 노력해야 한다.
  - 세부 기술 중심, 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분한다.
  - 고수준 영역은 저수준 영역에 의존하지 않게 해야 하며, 저수준 영역이 고수준 영역에 의존하게 해야 한다.
  - 저수준 영역은 언제든지 교체, 확장 가능해야 하며, 이 같은 변화가 고수준 영역에 영향을 줘서는 안 된다.
  - 자바처럼 인터페이스 및 추상 클래스를 지원하는 언어의 경우 저수준 영역의 구체 클래스가 고수준 영역의 추상 인터페이스에 의존하게 하는 의존성 역전의 원칙을 적용한다.
  - 인터페이스는 고수준의 안정된 영역에 존재해야 하며, 저수준의 어댑터가 이를 구현한다.

### 3.3.2 내부 영역 - 업무 규칙

**트랜잭션 스크립트 패턴**
- 비즈니스 개념을 표현하는 도메인 객체가 행위를 가지고 있지 않다.
- 따라서 모든 비즈니스 행위, 즉 무엇인가를 수행하는 책임은 서비스에 있다.
- 서비스가 비즈니스 절차에 따라 절차적으로 도메인 객체를 이용해 모든 처리를 수행한다.
- 이런 방식에서는 시간이 지남에 따라 서비스가 비대해지고 도메인 객체는 점점 정보 묶음의 역할만 수행하게 될 뿐이다.
- 또한 서비스는 유스케이스 처리의 단위이고 대부분의 비즈니스 로직 처리가 서비스에서 이뤄지므로 비슷한 유스케이스의 경우 서비스에 중복되는 코드가 계속 생겨날 수 있다.
- 이러한 점이 유지보수를 어렵게 할 수 있다.
- 트랜잭션 스크립트 패턴은 절차식 프로그래밍 방식과 같기 때문에 객체지향 지식이 없어도 일반적으로 쉽게 이해할 수 있는 구조이고 기존 데이터베이스 중심 아키텍처에 익숙하다면 더 쉽게 적응할 수 있다.
- 이 패턴은 비즈니스가 간단한 경우에는 쉽게 적용할 수 있다.
- 그렇지만 비즈니스가 복잡해질 경우 서비스 코드의 양이 점점 증가하는 등 데이터베이스 중심 아키텍처에서 겪었던 문제점이 발생할 여지가 크다.
- 따라서 간단한 비즈니스를 처리할 때 적용하는 것이 좋다.

**도메인 모델 패턴**
- 도메인 객체가 데이터뿐만 아니라 비즈니스 행위를 가지고 있으며, 도메인 객체가 소유한 데이터는 도메인 객체가 제공하는 행위에 의해 은닉된다.
- 도메인 객체는 각 비즈니스 개념 및 행위에 대한 책임을 수행하고, 서비스는 비즈니스 유스케이스를 구현하기 위해 서비스의 행위를 도메인 객체에 일부분 위임해서 처리한다
- 서비스의 책임들이 도메인으로 적절히 분산되기 때문에 서비스가 비대해지지 않고 서비스 메서드는 단순해진다.
- 도메인 모델 패턴의 도메인 모델은 객체지향 설계의 객체 모델이다.
- 거대한 서비스 클래스 대신 각기 적절한 책임을 가진 여러 클래스로 구성되므로 이해하기 쉽고 관리 및 테스트하기 쉽다.
- 여기서 더 진화해서 도메인 주도 설계의 애그리거트 패턴을 적용할 수 있는 구조다.
- 핵심은 도메인 모델이기 때문에 객체지향 지식에 대한 경험과 역량이 필요하다.
- 잘 만들어진 도메인 모델은 복잡한 비즈니스 로직을 처리하는 데 유용하며, 잘 정의된 도메인 모델은 코드의 양을 줄이고 재사용성도 높인다.
- 복잡한 비즈니스 로직이 많은 마이크로서비스의 구조로 선택하는 것이 좋다.

**도메인 주도 설계의 애그리거트 패턴**
- 점점 복잡해질 수 있는 객체 모델링의 단점을 보완한 패턴이다.
- 도메인 모델링을 하다 보면 객체 간의 관계를 참조로 표현하게 되는데, 참조로 정의할 경우 일대다 관계의 객체를 쉽게 사용할 수 있다는 장점이 있다.
- 그렇지만 업무가 복잡해지면 참조로 인한 다단계 계층 구조가 생기고 점점 참조 관계가 복잡해지고 무거워질 수 있다.
- 또한 이러한 복잡한 도메인 모델은 모델 내부의 경계가 불명확하다. 
  - 예를 들어, 어떤 도메인 모델이 일대다 관계를 맺고 있고, 다 측에 있는 클래스의 총 개수를 일 측에 있는 클래스에서 집계해야 하는 규칙이 있다고 하자.
  - 서비스에서 이러한 로직을 처리할 때 다측에 클래스가 추가되면 일측의 클래스에서 집계한 값을 수정해야 한다.
  - 그런데 다 측의 클래스만 추가하고 집계한 값을 수정하지 않는다면 비즈니스 일관성이 깨질 것이다.
  - 즉, 도메인 모델이 커짐에 따라 이러한 문제가 복잡해지고 꼬일 수 있다.
- 이를 개선할 방안으로 최상위에 존재하는 엔티티를 중심으로 개념의 집합을 분리한 것이 애그리거트 패턴이다.

![KakaoTalk_Photo_2023-03-31-22-39-31](https://user-images.githubusercontent.com/28394879/229135757-5cc77811-1421-4fe8-b776-03a40dc507d1.jpeg)
- 복잡한 모델을 세 덩어리의 개념으로 분리한 예이다.
- 1개 이상의 엔티티와 값 객체로 구성되는데, 개념적으로 묶인 엔티티의 모음 전체를 애그리거트라고 한다.
- 애그리거트 패턴에서는 애그리거트를 한 단위로 일관되게 처리하기 위해 다음과 같은 규칙을 부여한다.
  - 애그리거트 루트만 참조한다.
  - 애그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해 참조해야 한다. 수정할 때도 마찬가지다.
  - 애그리거트 간의 참조는 객체를 직접 참조하는 대신 기본 키를 사용한다.
  - 기본 키를 사용하면 느슨하게 연관되고 수정이 필요하지 않은 애그리거트를 함꼐 후정하는 실수를 방지한다.
  - 하나의 트랜잭션으로 하나의 애그리거트만 생성 및 수정한다.

## 3.4 정리
- 국내 현장에서 광범위하게 사용되고 있는 데이터베이스 중심 아키텍처는 모든 성능 측면을 데이터베이스에 의존시킴으로써 문제가 있으며, MSA의 장점을 퇴색할 수 있다.
- MSA 외부 아키텍처뿐만 아니라 서비스 내부 구조도 유연하게 구조화하는 것이 필요하며 유연성과 확장성을 지원하는 대표적인 애플리케이션 아키텍처로 레이어드 아키텍처, 헥사고날 아키텍처, 클린 아키텍처가 있따.
- 일반적인 레이어드 아키텍처의 적용은 한계가 있으며, 의존성 역전의 원칙을 활용해 레이어드 아키텍처를 개선할 수 있다.
- 헥사고날 아키텍처를 활용한 마이크로서비스 아키텍처의 내부 구조에서는 외부 영역이 내부 영역에 의존하도록 구성하는 것이 바람직하다.
- 마이크로서비스의 내부 영역을 정의할 때 비즈니스가 단순한 경우에는 트랜잭션 스크립트 패턴을 활용하고, 비즈니스가 복잡한 경우에는 트랜잭션 스크립트 패턴 보다는 도메인 모델 패턴을 적용하는 것이 바람직하다.

# 4. 마이크로서비스와 애자일 개발 프로세스
- 설계를 단순하고 간단하게 하고 바로 개발로 들어간 뒤에 실제로 동작하는 소프트웨어를 보면서 다시 지속적으로 리팩터링하는 방식이 더 효율적이라고 말한다.
- 아재일에는 빨리, 그리고 자주 실패를 경험해 보는 것이 중요하기 떄문에 단순한 설계를 통해 우선 최소한의 실제로 동작하는 제품(MVP)을 만들어 자주 배포하는 것이 중요하다.
- 또한 이러한 과정을 거치면서 각 개발팀에 맞는 최적의 개발 프로세스를 지속적으로 향상 시킬 수 있다.
- 그렇지만 개발 문화가 성숙하지 않은 팀에 이정도의 지침만 준다면 다시 워터폴 방식으로 되돌아갈 수 있고, 마이크로서비스조차 잘 정리되지 않은 채 뒤죽박죽인 스파게티 코드가 될 가능성이 높다.
- 따라서 이렇게 되지 않으려면 기민한 반복 주기에 적합한, 군더더기를 제거하고 핵심 활동에 집중할 수 있는 마이크로서비스 설계 및 개발 방법이 필요하다.

## 4.1 도메인 주도 설계와 마이크로서비스
- 도메인 주도 설계(에릭 에반스)책은 마이크로서비스가 대중화되기 전에 출간됐고, 특별히 마이크로서비스를 위한 책은 아니었다.
- 그러나 이후에 마이크로서비스 개발이 활성화되는 과정에서 DDD가 마이크로서비스의 설계와 개발을 위한 주요 가이드로 주목받았다.
- 특히 마이크로서비스의 애플리케이션 개발 측면, 응집성이 있는 도메인 중심의 마이크로서비스를 도출하는 지침 및 마이크로서비스 내부의 비즈니스 로직 설계의 주요한 가이드로 사용되고 있다.
- 마이크로 서비스 설계 영역에서 빈번히 언급되고, 주요 오픈소스(스프링 부트 등)의 아키텍처도 DDD의 영향을 받아 왔다.
- 따라서 마이크로서비스를 도출하고 내부 구조를 설계하는 데 도메인 주도 설계 기법을 활용하는 것이 효과적이다.
- DDD에는 전략적 설계와 전술적 설계라는 설계 영역이 있다.
- 전략적 설계는 도메인 전문가 및 기술팀이 함께 모여 유비쿼터스 언어를 통해 도메인 지식을 공유 및 이해하고, 이를 기준으로 개념과 경계를 식별해 바운디드 컨텍스트로 정의하고 경계의 관계를 컨텍스트 맵으로 정의하는 활동이다.
- 전술적 설계는 식별된 바운디드 컨텍스트 내의 도메인 개념인 도메인 모델을 구성하는 유용한 모델링 구성요소들을 설명한다.

## 4.2 기민한 설계/개발 프로세스 

### 4.2.1 점진/반복적인 스크럼 생명주기 
- 기본 생명주기는 스크럼의 스프린트를 활용한다.
- 스프린트는 스크럼의 점진, 반복적인 생명주기이며, 보통 1~4주 동안 실행된다.
- 백로그라는 일감 목록을 기반으로 매 스프린트마다 실제로 동작하는 소프트웨어를 시연하고 피드백을 얻는다.
- 팀의 속도에 맞춰 스프린트를 진행하다 보면 일정 내에 완료해야 할 일의 우선순의를 정하는 것이 매우 중요해지고, 이는 가장 우선순위가 높은 시스템의 핵심 기능에 집중할 수 있게 해준다.
- 스프린트는 협업을 진행하기 위한 관리 공정이다.
- 스프린트 내에 설계 및 개발에 대한 공정이 있고, 특이한 점은 스프린트에 들어가기 전의 설계 및 개발을 위한 작업들이 존재한다는 것이다.

### 4.2.2 아키텍처 정의와 마이크로서비스 도출
- 구현 스프린트를 본격적으로 진행하기 위해서는 준비하고 계획하는 활동이 필요하다.  
- 바로 '아키텍처 정의'와 '마이크로서비스 도출'이다.

**아키텍처 정의**  
- 마이크로서비스 외부/내부 아키텍처를 정의하는 공정
- 로버트 C.마틴은 기술 세부사항은 늦게 결정할 수 있어야 한다고 언급한 바 있다.
- 위의 말을 이해해보면, 마이크로서비스를 순수 비즈니스 로직이 존재하는 내부 영역과 기술 영역을 표현하는 외부 영역으로 구분해서 개발하면 외부 영역은 언제든지 교체될 수 있으므로 애플리케이션의 핵심인 내부 영역에 집중하고, 외부 영역, 즉 아키텍처의 결정사항들은 천천히 결정해도 된다는 말이다.
- 유연성을 항상 유지해야 한다는 점을 명심하되 최소한의 개발 및 테스트 환경을 먼저 준비하는 것은 스프린트 진행에 효과적이고 그래야만 곧바로 스프린트에서 실제로 돌아가는 애플리케이션을 시연해볼 수 있다.

**마이크로서비스 도출**  
- 본격적인 마이크로서비스 개발로 들어가기 위한 스크럼 팀이 개발할 전체 마이크로서비스들을 파악하는 작업이다.
- 모든 마이크로서비스를 하나의 스크럼 팀이 개발할 수 없으므로 DDD의 '전략적 설계' 기법을 호라용해 마이크로서비스를 도출하고 그것들 간의 대략적인 매핑 관계를 정의한 후 마이크로서비스 개발 우선순쉬에 근거해 스크럼 팀에 분배해서 스프린트를 진행하게 한다.
- 최종 결과물은 컨텍스트 맵이다.
- 컨텍스트 맵은 식별된 마이크로서비스와 그것들 간의 의존관계를 보여준다.

### 4.2.3 스프린트 내 개발 공정 
- 스프린트 내의 공정을 살펴보면 스크럼 팀 멤버인 백엔드 개발자와 프런트엔드 개발자의 역할대로 공정이 나뉜다.
- 두 영역의 접목은 두 영역 간의 계약인 'API 설계'를 통해 진행되고, 나머지 활동은 각각 내부적으로 진행하게 된다.

**백엔드 설계 및 개발**  
- 백엔드 설계의 시작은 API 설계다.
- API 설계는 각 백엔드 마이크로서비스가 프런트엔드에 제공할 서비스 명세다.
- 초기에 API 설계를 진행해 프런트엔드 영역과 협의 및 조정해야 한다.
- 다음으로 진행할 백엔드 영역의 설계는 정의된 마이크로서비스 내부 구조에 따라 '도메인 모델'과 '데이터 모델'을 설계하는 것이다.
- 도메인 모델을 작성하는 활동을 도메인 모델링이라 한다.
- 이전의 OOAD는 UML 등을 활용해 설계 모델을 작성하고, 이를 소스코드로 변환하는 작업 등을 진행했었지만
  - DDD는 별도의 정형화된 모델을 만들지 않고, 간략히 도메인 모델 등을 화이트보드나 포스트잇 등의 단순한 도구로 작성해서 공유한 후 곧바로 소스코드로 도메인 모델을 개발한다는 것이다.
- 이전의 MDD와 같이 추상적인 모델을 완벽히 만들어 놓고 특정 기술 프로파일이나 프레임워크를 적용해 구체적인 코드를생성해서 모델과 코드가 단절되는 구조였다면
  - DDD의 모델링은 코드 자체가 모델의 기본 표현 방식을 그대로 반영해서 코드로 표현된다.
  - 개발자는 개발 중에 초기에 설계한 개념대로 개발되고 있는지 확인하기 위해 또는 다른 개발자에게 핵심 도메인 모델을 이해시키기 위해 역공학 도구를 이용해 UML 모델로 역공학해서 볼 수 있다.
  - 따라서 DDD의 모델은 코드와 함께 항상 살아 숨쉬게 된다.

**프런트엔드 영역 설계와 개발**  
- 프런트엔드 영역 설계는 UI 레이아웃을 정의하고 백엔드의 API를 호출해서 API가 보내준 데이터를 기반으로 UI에 어떻게 표현할 것인가를 정의하는 활동이다.
- 사용자가 접근하는 채널에 따라 모바일앱, 웹 등의 레이아웃 정의가 다양할 수 있고, 프런트 아키텍처에 따라 설계 수준 및 방식이 모두 다를 수 있다.
- 프런트엔드 영역 설계와 개발의 기본적인 활동 
  - UI 흐름 정의: 비즈니스 흐름에 따른 UI 흐름을 정의, UI 흐름을 설계한 결과물을 UI 스토리보드 라고도 한다
  - UI 레이아웃 정의: 사용자 접점인 사용자 인터페이스를 정의하는 활동. 디자인을 고려하지 않은 사용자 경험을 고려해서 설계한다. ppt, 카카오 옵느 등의 도구가 사용 
  - UI 이벤트 및 액션 정의: UI 레이아웃의 구성요소인 컨트롤을 클릭하거나 터치 등의 행위를 했을 때 발생하는 이벤트 및 액션을 정의하는 활동. 미리 정의된 백엔드 API와의 연계를 정의할 수도 있다.
  - UI 개발: UI 레이아웃 및 이벤트 의도에 맞춰 프런트엔드 애플리케이션을 개발하는 활동, 보통 프런트엔드 아키텍처에서 정의한 UI 프레임워크나 도구를 사용할 수 있다.

**빌드 및 배포**  
- 스크럼 팀의 구성원은 언제라도 현재 진행된 만큼의 실제로 돌아가는 소프트웨어를 확인할 수 있어야 한다.
- 백엔드 및 프런트엔드 개발자는 매일 통합 빌드되고 배포된느 개발 환경에 익숙해져야 한다.
- 따라서 빌드가 안 되거나 배포가 안되는 상황을 방치해서는 안 된다.
- 아키텍처를 정의할 때 빌드 및 배포 파이프라인이 구성된 상태에서 개발자 입장에서 수행해야할 빌드 및 배포를 위한 활동은 다음과 같다.
  - 소스코드 리포지터리 구성: git, github
  - 통합 빌드 잡 구성: 젠킨스, github actions
  - 컨테이너 생성 파일 작성: Dockerfile
  - 배포 스크립트 작성

## 4.3 정리
- 애자일 기반의 마이크로서비스를 위한 개발 프로세스를 살펴봤다.
- 관리 공정으로 반복적이고 점진적인 피드백 기반의 스크럼 생명주기가 있고, 이를 위한 주요 활동으로 스프린트 계획 수립, 시연/회고, 스크럼 미팅 등이 있다.
- 마이크로서비스 개발을 위한 엔지니어링 공정으로 아키텍처 정의, 마이크로서비스 도출, 백엔드/프런트엔드 설계 및 개발, 빌드/배포의 설계와 개발 공정이 있다.

# 5. 마이로서비스 설계 
- 소프트웨어 개발의 역사에서 모듈화의 중요성은 예전이나 지금이나 한곁같다.
- 모듈화의 근본적 가치는 각 모듈을 기능적으로 응집성 높게 만들고, 기능이 다른 타 모듈 간의 의존도를 낮추는 것이다.
- 마찬가지로 마이크로서비스 설계에서의 가장 중요한 관심사도 어떻게 기능적으로 응집성 있는 마이크로서비스를 도출하고 타 서비스 간의 의존도는 낮출 것이다.
- 또한 마이크로서비스의 내부 구조를 구성하는 각 요소들도 역할별로 모듈화돼야 한다.
- 즉, 각 역할이 분명한, 응집성 있고 서로 의존성이 낮은 모듈들이 모여 마이크로서비스를 이루고, 이 마이크로서비스는 다른 마이크로서비스와 의존성이 낮아야 한다는 의미다.
- 다른 방식으로 표현하면 마이크로서비스를 구성하는 각 요소들이 모두 소프트, 즉 유연해야 한다는 말과 같다.
- DDD의 전략적 설계와 전술적 설계가 이를 위한 적절한 가이드를 준다.
- DDD를 중심으로 마이크로서비스를 도출하고 설계하는 방안들을 살펴보자.

## 5.1 마이크로서비스를 도출하는 방법 