- [1. 아마존 비즈니스 민첩성의 비밀](#1-아마존-비즈니스-민첩성의-비밀)
  - [1.1. 성공한 인터넷 기업들과 비즈니스 민첩성](#11-성공한-인터넷-기업들과-비즈니스-민첩성)
    - [1.1.1 성공 사례: 아마존의 배포속도](#111-성공-사례-아마존의-배포속도)
    - [1.1.2 클라우드 인프라의 등장](#112-클라우드-인프라의-등장)
    - [1.1.3 클라우드 인프라에 어울리는 애플리케이션의 조건](#113-클라우드-인프라에-어울리는-애플리케이션의-조건)
      - [스케일 업과 스케일 아웃](#스케일-업과-스케일-아웃)
      - [특정 서비스만 탄력성 있게 확장 (스케일 아웃)](#특정-서비스만-탄력성-있게-확장-스케일-아웃)
      - [클라우드 프렌들리와 클라우드 네이티브](#클라우드-프렌들리와-클라우드-네이티브)
  - [1.2 마이크로서비스란 무엇인가?](#12-마이크로서비스란-무엇인가)
    - [1.2.1 모노리스와 마이크로서비스 비교](#121-모노리스와-마이크로서비스-비교)
    - [1.2.2 SOA와 마이크로서비스](#122-soa와-마이크로서비스)
  - [1.3 마이크로서비스를 위한 조건은 무엇인가?](#13-마이크로서비스를-위한-조건은-무엇인가)
- [2. MSA의 이해](#2-msa의-이해)
  - [2.1 리액티브 선언: 현대 애플리케이션이 갖춰야 할 바람직한 속성들](#21-리액티브-선언-현대-애플리케이션이-갖춰야-할-바람직한-속성들)
    - [소프트웨어 아키텍처](#소프트웨어-아키텍처)
    - [리액티브 선언문](#리액티브-선언문)
  - [2.2 강 결합에서 느슨한 결합의 아키텍처로의 변화](#22-강-결합에서-느슨한-결합의-아키텍처로의-변화)
    - [과거의 아키텍처](#과거의-아키텍처)
    - [최근의 아키텍처](#최근의-아키텍처)
  - [2.3 마이크로서비스의 외부 아키텍처와 내부 아키텍처](#23-마이크로서비스의-외부-아키텍처와-내부-아키텍처)
  - [2.4 MSA 구성요소 및 MSA 패턴](#24-msa-구성요소-및-msa-패턴)
    - [2.4.1 인프라 구성 요소](#241-인프라-구성-요소)
    - [2.4.2 마이크로서비스 운영과 관리를 위한 플랫폼 패턴](#242-마이크로서비스-운영과-관리를-위한-플랫폼-패턴)

# 1. 아마존 비즈니스 민첩성의 비밀

## 1.1. 성공한 인터넷 기업들과 비즈니스 민첩성
- 아마존, 넷플릭스, 우버를 비롯해 성공한 유니콘 기업들의 공통점이 있다면 자신만의 특화된 서비스를 제공하려는 시도를 누구보다 빨리 실행했고 사용자 피드백을 반영해 끊임없이 서비스를 개선한다.
- `비즈니스 민첩성`은 이러한 기업들의 특출난 장점이자 기업 성공의 가장 큰 요인이다. 


### 1.1.1 성공 사례: 아마존의 배포속도 
- 2019년 아마존의 배포속도는 초당 1.5번
- 빠른 배포 주기는 비즈니스의 민첩성을 간접적으로 보여주는 지표라 할 수 있다.

### 1.1.2 클라우드 인프라의 등장

- 클라우드 인프라전에는 
  - `서버실 공사 -> 서버 장비 구입, 네트워크 연결 -> 운영체제 및 S/W 설치` 과정이 필요해서 많은 시간이 소요됐다.
  - 개발 환경을 구축한 뒤 서비스를 개발해 런칭했지만 서비스가 실패로 끝났다면 초기 투입된 인프라 비용을 건질 수 없다.
- 클라우드 인프라가 나온 뒤에는
  - 위에 문제들이 모두 해결됐다.
  - 시스템 인프라를 준비하는데 오랜 시간이 들지 않는다.

### 1.1.3 클라우드 인프라에 어울리는 애플리케이션의 조건
  
- 클라우드 인프라는 사용량에 따라 비용을 유연하게 조절 할 수 있다.
- 필요한 시점에 필요한 만큼만 애플리케이션을 변경해 배포하고 싶다면 클라우드 인프라를 닮으면 된다.
  - 레고처럼 조각 조각이 모여 하나의 큰 덩어리가 되고 쉽게 분리되야 한다.

#### 스케일 업과 스케일 아웃
- 사용량 증가에 따른 성능 및 가용성을 높이는 방법은 스케일 업과 스케일 아웃이 있다.
- 스케일 업: 시스템 자체의 물리적 용량을 증가시켜 성능을 높이는 방법
- 스케일 아웃: 기존 시스템과 용량이 같은 다수의 장비를 병행 추가해서 가용성을 높이는 방법

#### 특정 서비스만 탄력성 있게 확장 (스케일 아웃)
- 1주일 간의 세일 기간 중 정작 바쁜 업무는 세일 이벤트를 수행하는 부분이다. 나머지 부분은 사용자가 몰리지 않아 더 한가해질 수도 있다.
- 세일 이벤트를 담당하는 조각(서버)만 용량이 증설되고 사용량에 따라 복제되어 트래픽에 대비하면 된다.
- 쇼핑몰 세일을 준비하는 운영자의 운영 시나리오
  1. 타임세일 서비스의 용량만 고려해서 증설한다 (스케일 업)
  2. 트래픽이 증가하면 타임세일 서비스 인스턴스만 복제되도록 설정한다 (스케일 아웃)

#### 클라우드 프렌들리와 클라우드 네이티브
- 물론 작은 단위의 서비스 연계로 시스템을 구성하지 않고 전체 시스템을 하나의 덩어리로 만들어 클라우드 인프라에 올려도 비즈니스를 제공하는데 전혀 문제가 없다.
- 그렇지만 특정 기능만 확장하거나 배포할 수 없는 비효율을 감소해야 한다.
- 클라우드 친화 애플리케이션(Cloud Friendly Application): 큰 덩어리로 클라우드 환경에 올라갈 수 있게만 한 애플리케이션
- 클라우드 네이티브 애플리케이션(Cloud Native Application): 독립적으로 분리되어 배포될 수 있는 조각으로 구성된 애플리케이션 
- 아마존은 클라우드 네이티브 애플리케이션으로 구성되어 있다.


## 1.2 마이크로서비스란 무엇인가?

### 1.2.1 모노리스와 마이크로서비스 비교 
- 모노리스
  - 하나위 단위로 개발되는 일체식 애플리케이션
  - 아무리 작은 변화에도 새로운 버전으로 전체를 빌드해서 배포
  - 보통 로드 밸런서를 앞에 두고 여러 인스턴스 위에 큰 덩어리를 복제해 수평으로 확장 -> 작은 변경에도 전부 빌드하고 배포 
  - 확장 시에 애플리케이션은 병렬로 확장되지만, DB는 탄력적으로 대응할 수 없어서 사전에 성능을 감당하기 위해 스케일 업을 통해 용량을 증설해야 함 
- 마이크로서비스
  - 여러 서비스가 별개의 인스턴스로 로딩됨
  - 확장 시에 특정 기능별로 독립적으로 확장 할 수 있음 
  - 각 서비스가 독립적이어서 서로 다른 언어로 개발 가능
  - 각 서비스의 소유권을 분리해서 서로 다른 팀이 개발 및 운영 가능 

### 1.2.2 SOA와 마이크로서비스

- SOA: 컴포넌트를 모아 비즈니스적으로 의미 있고 완결적인 서비스 단위로 모듈화
- 넓게보면 여러 개의 응집된 비즈니스 서비스의 집합으로 시스템을 개발한다는 점에서 MSA와 개념적으로는 큰 차이 없음
- 그러나 SOA는 구체적이지 않고 이론적이며, 실제 비즈니스 성공 사례가 많지 않았음.
- 반면 MSA는 클라우드 인프라 기술의 발전과 접목되어 아마존, 넷플릭스에 의해 구체화되고 성공 사례가 널리 공유됨.
- 즉, 이상적이었지만 성공을 증명하지 못했던 SOA가 클라우드 인프라의 등장으로 하드웨어를 유연하게 다룰 수 있게 되면서 실현되어 성공적으로 증명된 시스템 구조가 MSA이다.
- 폴리그랏(Polyglot): 특정 서비스를 구축하는 데 사용되는 언어나 저장소를 자율적으로 선택할 수 있는 방식
- SOA에서는 애플리케이션은 모듈로 분리했으나 데이터 저장소까지는 분리하지 못했고, 데이터의 강한 결합으로 애플리케이션도 독립적으로 사용하기 힘들었음.


## 1.3 마이크로서비스를 위한 조건은 무엇인가?

- 마이크로서비스에서는 비즈니스 처리를 위해 일부 데이터의 복제와 중복 허용이 필요하다.
- 각 마이크로서비스의 저장소에 담긴 데이터의 비즈니스 정합성을 맞춰야 하는 데이터 일관성 문제이다.
- 데이터 일관성 처리를 위해서는 보통 2단계 커밋 같은 분산 트랜잭션 기법을 사용하는데, 다른 서비스를 하나의 트랜잭션으로 묶다 보면 각 서비스의 독립성도 침해되고 NOSQL 같은 저장소는 2단계 커밋을 지원하지 않는다.
- 따라서 마이크로서비스는 데이터 일관성 문제를 해결하기 위해 두 서비스를 단일 트랜잭션으로 묶는 방법이 아닌 비동기 이벤트 처리를 통한 협업을 강조한다.
- 이를 가리켜 결과적 일관성(Eventual Consistency)이라는 개념으로 표현하기도 한다.
- 간단히 말하면 두 서비스의 데이터가 일시적으로 불일치하는 시점에 있고 일관성이 없는 상태지만 결국에는 두 데이터가 같아진다는 개념이다.
- 별도의 로컬 트랜잭션을 각각 수행하고 일관성이 달라진 부분은 체크해서 보상 트랜잭션으로 일관성을 맞추는 개념이다.

**주문 배송 서비스 예시**
- 주문이 발생하면 배송 처리가 돼야 하는 비즈니스

1. 주문 서비스가 주문 처리 트랜잭션을 수행
   1. 동시에 주문 이벤트를 발행
   2. 주문 이벤트가 메시지 큐로 전송
   3. 배송 서비스가 주문 이벤트를 인식
2. 배송 서비스가 주문 처리에 맞는 배송 처리 트랜잭션을 수행 (비즈니스 일관성 만족)
3. 배송 처리 트랜잭션 중 오류로 트랜잭션을 실패
   1. 배송 처리 실패 이벤트를 발행
   2. 배송 처리 실패 이벤트가 메시지 큐로 전송
   3. 주문 서비스가 배송 처리 실패 이벤트를 인식 
4. 주문 서비스는 주문 취소(보상 트랜잭션)을 추생 (비즈니스 일관성 만족)

서킷브레이커: 각 서비스를 모니터링하고 있다가 한 서비스가 다운되거나 실패하면 이를 호출하는 서비스의 연계를 차단하고 적절하게 대응

# 2. MSA의 이해

- 모노리스에서 마이크로서비스 시스템으로 변화함에 따라 발생하는 문제점들을 해결하기 위해 등장했던 MSA 패턴들을 살펴보자.

## 2.1 리액티브 선언: 현대 애플리케이션이 갖춰야 할 바람직한 속성들

### 소프트웨어 아키텍처
- 소프트웨어를 구성하는 요소와 그 구성요소 간의 관게를 정의
- 아키텍처를 정의하는 과정: 비기능 요건(성능, 가용성, 보안, 유지보수성, 확장성 등)을 만족하는 다양한 해결 방법을 찾는 과정 

### 리액티브 선언문
- 리액티브 선언문: 사람들이 스마트폰, 데스크톱 애플리케이션 등 여러 기기에 포함된 애플리케이션이 요청에 즉각 응답하고 항상 가동되길 기대하는 것을 잘 표현한 문서
- 리액티브 시스템: 응답성, 탄력성, 유연성, 메시지 기반(Message Driven) 4가지 특성을 강조하고, 이러한 요건을 만족하는 시스템
  - 응답성: 사용자에게 신뢰성 있는 응답을 빠르고 적절하게 제공
  - 탄력성: 장애가 발생하거나 부분적으로 고장 나더라도 시스템 전체가 고장 나지 않고 빠르게 복구하는 능력
  - 유연성: 사용량에 변화가 있더라도 균일한 응답성을 제공, 사용량에 비례해서 자원을 늘리거나 줄이는 능력
  - 메시지 기반: 비동기 메시지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향
- 아키텍처 유연성
  - 리액티브 시스템이 반드시 갖춰야 할 공통적인 특성
  - 시스템을 구성하는 구성요소 간의 관계들이 느슨하게 맺어져 있어 언제든지 대체되거나 추가 확장될 수 있는 특성 
  - 위의 4가지 요소 중에서 '메시지 기반'이라는 요소가 아키텍처 유연성을 만족시키는 요소이다.
  - 메시지 기반 특성은 이후에 살펴볼 마이크로서비스 아키텍처에서도 마이크로서비스 간의 의존성을 줄이는 중요한 특성이 된다.

## 2.2 강 결합에서 느슨한 결합의 아키텍처로의 변화

### 과거의 아키텍처
- 아키텍처 구성요소들을 각 기업이나 특정 벤더의 제품에 전적으로 의존해서 구축하거나 수정이 필요한 부분만 별도로 직접 개발하는 경우가 많았다.
- 특정 벤더 솔루션이나 프레임워크가 변경될 경우 그것에 의존하는 애플리케이션의 많은 부분들을 변경해야 할 정도로 강 결합돼 있었다.
- 검증된 유명 제품군을 사용한다는 점에서 품질이 보장된다고 생각할 수 있는 반면, 특정 기술에 락인되어 쉽게 변경되거나 확장하지 못한다는 단점이 있다.

### 최근의 아키텍처
- 최근에 분위기를 바꿔 하나의 벤더에 의존하거나 직접 구출할 필요가 적어졌다.
  - 왜냐하면 클라우드 환경에서 사용되는 오픈소스 또는 오픈소스를 기반으로 한 상용 제품들이 이전의 유명 벤더의 제품군 만큼이나 품질이 높아지고 다양한 기능을 지원하면서 서로 다른 오픈소스 제품간에도 호환성이 높아졌기 때문이다.
- 이러한 흐름은 아키텍처 설계 활동에도 변화를 가져왔다.
  - 예전에는 검증된 기술이나 솔루션을 기반으로 기술을 직접 구현하는 폐쇄적인 방식
  - 최근의 아키텍처 설계는 필요한 영역에 적절한 솔루션을 선택하고 조합하는 개방적인 방식으로 바뀜 

## 2.3 마이크로서비스의 외부 아키텍처와 내부 아키텍처

![KakaoTalk_Photo_2023-01-11-12-29-35](https://user-images.githubusercontent.com/28394879/211711352-af7feceb-86d2-4995-b5f4-2af0cf24175a.jpeg)
- 밑에서부터 인프라, 플랫폼, 애플리테이션 영역으로 구분
- 각 관계
  - 맨 아래에 기반이 되는 하드웨어 인프라 
  - 인프라 영역위에 애플리케이션을 운영 및 구동하기 위한 플랫폼
  - 플랫폼 위에 애플리케이션인 서비스가 구독 
- MSA 외부 아키텍처
  - 인프라 영역과 플랫폼 영역, 애플리케이션 영역에 있는 구성 요소 및 그것들의 관계를 정의
  - 마이크로서비스가 운영되는 환경을 정의
  - 인프라 환경, 플랫폼 환경, 마이크로서비스가 운영되는 애플리케이션 환경이 모두 포함, 특히 애플리케이션 측면에서는 여러 개의 마이크로서비스를 관리하고 운영하기 위한 애플리케이션도 모두 포함
  - 이러한 환경을 클라우드 아키텍처가 요구하는 유연성과 확장성을 고려해서 정의해야 함
- MSA 내부 아키텍처
  - 실제로 비즈니스가 실행되는 비즈니스 애플리케이션, 즉 각 MSA의 내부 구조를 정의
  - MSA가 제공하는 API, 비즈니스 로직, 이벤트 발행, 데이터 저장 처리 등을 어떻게 구조화해야 하는가에 대한 내용 
  - 당연히 이 구조도 변화에 적응 가능하도록 유연하고 확장성 있게 구현해야 함

## 2.4 MSA 구성요소 및 MSA 패턴

- 아키텍처 스타일 또는 아키텍처 패턴이란?
  - 어떤 문제 영역에 대해 여러 사람들에 의해 검증되어 정리된 유용한 해법
- 마이크로 서비스 아키텍처에도 아키텍처 패턴이 있다.
  - 크리스 리처드슨은 MSA 아키텍처 패턴을 인프라 패턴, 애플리케이션 인프라 패턴, 애플리케이션 패턴 등으로 분류해서 정의했다.

| 패턴 유형 | 설명 |
| --- | --- |
| 인프라 구성요소 | 마이크로서비스를 지탱하는 하부구조 인프라를 구축하는데 필요한 구성요소 |
| 플랫폼 패턴 | 인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴 |
| 애플리케이션 패턴 | 마이크로서비스 애플리케이션을 구성하는 데 필요한 패턴 |


### 2.4.1 인프라 구성 요소

- 인프라: 하드웨어, 소프트웨어, 네트워킹 구성요소, 운영체제, 데이터 스토리지 등 
- 클라우드 환경에서는 위 인프라 구성요소가 가상화되어 제공됨.
- 각 유형을 살펴보자.

**퍼블릿 클라우드와 베어 메탈, 프라이빗 클라우드 환경**  
- IaaS PaaS 서비스를 통해 시스템의 구성, 할당, 관리, 모니터링 등이 설정 작업을 몇번의 버튼 클릭만으로 처리할 수 있다.
- 위 같은 환경에서 아키텍트가 해야 할일은 
  - 맨 하부의 시스템의 기반이 되는 인프라 구축 
  - 기존의 물리적인 베어 메탈 장비를 구매해서 구축 할지, 가상화 환경을 선택해서 이용할지 를 고민
  - 클라우드 사업자가 서비스로 제공하는 퍼블릭 IaaS, PaaS를 선택할지 또는 직접 구매하거나 기존의 보유한 베어 메탈 서버에 프라이빗 PaaS를 구축할지 고민
- 마이크로 서비스는 어떠한 장비에도 구동될 수 있다.
  - 특정 인프라를 고집할 필요는 없다.
  - 그렇지만 가상화 장치 없이 베어 메탈 장비로 구동하는것은 쉽지 않다.
  - 따라서 가상 인프라 환경을 검토할 필요가 있다.
- 예전에는 인프라 선택이 소프트웨어 구성요소에 영향을 끼쳤지만 요즘은 어떤 것을 선택하든 다른 아키텍처 요소와 유연하게 결합할 수 있어 크게 신경 안써도 된다.
  - 모든 소프트웨어들이 상호 독립적이고 서로 호환되도록 유연한 구조로 만들어졌기 때문 
  - 이처럼 유연성이 클라우드 기반 소프트웨어의 필수 요소로 자리 잡고 있는 것이 추세이다.

**VM과 컨테이너**
- 가상 인프라 환경을 활용하기로 선택하면 그다음으로 가장 먼저 고민해야 할 사항은 가상머신 vs 컨테이너 기반을 선택하는 것이다.
- 가상머신은
  - 하이퍼바이저라는 소프트웨어를 이용해 하나의 시스템에서 여러 개의 운영체제를 사용하는 기술
  - 운영체제 패치 설치나 관련 라이브러리 설치 같은 오버헤드가 지속적으로 발생 (게스트OS 사용)
- 컨테이너는
  - 하이퍼바이저 없이 컨테이너 엔진을 사용해 가상의 격리된 공간을 생성
  - 마이크로 서비스 같은 작은 서비스를 패키지하고 배포하기에 적합하다(게스트 OS 사용 X)
  - 대표적으로 도커를 많이 사용
  - 컨테이너 이미지 레이어 (기반 이미지 -> 이미지 레이어 1[운영체제] -> 이미지 레이어2[런타임] -> 이미지 레이어3[애플리케이션])
- 도커 컨테이너의 이점은
  - 이식성: 호스트 커널이나 플랫폼 버전에 상관없이 사용 가능하며 동일하게 동작
  - 신속성: 크기가 작고 가볍기 때문에 빠르게 배포 가능, 문제 발생 시 수정 없이 새로 기동하면 됨 
  - 재사용성: 동일한 환경을 재사용해서 쉽게 설정 가능하기 떄문에 개발, 테스트, 스테이징, 프로덕션 환경을 동일한 환경으로 구축하기 쉬움 
- 마이크로서비스가 가변적이고 유연한 속성을 컨테이너가 쉽고 빠르게 지원할 수 있다.

**컨테이너 오케스트레이션**
- 컨테이너 기술을 선택했다면 컨테이너를 관리하기 위한 기술 또한 필요 
- 컨테이너가 많아지면 컨테이너의 자동 배치 및 복제, 장애 복구, 확장 및 축소, 컨테이너 간 통신, 로드 밸런싱 등의 컨테이너 관리를 위한 기능이 필요해짐
- 이러한 기술을 컨테이너 오케스트레이션이라 한다.
- 도커 스웜, 아파치 메소스, 쿠버네티스 등이 있다.
- 쿠버네티스는 다음과 같은 주요 기능을 제공한다.
  - 자동화된 자원 배정: 각 컨테이너가 필요로 하는 CPU와 메모리를 쿠버네티스에 요청하면 컨테이너를 노드에 맞춰 자동으로 배치
  - 셀프 치유: health check해서 실패한 경우 자동으로 교체하고 재스케줄링 
  - 수평 확장: 일정 CPU 및 메모리 사용량을 초과하면 자동으로 확장 

**서비스 유형별 대표적인 클라우드 서비스**
- IaaS
  - 가상 머신, 스토리지 네트워크 같은 인프라를 필요한 만큼 적시에 제공하는 서비스
  - 사용자는 이러한 인프라를 이용해 개발 환경을 구성한 후 애플리케이션을 배포 
  - 가상 서버, 가상 네트워크, 가상 스토리지라 생각하면 쉽다.
  - ex) AWS EC2, Azure VM
- CaaS
  - 컨테이너 기반 가상화를 사용해 컨테이너를 업로드, 구성, 실행, 확장, 중지할 수 있는 서비스 
  - 애플리케이션을 바로 구동할 수 있는 환경을 제공한다는 점에서 PaaS와 유사 하지만, 다른 환경에도 이식 가능한 컨테이너 기반 가상화를 제공한다는 점에서 다름
  - ex) AKS, EKS, GKE, ECS
- PaaS
  - 복잡함 없이 애플리케이션을 곧바로 개발, 실행, 관리할 수 있는 플랫폼 환경을 서비스 형태로 제공
  - IaaS 위에 실제로 애플리케이션이 실행될 수 있는 미들웨어나 런타임까지 탑재된 환경
  - ex) Azure Web App, Google App Engine, AWS Elastic Beanstalk

### 2.4.2 마이크로서비스 운영과 관리를 위한 플랫폼 패턴 
- 지금까지는 MSA를 적재하기 위한 기반이 되는 클라우드 인프라 요소를 살펴봄.
- 다음으로 MSA의 원활한 동작을 지원하는 플랫폼 환경을 살펴보자.
- 애플리케이션이 실제로 구동되는 인프라 환경을 결정했다면 그 다음으로 선택한 인프라 환경 위에서 애플리케이션을 운영하고 관리하는 환경을 구성하는 방법을 생각해야 됨.
- 특히 애플리케이션을 빌드하고 인프라에 배로할 수 있는 환경이 중요함.

**개발 지원 환경: 데브옵스 인프라 구성**
- 그래서 필요한 요소가 마이크로서비스를 빌드하고 테스트한 뒤 배포할 수 있게 도와주는 개발 지원 환경인 데브옵스 환경이다.
- 개발과 운영을 병행 가능하게끔 높은 품질로 소프트웨어를 빠르게 개발하도록 지원하는 빌드, 테스트, 배포를 위한 자동화 환경을 말함.
- 수동 배포 절차
  1. 컴파일, 수동 테스트 오류수정 
  2. 수동 테스트 오류 수정 
  3. 배포 승인 
  4. 운영 환경에 야간 수동 배포 
- 이러한 수동 빌드/배포 과정에는 정말 많은 시간이 소요됨
- 여러 개의 마이크로서비스를 배포해야 하는 환경에서는 배포가 잦을 수 밖에 없기 때문에 자동화가 절실하다.
- 자동화된 빌드나 배포 작업을 보통 CI/CD라고 한다.
  - CI: 지속적 통합, 자동으로 통합 및 테스트하고 그 결과를 리포트로 기록하는 활동
  - CD: 지속적 배포, 실행 환경에 내보내는 활동

**빌드/배포 파이프라인 설계**
- 빌드/배포되는 과정 동안 수행해야 할 태스크가 정의된 것을 빌드/배포 파이프라인이라고 한다.
- 빌드/배포 파이프라인은 통합 및 배포까지 이어지는 일련의 프로세스를 하나로 연계해서 자동화하고 시각화된 절차로 구축하는 것을 말함
- 배포 파이프 라인 절차
  - 리포지토리 -> 빌드 & 유닛 테스트 -> 정적 분석 -> 통합 테스트 -> 배포 -> 마이크로 서비스 
  - 여기에 UI 테스트, 통합 테스트, 배포 승인 프로세스 등을 추가해서 재설계 할 수도 있다.
- Infrastructure as Code
  - 인프라 구성을 마치 프로그래밍하는 것처럼 처리하고 소수의 인원으로 많은 컨테이너 배포 처리를 할 수 있게 된것을 의미
  - 이것으로 배포 파이프라인 절차를 완벽하게 자동화 할 수 있으며, 대규모 인프라 관리를 수행할 수 있고, 코드이기 떄문에 쉽게 공유 및 재사용이 가능 

**마이크로서비스 생태계와 운영 관리 요소의 탄생**
- AWS의 클라우드 환경, 도커 컨테이너, 넷플리긋가 공유한 오픈소스, 스프링 프레임워크, 구글의 쿠버네티스 같은 것들이 MSA 생태계의 발전을 계속 이끌음.
- 이러한 과정을 거쳐 MSA 아키텍처의 주요 문제 영역들이 논의되고 그에 대한 해결책이 제새돼 왔음. 

**경험으로 획득한 지혜: 마이크로서비스 관리/운영 패턴**
- API 게이트웨이, 서비스 디스커버리, 모니터링, 트레이싱 등 다수의 마이크로서비스를 관리 및 운영하기 위한 플랫폼 패턴으로서 넷플릭스에서 소스를 공개하고 나서 패턴으로 정착되고
- 나중에 이러한 패턴을 적용한 다른 여러 도구와 오픈소스들이 생겨나는 밑거름으로 작용했다.
- 또한 넷플릭스 OSS를 더 쉽게 쓸 수 있도록 넷플릭스 OSS 모듈들을 스프링 프레임워크로 감싸서 스프링 클라우드라는 명칭으로 발표했다. 

**스프링 클라우드: 스프링 부트 + 스프링 OSS**
- 넷플릭스가 공개한 줄, 유레카, 히스트릭스, 리본 등의 넷플릭스 오픈소스를 스프링 부트 프레임워크 기반으로 사용하기 쉽게 통합한 것
- 예시로 비즈니스를 구현한 마이크로서비스 서비스와 스프링 클라우드 서비스의 연계 흐름 요약
  1. 모든 마이크로서비스는 인프라에 종속되지 않도록 DB, 파일 등에 저장된 환경 설정 정보를 형상관리 시스템에 연계된 `Config 서비스`에서 가져와 설정 정보를 주입한 후 클라우드 인프라의 개별 인스턴스로 로딩
  2. 로딩과 동시에 `서비스 레지스트리`에 자신의 서비스명과 클라우드 인프라부터 할당받은 물리 주소를 매핑해서 등록
  3. 클라이언트가 `API 게이트웨이`를 통해 마이크로서비스에 접근하고, 이 때 API 게이트웨이는 적절한 라우팅 및 부하 관리를 위해 로드 밸런싱을 수행
  4. 또한 API 게이트웨이에서 클라이언트가 마이크로서비스에 접근하기 위한 주소를 알기 위해 `서비스 레지스트리` 검색을 통해 서비스의 위치를 가져옴
  5. 동시에 API 게이트웨이는 클라이언트가 각 서비스에 접근할 수 있는 권한이 있는지 `권한 서비스` 와 연계해 인증/인가 처리를 수행 
  6. 이러한 모든 마이크로서비스 간의 호출 흐름은 `모니터링 서비스`와 `추적 서비스`에 의해 모니터링되고 추적된다
- 스프링 클라우드 외에 각 클라우드 제공 업체의 플랫폼에도 유사한 형태의 서비스로 각기 존재한다. 

**다양한 서비스의 등록 및 탐색을 위한 서비스 레지스트리, 서비스 디스커버리 패턴**
- 서비스 디스커버리 패턴의 탄생
  - 프론트엔드 클라이언트가 여러 개의 백엔드 마이크로서비스를 어떻게 호출해야 할까? 
  - 또한 스케일 아웃을 통해 인스턴스가 여러 개로 복제됐다면 어떻게 부하를 적절히 분산할 수 있을까?
  - 위의 질문을 위한 패턴이 서비스 디스커버리 패턴이다.
- 클라이언트가 여러 개의 마이크로서비스를 호출하기 위해서는 최적 경로를 찾아주는 라우팅 기능과 적절한 부하 분산을 위한 로드 밸런싱 기능이 제공돼야 한다.
  - 줄(Zuul): 라우팅 기능 담당
  - 리본(Ribbon): 로드 밸런싱 담당
- 라우터는 최적 경로를 탐색하기 위해 서비스 명칭에 해당하는 IP 주소를 알아야 한다.
  - 그런데 이러한 라우팅 정보를 클라이언트가 가지고 있으면 클라우드 환경에서 동적으로 변경되는 백엔드의 유동 IP 정보를 매번 전송받아 변경해야 한다.
  - 따라서 제3의 공간에서 이러한 정보를 관리하는 것이 좋다.
  - 즉, 백엔드 마이크로서비스 서비스의 명칭과 유동적인 IP 정보를 매핑해서 보관할 저장소가 필요하다.
  - 넷플릭스 유레카(Eureka)가 그 기능을 담당하고, 이러한 패턴을 서비스 레지스트리 패턴이라 한다.

![IMG_1787 (1)](https://user-images.githubusercontent.com/28394879/224304488-109c5220-25e6-4ad5-ab8a-7c54f2903105.jpg)
- 각 서비스 인스턴스가 로딩 될 떄 자신의 서비스 이름과 할당된 IP 주소를 레지스트리 서비스에 등록한다
  - 그런 다음, 클라이언트가 해당 서비스명을 호출할 때 라우터가 레지스트리 서비스를 검색해 해당 서비스의 이름과 매핑된 IP 저옵를 확인한 후 호출한다.
  - 이 레지스트리 서비스는 모든 마이크로서비스의 인스턴스의 주소를 알고 있는 서비스 매핑 저장소가 된다.
  - 모든 마이크로서비스가 처음 기동할 때 자신의 위치 정보를 저장하고, 서비스가 종료될 때 위치 정보가 삭제된다.
- 쿠버네티스에서는 DNS 및 서비스(Kubernetes Service)로 제공한다. 

**서비스 단일 진입을 위한 API 게이트웨이 패턴**