
# 1. 리액트 입문 

## 1. 리액트는 어쩌다가 만들어졌을까?
- 리액트라는 라이브러리가 어쩌다 만들어졌는지 부터 살펴보자.
- JS + HTML 로 구성한 UI에선, DOM을 변형시키기 위해서는 DOM Selector API를 사용해서 특정 DOM을 선택한 뒤, 특정 이벤트가 발생하면 변화를 준다.
- 사용자와의 인터랙션이 별로 없는 웹페이지라면 상관없겠지만, 만약에 인터랙션이 자주 ㅂ라생하고, 이에 따라 동적으로 UI를 표현해야하면, 규칙이 다양해지고 관리도 힘들어진다.
- 대부분의 웹 애플리케이션의 규모가 커지면, DOM을 직접 건드리면서 작업을 하면 코드가 난잡해지기 쉽다.
- 그래서 Ember, Backbone, AngularJS 등의 프레임워크가 만들어졌었는데, 이 프레임워크들은 쉽게 설명하면 JS의 특정 값이 바뀌면 DOM의 속성이 바뀌도록 연결을 해주어서, 업데이트 하는 작업을 간소화해주는 방식으로 웹개발의 어려움을 해결해주었다.
- 하지만 리액트는 어떠한 상태가 바뀌었을 때, 그 상태에 따라 DOM을 어떻게 업데이트 할 지 규칙을 정하는 게 아니라, 아예 다 날려버리고 처음부터 모든걸 새로 만들어서 보여준다 라는 아이디어로 시작됐다.
- 동적인 UI를 보여주기 위해서 모든걸 다 날려버리고 모든걸 새로 만들면 속도가 굉장히 느리고, 규모가 큰 웹애플리케이션이라면 상상하기 힘들다.
- 하지만 리액트에서는 Virtual DOM이라는 것을 사용해서 이를 가능하게 했다.
- Virtual DOM은 가상의 DOM이고, 가상으로 존재하는 DOM으로서 그냥 JS 객체이기 떄문에 작동 성능이 실제로 브라우저에서 DOM을 보여주는 것보다 속도가 훨씬 빠르다.
- 리액트는 상태가 업데이트 되면, 업데이트가 필요한 곳의 UI 를 Virtual DOM을 통해서 렌더링한다.
- 그리고 나서 리액트 개발팀이 만든 매우 효율적인 비교 알고리즘을 통해 실제 브라우저에 보여지고 잇는 DOM과 비교 한 후, 차이가 있는 곳을 감지해서 DOM에 패치시켜준다.
- 이를 통해서 "업데이트를 어떻게 할 지"에 대한 고민을 하지 않으면서 빠른 성능도 지켜낼 수 있었다.

## 2. 작업환경 준비 
- Node.js
  - Webpack 과 Babel 같은 도구들이 js 런타임인 Node.js 기반으로 만들어져있어서 설치 필요.
- Yarn
  - npm의 개선된 버전. 
  - npm은 Node.js를 설치할 때 같이 딸려오는 패키지 매니저 도구. 
  - 프로젝트에서 사용되는 라이브러리를 설치하고 해당 라이브러리들의 버전 관리 할 때 사용. 
  - Yarn을 사용하는 이유는, 더 나은 속도와 더 나은 캐싱 시스템을 사용하기 위함.
- Webpack, Babel
  - 리액트를 사용하면서 컴포넌트를 여러가지 파일로 분리해서 저장하는데, 이 컴포넌트는 일반 자바스크립트가 아닌 JSX 라는 문법으로 작성하게 된다. 
  - 여러가지의 파일을 한개로 결합하기 위해서 Webpack 이라는 도구를 사용한다.
  - JSX를 비롯한 새로운 자바스크립트 문법들을 사용하기 위해 Babel 이라는 도구를 사용한다.

Node.js 설치
```
$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
$ nvm install --lts
``` 

Yarn 설치
```
brew install yarn
```

새 프로젝트 만들어보기
```
npx create-react-app begin-react
cd begin-react
yarn start
```

## 3. 나의 첫번째 리액트 컴포넌트
- 리액트 컴포넌트를 만들 땐 아래 코드를 통해 리액트를 불러와야 한다.
```js
import React from 'react';
```

- 리액트 컴포넌트에서 XML 형식의 값을 반환해줄 수 있는데 이를 JSX라고 부른다. 
- 아래 코드는 Hello 라는 컴포넌트를 내보내겠다는 의미이다.
```js
export default Hello;
```

- 컴포넌트는 일종의 UI 조각이고, 쉽게 재사용할 수 있다. 
- 실제 DOM 내부에 리액트 컴포넌트를 렌더링한다.
- 리액트 컴포넌트가 렌더링 될 때에는, 렌더링된 결과물 위 div 내부에 렌더링되는 것이다.


## 4. JSX

- 리액트 컴포넌트 파일에서 XML 형태로 코드를 작성하면 babel이 JSX를 js로 변환해준다.
- Babel은 js의 문법을 확장해주는 도구이고, 아직 지원되지 않는 최신 문법이나, 편의상 사용하거나 실험적인 js 문법들을 정식 js 형태로 변환해줌으로써 구형 브라우저에서도 제대로 실행할 수 있게 해줌.
- JSX가 js로 제대로 변환 되려면 지켜줘야하는 규칙이 몇가지 있다.
  - 태그는 꼭 닫혀야 한다.
  - 두가지 이상의 태그는 무조건 하나의 태그로 감싸져있어야 함.
  - JSX안에 js 값 사용하려면 {}로 감싸줘야함.
  - CSS class를 설정할 땐 `class=` 가 아닌 `className=` 으로 설정해줘야 한다.
  - 주석은 {/* */}, // 으로 사용한다.

## 5. props 를 통해 컴포넌트에게 값 전달하기 
- props는 properties의 줄임말.
- 어떠한 값을 컴포넌트에게 전달해줘야 할 때 사용함.

- props의 기본 사용법
- 여러 개의 props, 비구조화 할당
- defaultProps로 기본값 설정
- props.children

## 6. 조건부 렌더링
- 특정 조건에 따라 다른 결과물을 렌더링 하는 것을 의미
- JSX에서 null, false, undefined를 렌더링하면 아무것도 나타나지 않는다.
- 보통 삼항연산자를 사용해서 조건부 렌더링을 처리한다.
- props 값 설정을 생략하면 ={true} 이다

## 7. useState 를 통해 컴포넌트에서 바뀌는 값 관리하기
- 리액트 16.8 이전 버전에서는 함수형 컴포넌트에서는 상태관리할 수 없었다.
- 리액트 16.8에서 Hooks라는 기능이 도입되면서 함수형 컴포넌트에서도 상태를 관리할 수 있게 됐다.
- useState라는 함수가 리액트의 Hooks 중 하나이다.
- 함수형 업데이트는 주로 컴포넌트 최적화를 하게 될 때 사용하게 된다. 

## 8. input 상태 관리하기 
- 이번에도, useState를 사용
- 이번에는 input의 `onChange` 라는 이벤트를 사용.
- 이벤트에 등록하는 함수에서 이벤트 객체를 `e`를 파라미터로 받아와서 사용 하는데
  - 이 객체의 `e.target`은 이벤트가 발생한 DOM 인 input DOM
  - `e.tar.value`는 이 DOM의 `value` 값, 이값을 조회하면 현재 input에 입력한 값이 무엇인지 알 수 있음 

## 9. 여러개의 input 상태 관리하기 
- input이 비어져있을 때 인풋에 대한 설명을 보여주는 `placeholder` 값도 설정해보자.
- input의 개수가 여러개가 됐을 때, 단순히 `useState`를 여러번 사용하고 `onChange`도 여러개 만들어서 구현할 수 있다.
- 하지만 가장 좋은 방법은 아니다.
- 더 좋은 방법은 input에 `name`을 설정하고 이벤트가 발생했을 때 이 값을 참조하는 것이다.
- 그리고 `useState`에서는 문자열이 아니라 객체 형태의 상태를 관리해줘야 한다.
- ``...inputs` 에서 `...` 문법은 spread 문법이다. 객체의 내용을 모두 펼쳐서 기존 객체를 복사해줌.
- 리액트 상태에서 객체를 수정할 때에는 직접 수정하면 안되고, 새로운 객체를 만들어서 새로운 객체에 변화를 주고, 이를 상태로 사용해 주어야한다.
  - 이러한 작업을 "불변성을 지킨다"라고 한다.
  - 불변성을 지켜주어야만 리액트 컴포넌트에서 상태가 업데이트가 됐음을 감지할 수 있고 
  - 이에 따라 필요한 리렌더링이 진행된다.
  - 만약 `inputs[name] = value` 이런식으로 기존 상태를 직접 수정하게 되면, 값을 바꿔도 리렌더링이 되지 않는다.
  - 추가적으로 리액트에서는 불변성을 지켜주어야만 컴포넌트 업데이트 성능 최적화를 제대로 할 수 있다. 

## 10. useRef 로 특정 DOM 선택하기
- js를 사용하면, 우리가 특정 DOM을 선택해야 하는 상황에 `getElementById`, `querySelector` 같은 DOM Selector 함수를 사용해서 DOM을 선택한다.
- 리액트를 사용하더라도 DOM을 직접 선택해야 하는 상황이 발생한다. 예를들어
  - 특정 엘리먼트의 크기를 가져와야 한다거나
  - 스크롤바 위치를 가져오거나 설정해야 된다던지
  - 또는 포커스를 설정해줘야 된다던지 등 다양한 상황이 있다.
  - Video.js, JWPlayer같은 HTML5 Video 관련 라이브러리 또는 D3, char.js 같은 그래프 관련 라이브러리 등의 외부 라이브러리도 특정 DOM에다 적용하기 때문에 DOM을 선택해야 하는 상황이 발생할 수 있다.
- 이럴 땐, 리액트에서 `ref` 라는 것을 사용한다.
  - 함수형 컴포넌트에서 `ref`를 사용할 때 `useRef` 라는 Hook 함수를 사용한다.
  - 클래스형 컴포넌트에서는 콜백 함수를 사용하거나 `React.createRef` 라는 함수를 사용한다. (참고로 클래스 컴포넌트는 이제 별로 중요하지 않다.)
- InputSample에서 초기화 버튼을 누르면 포커스가 초기화 버튼에 그대로 남아있게 되는데, input에 포커스가 잡히도록 `useRef`를 사용해보자.

## 11. 배열 렌더링하기
- 배열을 컴포넌트로 렌더링한다고 할 때, 가장 기본적인 방법으론 비효율적이지만 그냥 그대로 코드를 작성하는 것이다.
- 배열이 고정적이라면 상관없겠지만, 배열의 인덱스를 하나하나 조회해가면서 렌더링하는 방법은 동적인 배열을 렌더링하지 못한다.
- 동적인 배열을 렌더링해야 할 때에는 js 배열의 내장함수 `map()`을 사용한다.
- 리액트에서 배열을 렌더링 할 때에는 `key` 라는 props를 설정해야한다.
- `key` 값은 각 원소들마다 가지고 있는 고유값으로 설정을 해야한다. 지금의 경우엔 `id`가 고유 값이다.
  - 만약 배열 안의 원소가 가지고 있는 고유한 값이 없다면 `map()` 함수를 사용 할 때 설정하는 콜백함수의 두번째 파라미터 `index`를 `key`로 사용하면 된다.
- 배열 렌더링시에 `key` 설정 하지 않으면 기본적으로 배열의 `index` 값을 `key` 로 사용하게 되고, 경고메시지가 뜬다. 
- 경고 메시지가 뜨는 이유는, 각 고유 원소에 `key`가 있어야만 배열이 업데이트 될 때 효율적으로 렌더링 될 수 있기 때문이다.

**key 의 존재유무에 따른 업데이트 방식**

1. key가 없을 때
```
const array = ['a', 'b', 'c', 'd'];

array.map(item => <div>{item></div>});
```
- 위 배열의 b c 사이에 z를 삽입하면, 리렌더링 할 때 
- <div>b</div> 와 <div>c</div> 사이에 <div> 태그를 삽입하는게 아니다.
- c가 z로 바뀌고, d는 c로 바뀌고 맨 마지막에 d가 새로 삽입된다.

2. key가 있을 때 
```
[
  {
    id: 0,
    text: 'a'
  },
  {
    id: 1,
    text: 'b'
  },
  {
    id: 2,
    text: 'c'
  },
  {
    id: 3,
    text: 'd'
  }
];

array.map(item => <div key={item.id}>{item.text}</div>);
```

- 배열이 업데이트될 때 수정되지 않는 기존의 값은 그대로 두고 원하는 곳에 내용을 삽입하거나 삭제한다.
- 만약 배열안에 중복되는 `key`가 있을 때에는 렌더링시에 오류메시지가 콘솔에 나타나게 되고, 업데이트가 제대로 이루어지지 않는다. 