
# 1. 리액트 입문 

## 1. 리액트는 어쩌다가 만들어졌을까?
- 리액트라는 라이브러리가 어쩌다 만들어졌는지 부터 살펴보자.
- JS + HTML 로 구성한 UI에선, DOM을 변형시키기 위해서는 DOM Selector API를 사용해서 특정 DOM을 선택한 뒤, 특정 이벤트가 발생하면 변화를 준다.
- 사용자와의 인터랙션이 별로 없는 웹페이지라면 상관없겠지만, 만약에 인터랙션이 자주 ㅂ라생하고, 이에 따라 동적으로 UI를 표현해야하면, 규칙이 다양해지고 관리도 힘들어진다.
- 대부분의 웹 애플리케이션의 규모가 커지면, DOM을 직접 건드리면서 작업을 하면 코드가 난잡해지기 쉽다.
- 그래서 Ember, Backbone, AngularJS 등의 프레임워크가 만들어졌었는데, 이 프레임워크들은 쉽게 설명하면 JS의 특정 값이 바뀌면 DOM의 속성이 바뀌도록 연결을 해주어서, 업데이트 하는 작업을 간소화해주는 방식으로 웹개발의 어려움을 해결해주었다.
- 하지만 리액트는 어떠한 상태가 바뀌었을 때, 그 상태에 따라 DOM을 어떻게 업데이트 할 지 규칙을 정하는 게 아니라, 아예 다 날려버리고 처음부터 모든걸 새로 만들어서 보여준다 라는 아이디어로 시작됐다.
- 동적인 UI를 보여주기 위해서 모든걸 다 날려버리고 모든걸 새로 만들면 속도가 굉장히 느리고, 규모가 큰 웹애플리케이션이라면 상상하기 힘들다.
- 하지만 리액트에서는 Virtual DOM이라는 것을 사용해서 이를 가능하게 했다.
- Virtual DOM은 가상의 DOM이고, 가상으로 존재하는 DOM으로서 그냥 JS 객체이기 떄문에 작동 성능이 실제로 브라우저에서 DOM을 보여주는 것보다 속도가 훨씬 빠르다.
- 리액트는 상태가 업데이트 되면, 업데이트가 필요한 곳의 UI 를 Virtual DOM을 통해서 렌더링한다.
- 그리고 나서 리액트 개발팀이 만든 매우 효율적인 비교 알고리즘을 통해 실제 브라우저에 보여지고 잇는 DOM과 비교 한 후, 차이가 있는 곳을 감지해서 DOM에 패치시켜준다.
- 이를 통해서 "업데이트를 어떻게 할 지"에 대한 고민을 하지 않으면서 빠른 성능도 지켜낼 수 있었다.

## 2. 작업환경 준비 
- Node.js
  - Webpack 과 Babel 같은 도구들이 js 런타임인 Node.js 기반으로 만들어져있어서 설치 필요.
- Yarn
  - npm의 개선된 버전. 
  - npm은 Node.js를 설치할 때 같이 딸려오는 패키지 매니저 도구. 
  - 프로젝트에서 사용되는 라이브러리를 설치하고 해당 라이브러리들의 버전 관리 할 때 사용. 
  - Yarn을 사용하는 이유는, 더 나은 속도와 더 나은 캐싱 시스템을 사용하기 위함.
- Webpack, Babel
  - 리액트를 사용하면서 컴포넌트를 여러가지 파일로 분리해서 저장하는데, 이 컴포넌트는 일반 자바스크립트가 아닌 JSX 라는 문법으로 작성하게 된다. 
  - 여러가지의 파일을 한개로 결합하기 위해서 Webpack 이라는 도구를 사용한다.
  - JSX를 비롯한 새로운 자바스크립트 문법들을 사용하기 위해 Babel 이라는 도구를 사용한다.

Node.js 설치
```
$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
$ nvm install --lts
``` 

Yarn 설치
```
brew install yarn
```

새 프로젝트 만들어보기
```
npx create-react-app begin-react
cd begin-react
yarn start
```

## 3. 나의 첫번째 리액트 컴포넌트
- 리액트 컴포넌트를 만들 땐 아래 코드를 통해 리액트를 불러와야 한다.
```js
import React from 'react';
```

- 리액트 컴포넌트에서 XML 형식의 값을 반환해줄 수 있는데 이를 JSX라고 부른다. 
- 아래 코드는 Hello 라는 컴포넌트를 내보내겠다는 의미이다.
```js
export default Hello;
```

- 컴포넌트는 일종의 UI 조각이고, 쉽게 재사용할 수 있다. 
- 실제 DOM 내부에 리액트 컴포넌트를 렌더링한다.
- 리액트 컴포넌트가 렌더링 될 때에는, 렌더링된 결과물 위 div 내부에 렌더링되는 것이다.


## 4. JSX

- 리액트 컴포넌트 파일에서 XML 형태로 코드를 작성하면 babel이 JSX를 js로 변환해준다.
- Babel은 js의 문법을 확장해주는 도구이고, 아직 지원되지 않는 최신 문법이나, 편의상 사용하거나 실험적인 js 문법들을 정식 js 형태로 변환해줌으로써 구형 브라우저에서도 제대로 실행할 수 있게 해줌.
- JSX가 js로 제대로 변환 되려면 지켜줘야하는 규칙이 몇가지 있다.
  - 태그는 꼭 닫혀야 한다.
  - 두가지 이상의 태그는 무조건 하나의 태그로 감싸져있어야 함.
  - JSX안에 js 값 사용하려면 {}로 감싸줘야함.
  - CSS class를 설정할 땐 `class=` 가 아닌 `className=` 으로 설정해줘야 한다.
  - 주석은 {/* */}, // 으로 사용한다.

## 5. props 를 통해 컴포넌트에게 값 전달하기 
- props는 properties의 줄임말.
- 어떠한 값을 컴포넌트에게 전달해줘야 할 때 사용함.

- props의 기본 사용법
- 여러 개의 props, 비구조화 할당
- defaultProps로 기본값 설정
- props.children

## 6. 조건부 렌더링
- 특정 조건에 따라 다른 결과물을 렌더링 하는 것을 의미
- JSX에서 null, false, undefined를 렌더링하면 아무것도 나타나지 않는다.
- 보통 삼항연산자를 사용해서 조건부 렌더링을 처리한다.
- props 값 설정을 생략하면 ={true} 이다

## 7. useState 를 통해 컴포넌트에서 바뀌는 값 관리하기
- 리액트 16.8 이전 버전에서는 함수형 컴포넌트에서는 상태관리할 수 없었다.
- 리액트 16.8에서 Hooks라는 기능이 도입되면서 함수형 컴포넌트에서도 상태를 관리할 수 있게 됐다.
- useState라는 함수가 리액트의 Hooks 중 하나이다.
- 함수형 업데이트는 주로 컴포넌트 최적화를 하게 될 때 사용하게 된다. 

## 8. input 상태 관리하기 
- 이번에도, useState를 사용
- 이번에는 input의 `onChange` 라는 이벤트를 사용.
- 이벤트에 등록하는 함수에서 이벤트 객체를 `e`를 파라미터로 받아와서 사용 하는데
  - 이 객체의 `e.target`은 이벤트가 발생한 DOM 인 input DOM
  - `e.tar.value`는 이 DOM의 `value` 값, 이값을 조회하면 현재 input에 입력한 값이 무엇인지 알 수 있음 